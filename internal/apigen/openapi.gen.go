// Package apigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package apigen

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	TokenScopes = "token.Scopes"
)

// Defines values for APIKeyOrganizationRoles.
const (
	APIKeyOrganizationRolesOrganizationMember APIKeyOrganizationRoles = "organizationMember"
	APIKeyOrganizationRolesOrganizationOwner  APIKeyOrganizationRoles = "organizationOwner"
	APIKeyOrganizationRolesProjectCreator     APIKeyOrganizationRoles = "projectCreator"
)

// Defines values for APIKeyResourcesItemsRoles.
const (
	APIKeyResourcesItemsRolesProjectDataReader       APIKeyResourcesItemsRoles = "projectDataReader"
	APIKeyResourcesItemsRolesProjectDataReaderWriter APIKeyResourcesItemsRoles = "projectDataReaderWriter"
	APIKeyResourcesItemsRolesProjectManager          APIKeyResourcesItemsRoles = "projectManager"
	APIKeyResourcesItemsRolesProjectOwner            APIKeyResourcesItemsRoles = "projectOwner"
	APIKeyResourcesItemsRolesProjectViewer           APIKeyResourcesItemsRoles = "projectViewer"
)

// Defines values for AllowedCidrStatus.
const (
	AllowedCidrStatusActive  AllowedCidrStatus = "active"
	AllowedCidrStatusExpired AllowedCidrStatus = "expired"
)

// Defines values for AllowedCidrType.
const (
	AllowedCidrTypePermanent AllowedCidrType = "permanent"
	AllowedCidrTypeTemporary AllowedCidrType = "temporary"
)

// Defines values for AppServiceAllowedCidrStatus.
const (
	AppServiceAllowedCidrStatusActive  AppServiceAllowedCidrStatus = "active"
	AppServiceAllowedCidrStatusExpired AppServiceAllowedCidrStatus = "expired"
)

// Defines values for AppServiceAllowedCidrType.
const (
	AppServiceAllowedCidrTypePermanent AppServiceAllowedCidrType = "permanent"
	AppServiceAllowedCidrTypeTemporary AppServiceAllowedCidrType = "temporary"
)

// Defines values for AppServiceStates.
const (
	AppServiceStatesDegraded         AppServiceStates = "degraded"
	AppServiceStatesDeploying        AppServiceStates = "deploying"
	AppServiceStatesDeploymentFailed AppServiceStates = "deploymentFailed"
	AppServiceStatesDestroyFailed    AppServiceStates = "destroyFailed"
	AppServiceStatesDestroying       AppServiceStates = "destroying"
	AppServiceStatesHealthy          AppServiceStates = "healthy"
	AppServiceStatesPending          AppServiceStates = "pending"
	AppServiceStatesScaleFailed      AppServiceStates = "scaleFailed"
	AppServiceStatesScaling          AppServiceStates = "scaling"
	AppServiceStatesTurnOffFailed    AppServiceStates = "turnOffFailed"
	AppServiceStatesTurnOnFailed     AppServiceStates = "turnOnFailed"
	AppServiceStatesTurnedOff        AppServiceStates = "turnedOff"
	AppServiceStatesTurningOff       AppServiceStates = "turningOff"
	AppServiceStatesTurningOn        AppServiceStates = "turningOn"
	AppServiceStatesUpgradeFailed    AppServiceStates = "upgradeFailed"
	AppServiceStatesUpgrading        AppServiceStates = "upgrading"
)

// Defines values for AvailabilityType.
const (
	Multi  AvailabilityType = "multi"
	Single AvailabilityType = "single"
)

// Defines values for BucketConflictResolution.
const (
	Lww   BucketConflictResolution = "lww"
	Seqno BucketConflictResolution = "seqno"
)

// Defines values for CachingDefaultCache.
const (
	Semantic CachingDefaultCache = "semantic"
	Standard CachingDefaultCache = "standard"
)

// Defines values for CloudConfigComputeCpu.
const (
	CloudConfigComputeCpuN32 CloudConfigComputeCpu = 32
	CloudConfigComputeCpuN4  CloudConfigComputeCpu = 4
)

// Defines values for CloudConfigComputeGpuMemory.
const (
	N192 CloudConfigComputeGpuMemory = 192
	N24  CloudConfigComputeGpuMemory = 24
	N48  CloudConfigComputeGpuMemory = 48
)

// Defines values for CloudConfigProvider.
const (
	CloudConfigProviderAws   CloudConfigProvider = "aws"
	CloudConfigProviderAzure CloudConfigProvider = "azure"
	CloudConfigProviderGcp   CloudConfigProvider = "gcp"
)

// Defines values for CloudProviderType.
const (
	CloudProviderTypeAws   CloudProviderType = "aws"
	CloudProviderTypeAzure CloudProviderType = "azure"
	CloudProviderTypeGcp   CloudProviderType = "gcp"
)

// Defines values for ClusterOnOffScheduleTimezone.
const (
	ClusterOnOffScheduleTimezoneAfricaNairobi               ClusterOnOffScheduleTimezone = "Africa/Nairobi"
	ClusterOnOffScheduleTimezoneAmericaArgentinaBuenosAires ClusterOnOffScheduleTimezone = "America/Argentina/Buenos_Aires"
	ClusterOnOffScheduleTimezoneAmericaPuertoRico           ClusterOnOffScheduleTimezone = "America/Puerto_Rico"
	ClusterOnOffScheduleTimezoneAntarcticaSouthPole         ClusterOnOffScheduleTimezone = "Antarctica/South_Pole"
	ClusterOnOffScheduleTimezoneAsiaBangkok                 ClusterOnOffScheduleTimezone = "Asia/Bangkok"
	ClusterOnOffScheduleTimezoneAsiaCalcutta                ClusterOnOffScheduleTimezone = "Asia/Calcutta"
	ClusterOnOffScheduleTimezoneAsiaDhaka                   ClusterOnOffScheduleTimezone = "Asia/Dhaka"
	ClusterOnOffScheduleTimezoneAsiaHongKong                ClusterOnOffScheduleTimezone = "Asia/Hong_Kong"
	ClusterOnOffScheduleTimezoneAsiaKarachi                 ClusterOnOffScheduleTimezone = "Asia/Karachi"
	ClusterOnOffScheduleTimezoneAsiaTehran                  ClusterOnOffScheduleTimezone = "Asia/Tehran"
	ClusterOnOffScheduleTimezoneAsiaTokyo                   ClusterOnOffScheduleTimezone = "Asia/Tokyo"
	ClusterOnOffScheduleTimezoneAtlanticCapeVerde           ClusterOnOffScheduleTimezone = "Atlantic/Cape_Verde"
	ClusterOnOffScheduleTimezoneAustraliaNorth              ClusterOnOffScheduleTimezone = "Australia/North"
	ClusterOnOffScheduleTimezoneAustraliaSydney             ClusterOnOffScheduleTimezone = "Australia/Sydney"
	ClusterOnOffScheduleTimezoneCanadaNewfoundland          ClusterOnOffScheduleTimezone = "Canada/Newfoundland"
	ClusterOnOffScheduleTimezoneEuropeAmsterdam             ClusterOnOffScheduleTimezone = "Europe/Amsterdam"
	ClusterOnOffScheduleTimezoneEuropeAthens                ClusterOnOffScheduleTimezone = "Europe/Athens"
	ClusterOnOffScheduleTimezoneEuropeLondon                ClusterOnOffScheduleTimezone = "Europe/London"
	ClusterOnOffScheduleTimezoneIndianMauritius             ClusterOnOffScheduleTimezone = "Indian/Mauritius"
	ClusterOnOffScheduleTimezonePacificMidway               ClusterOnOffScheduleTimezone = "Pacific/Midway"
	ClusterOnOffScheduleTimezonePacificPonape               ClusterOnOffScheduleTimezone = "Pacific/Ponape"
	ClusterOnOffScheduleTimezoneUSAlaska                    ClusterOnOffScheduleTimezone = "US/Alaska"
	ClusterOnOffScheduleTimezoneUSCentral                   ClusterOnOffScheduleTimezone = "US/Central"
	ClusterOnOffScheduleTimezoneUSEastern                   ClusterOnOffScheduleTimezone = "US/Eastern"
	ClusterOnOffScheduleTimezoneUSHawaii                    ClusterOnOffScheduleTimezone = "US/Hawaii"
	ClusterOnOffScheduleTimezoneUSMountain                  ClusterOnOffScheduleTimezone = "US/Mountain"
	ClusterOnOffScheduleTimezoneUSPacific                   ClusterOnOffScheduleTimezone = "US/Pacific"
)

// Defines values for ColumnarAnalyticsOnOffScheduleTimezone.
const (
	ColumnarAnalyticsOnOffScheduleTimezoneAfricaNairobi               ColumnarAnalyticsOnOffScheduleTimezone = "Africa/Nairobi"
	ColumnarAnalyticsOnOffScheduleTimezoneAmericaArgentinaBuenosAires ColumnarAnalyticsOnOffScheduleTimezone = "America/Argentina/Buenos_Aires"
	ColumnarAnalyticsOnOffScheduleTimezoneAmericaPuertoRico           ColumnarAnalyticsOnOffScheduleTimezone = "America/Puerto_Rico"
	ColumnarAnalyticsOnOffScheduleTimezoneAntarcticaSouthPole         ColumnarAnalyticsOnOffScheduleTimezone = "Antarctica/South_Pole"
	ColumnarAnalyticsOnOffScheduleTimezoneAsiaBangkok                 ColumnarAnalyticsOnOffScheduleTimezone = "Asia/Bangkok"
	ColumnarAnalyticsOnOffScheduleTimezoneAsiaCalcutta                ColumnarAnalyticsOnOffScheduleTimezone = "Asia/Calcutta"
	ColumnarAnalyticsOnOffScheduleTimezoneAsiaDhaka                   ColumnarAnalyticsOnOffScheduleTimezone = "Asia/Dhaka"
	ColumnarAnalyticsOnOffScheduleTimezoneAsiaHongKong                ColumnarAnalyticsOnOffScheduleTimezone = "Asia/Hong_Kong"
	ColumnarAnalyticsOnOffScheduleTimezoneAsiaKarachi                 ColumnarAnalyticsOnOffScheduleTimezone = "Asia/Karachi"
	ColumnarAnalyticsOnOffScheduleTimezoneAsiaTehran                  ColumnarAnalyticsOnOffScheduleTimezone = "Asia/Tehran"
	ColumnarAnalyticsOnOffScheduleTimezoneAsiaTokyo                   ColumnarAnalyticsOnOffScheduleTimezone = "Asia/Tokyo"
	ColumnarAnalyticsOnOffScheduleTimezoneAtlanticCapeVerde           ColumnarAnalyticsOnOffScheduleTimezone = "Atlantic/Cape_Verde"
	ColumnarAnalyticsOnOffScheduleTimezoneAustraliaNorth              ColumnarAnalyticsOnOffScheduleTimezone = "Australia/North"
	ColumnarAnalyticsOnOffScheduleTimezoneAustraliaSydney             ColumnarAnalyticsOnOffScheduleTimezone = "Australia/Sydney"
	ColumnarAnalyticsOnOffScheduleTimezoneCanadaNewfoundland          ColumnarAnalyticsOnOffScheduleTimezone = "Canada/Newfoundland"
	ColumnarAnalyticsOnOffScheduleTimezoneEuropeAmsterdam             ColumnarAnalyticsOnOffScheduleTimezone = "Europe/Amsterdam"
	ColumnarAnalyticsOnOffScheduleTimezoneEuropeAthens                ColumnarAnalyticsOnOffScheduleTimezone = "Europe/Athens"
	ColumnarAnalyticsOnOffScheduleTimezoneEuropeLondon                ColumnarAnalyticsOnOffScheduleTimezone = "Europe/London"
	ColumnarAnalyticsOnOffScheduleTimezoneIndianMauritius             ColumnarAnalyticsOnOffScheduleTimezone = "Indian/Mauritius"
	ColumnarAnalyticsOnOffScheduleTimezonePacificMidway               ColumnarAnalyticsOnOffScheduleTimezone = "Pacific/Midway"
	ColumnarAnalyticsOnOffScheduleTimezonePacificPonape               ColumnarAnalyticsOnOffScheduleTimezone = "Pacific/Ponape"
	ColumnarAnalyticsOnOffScheduleTimezoneUSAlaska                    ColumnarAnalyticsOnOffScheduleTimezone = "US/Alaska"
	ColumnarAnalyticsOnOffScheduleTimezoneUSCentral                   ColumnarAnalyticsOnOffScheduleTimezone = "US/Central"
	ColumnarAnalyticsOnOffScheduleTimezoneUSEastern                   ColumnarAnalyticsOnOffScheduleTimezone = "US/Eastern"
	ColumnarAnalyticsOnOffScheduleTimezoneUSHawaii                    ColumnarAnalyticsOnOffScheduleTimezone = "US/Hawaii"
	ColumnarAnalyticsOnOffScheduleTimezoneUSMountain                  ColumnarAnalyticsOnOffScheduleTimezone = "US/Mountain"
	ColumnarAnalyticsOnOffScheduleTimezoneUSPacific                   ColumnarAnalyticsOnOffScheduleTimezone = "US/Pacific"
)

// Defines values for ColumnarSupportPlan.
const (
	ColumnarSupportPlanDeveloperPro ColumnarSupportPlan = "developer pro"
	ColumnarSupportPlanEnterprise   ColumnarSupportPlan = "enterprise"
)

// Defines values for ColumnarSupportTimezone.
const (
	ColumnarSupportTimezoneET  ColumnarSupportTimezone = "ET"
	ColumnarSupportTimezoneGMT ColumnarSupportTimezone = "GMT"
	ColumnarSupportTimezoneIST ColumnarSupportTimezone = "IST"
	ColumnarSupportTimezonePT  ColumnarSupportTimezone = "PT"
)

// Defines values for ConfigOptimization.
const (
	ConfigOptimizationLatency    ConfigOptimization = "latency"
	ConfigOptimizationThroughput ConfigOptimization = "throughput"
)

// Defines values for ConfigProvider.
const (
	Meta   ConfigProvider = "meta"
	Nvidia ConfigProvider = "nvidia"
)

// Defines values for ConfigQuantization.
const (
	ConfigQuantizationFp16          ConfigQuantization = "fp16"
	ConfigQuantizationFp8           ConfigQuantization = "fp8"
	ConfigQuantizationFullPrecision ConfigQuantization = "fullPrecision"
)

// Defines values for ConfigType.
const (
	ConfigTypeEmbeddingGeneration ConfigType = "embedding-generation"
	ConfigTypeModeration          ConfigType = "moderation"
	ConfigTypePromptInjection     ConfigType = "prompt-injection"
	ConfigTypeTextGeneration      ConfigType = "text-generation"
)

// Defines values for ConfigurationType.
const (
	MultiNode  ConfigurationType = "multiNode"
	SingleNode ConfigurationType = "singleNode"
)

// Defines values for CreateAlertRequestKind.
const (
	CreateAlertRequestKindWebhook CreateAlertRequestKind = "webhook"
)

// Defines values for CreateBucketRequestVbuckets.
const (
	CreateBucketRequestVbucketsN1024 CreateBucketRequestVbuckets = 1024
	CreateBucketRequestVbucketsN128  CreateBucketRequestVbuckets = 128
)

// Defines values for CreateColumnarAnalyticsClusterRequestCloudProvider.
const (
	Aws CreateColumnarAnalyticsClusterRequestCloudProvider = "aws"
	Gcp CreateColumnarAnalyticsClusterRequestCloudProvider = "gcp"
)

// Defines values for CreateOnDemandRestoreRequestReplaceTTL.
const (
	CreateOnDemandRestoreRequestReplaceTTLAll     CreateOnDemandRestoreRequestReplaceTTL = "all"
	CreateOnDemandRestoreRequestReplaceTTLExpired CreateOnDemandRestoreRequestReplaceTTL = "expired"
	CreateOnDemandRestoreRequestReplaceTTLNone    CreateOnDemandRestoreRequestReplaceTTL = "none"
)

// Defines values for CreateProviderRequestType.
const (
	CreateProviderRequestTypeAwsS3  CreateProviderRequestType = "awsS3"
	CreateProviderRequestTypeOpenAI CreateProviderRequestType = "openAI"
)

// Defines values for CreateReplicationRequestDirection.
const (
	CreateReplicationRequestDirectionOneWay CreateReplicationRequestDirection = "oneWay"
	CreateReplicationRequestDirectionTwoWay CreateReplicationRequestDirection = "twoWay"
)

// Defines values for CreateReplicationRequestMode.
const (
	Sync CreateReplicationRequestMode = "sync"
)

// Defines values for CreateReplicationRequestPriority.
const (
	CreateReplicationRequestPriorityHigh   CreateReplicationRequestPriority = "high"
	CreateReplicationRequestPriorityLow    CreateReplicationRequestPriority = "low"
	CreateReplicationRequestPriorityMedium CreateReplicationRequestPriority = "medium"
)

// Defines values for CreateReplicationRequestTargetType.
const (
	CreateReplicationRequestTargetTypeCapella  CreateReplicationRequestTargetType = "capella"
	CreateReplicationRequestTargetTypeExternal CreateReplicationRequestTargetType = "external"
)

// Defines values for CreateScheduledBackupRequestType.
const (
	Weekly CreateScheduledBackupRequestType = "weekly"
)

// Defines values for CreateScheduledBackupRequestWeeklyScheduleDayOfWeek.
const (
	CreateScheduledBackupRequestWeeklyScheduleDayOfWeekFriday    CreateScheduledBackupRequestWeeklyScheduleDayOfWeek = "friday"
	CreateScheduledBackupRequestWeeklyScheduleDayOfWeekMonday    CreateScheduledBackupRequestWeeklyScheduleDayOfWeek = "monday"
	CreateScheduledBackupRequestWeeklyScheduleDayOfWeekSaturday  CreateScheduledBackupRequestWeeklyScheduleDayOfWeek = "saturday"
	CreateScheduledBackupRequestWeeklyScheduleDayOfWeekSunday    CreateScheduledBackupRequestWeeklyScheduleDayOfWeek = "sunday"
	CreateScheduledBackupRequestWeeklyScheduleDayOfWeekThursday  CreateScheduledBackupRequestWeeklyScheduleDayOfWeek = "thursday"
	CreateScheduledBackupRequestWeeklyScheduleDayOfWeekTuesday   CreateScheduledBackupRequestWeeklyScheduleDayOfWeek = "tuesday"
	CreateScheduledBackupRequestWeeklyScheduleDayOfWeekWednesday CreateScheduledBackupRequestWeeklyScheduleDayOfWeek = "wednesday"
)

// Defines values for CreateScheduledBackupRequestWeeklyScheduleIncrementalEvery.
const (
	CreateScheduledBackupRequestWeeklyScheduleIncrementalEveryN1  CreateScheduledBackupRequestWeeklyScheduleIncrementalEvery = 1
	CreateScheduledBackupRequestWeeklyScheduleIncrementalEveryN12 CreateScheduledBackupRequestWeeklyScheduleIncrementalEvery = 12
	CreateScheduledBackupRequestWeeklyScheduleIncrementalEveryN2  CreateScheduledBackupRequestWeeklyScheduleIncrementalEvery = 2
	CreateScheduledBackupRequestWeeklyScheduleIncrementalEveryN24 CreateScheduledBackupRequestWeeklyScheduleIncrementalEvery = 24
	CreateScheduledBackupRequestWeeklyScheduleIncrementalEveryN4  CreateScheduledBackupRequestWeeklyScheduleIncrementalEvery = 4
	CreateScheduledBackupRequestWeeklyScheduleIncrementalEveryN6  CreateScheduledBackupRequestWeeklyScheduleIncrementalEvery = 6
	CreateScheduledBackupRequestWeeklyScheduleIncrementalEveryN8  CreateScheduledBackupRequestWeeklyScheduleIncrementalEvery = 8
)

// Defines values for CreateScheduledBackupRequestWeeklyScheduleRetentionTime.
const (
	N180days CreateScheduledBackupRequestWeeklyScheduleRetentionTime = "180days"
	N1year   CreateScheduledBackupRequestWeeklyScheduleRetentionTime = "1year"
	N2years  CreateScheduledBackupRequestWeeklyScheduleRetentionTime = "2years"
	N30days  CreateScheduledBackupRequestWeeklyScheduleRetentionTime = "30days"
	N3years  CreateScheduledBackupRequestWeeklyScheduleRetentionTime = "3years"
	N4years  CreateScheduledBackupRequestWeeklyScheduleRetentionTime = "4years"
	N5years  CreateScheduledBackupRequestWeeklyScheduleRetentionTime = "5years"
	N60days  CreateScheduledBackupRequestWeeklyScheduleRetentionTime = "60days"
	N90days  CreateScheduledBackupRequestWeeklyScheduleRetentionTime = "90days"
)

// Defines values for CreateScheduledBackupRequestWeeklyScheduleStartAt.
const (
	CreateScheduledBackupRequestWeeklyScheduleStartAtN0  CreateScheduledBackupRequestWeeklyScheduleStartAt = 0
	CreateScheduledBackupRequestWeeklyScheduleStartAtN1  CreateScheduledBackupRequestWeeklyScheduleStartAt = 1
	CreateScheduledBackupRequestWeeklyScheduleStartAtN10 CreateScheduledBackupRequestWeeklyScheduleStartAt = 10
	CreateScheduledBackupRequestWeeklyScheduleStartAtN11 CreateScheduledBackupRequestWeeklyScheduleStartAt = 11
	CreateScheduledBackupRequestWeeklyScheduleStartAtN12 CreateScheduledBackupRequestWeeklyScheduleStartAt = 12
	CreateScheduledBackupRequestWeeklyScheduleStartAtN13 CreateScheduledBackupRequestWeeklyScheduleStartAt = 13
	CreateScheduledBackupRequestWeeklyScheduleStartAtN14 CreateScheduledBackupRequestWeeklyScheduleStartAt = 14
	CreateScheduledBackupRequestWeeklyScheduleStartAtN15 CreateScheduledBackupRequestWeeklyScheduleStartAt = 15
	CreateScheduledBackupRequestWeeklyScheduleStartAtN16 CreateScheduledBackupRequestWeeklyScheduleStartAt = 16
	CreateScheduledBackupRequestWeeklyScheduleStartAtN17 CreateScheduledBackupRequestWeeklyScheduleStartAt = 17
	CreateScheduledBackupRequestWeeklyScheduleStartAtN18 CreateScheduledBackupRequestWeeklyScheduleStartAt = 18
	CreateScheduledBackupRequestWeeklyScheduleStartAtN19 CreateScheduledBackupRequestWeeklyScheduleStartAt = 19
	CreateScheduledBackupRequestWeeklyScheduleStartAtN2  CreateScheduledBackupRequestWeeklyScheduleStartAt = 2
	CreateScheduledBackupRequestWeeklyScheduleStartAtN20 CreateScheduledBackupRequestWeeklyScheduleStartAt = 20
	CreateScheduledBackupRequestWeeklyScheduleStartAtN21 CreateScheduledBackupRequestWeeklyScheduleStartAt = 21
	CreateScheduledBackupRequestWeeklyScheduleStartAtN22 CreateScheduledBackupRequestWeeklyScheduleStartAt = 22
	CreateScheduledBackupRequestWeeklyScheduleStartAtN23 CreateScheduledBackupRequestWeeklyScheduleStartAt = 23
	CreateScheduledBackupRequestWeeklyScheduleStartAtN3  CreateScheduledBackupRequestWeeklyScheduleStartAt = 3
	CreateScheduledBackupRequestWeeklyScheduleStartAtN4  CreateScheduledBackupRequestWeeklyScheduleStartAt = 4
	CreateScheduledBackupRequestWeeklyScheduleStartAtN5  CreateScheduledBackupRequestWeeklyScheduleStartAt = 5
	CreateScheduledBackupRequestWeeklyScheduleStartAtN6  CreateScheduledBackupRequestWeeklyScheduleStartAt = 6
	CreateScheduledBackupRequestWeeklyScheduleStartAtN7  CreateScheduledBackupRequestWeeklyScheduleStartAt = 7
	CreateScheduledBackupRequestWeeklyScheduleStartAtN8  CreateScheduledBackupRequestWeeklyScheduleStartAt = 8
	CreateScheduledBackupRequestWeeklyScheduleStartAtN9  CreateScheduledBackupRequestWeeklyScheduleStartAt = 9
)

// Defines values for CreateStructuredWorkflowRequestStructuredDataProcessingConfigJsonType.
const (
	CreateStructuredWorkflowRequestStructuredDataProcessingConfigJsonTypeJson      CreateStructuredWorkflowRequestStructuredDataProcessingConfigJsonType = "json"
	CreateStructuredWorkflowRequestStructuredDataProcessingConfigJsonTypeJsonlines CreateStructuredWorkflowRequestStructuredDataProcessingConfigJsonType = "jsonlines"
	CreateStructuredWorkflowRequestStructuredDataProcessingConfigJsonTypeJsonlist  CreateStructuredWorkflowRequestStructuredDataProcessingConfigJsonType = "jsonlist"
)

// Defines values for CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigChunkingStrategyStrategyType.
const (
	CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigChunkingStrategyStrategyTypeFIXEDTOKENSPLITTER CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigChunkingStrategyStrategyType = "FIXED_TOKEN_SPLITTER"
	CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigChunkingStrategyStrategyTypePARAGRAPHSPLITTER  CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigChunkingStrategyStrategyType = "PARAGRAPH_SPLITTER"
	CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigChunkingStrategyStrategyTypeRECURSIVESPLITTER  CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigChunkingStrategyStrategyType = "RECURSIVE_SPLITTER"
	CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigChunkingStrategyStrategyTypeSEMANTICSPLITTER   CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigChunkingStrategyStrategyType = "SEMANTIC_SPLITTER"
	CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigChunkingStrategyStrategyTypeSENTENCESPLITTER   CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigChunkingStrategyStrategyType = "SENTENCE_SPLITTER"
)

// Defines values for CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigExclusions.
const (
	CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigExclusionsFooter CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigExclusions = "footer"
	CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigExclusionsHeader CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigExclusions = "header"
	CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigExclusionsTable  CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigExclusions = "table"
)

// Defines values for CreateWorkflowRequestType.
const (
	CreateWorkflowRequestTypeStructuredDataProcessing   CreateWorkflowRequestType = "structuredDataProcessing"
	CreateWorkflowRequestTypeUnstructuredDataProcessing CreateWorkflowRequestType = "unstructuredDataProcessing"
	CreateWorkflowRequestTypeVectorization              CreateWorkflowRequestType = "vectorization"
)

// Defines values for CurrentColumnarState.
const (
	CurrentColumnarStateDeploying        CurrentColumnarState = "deploying"
	CurrentColumnarStateDeploymentFailed CurrentColumnarState = "deploymentFailed"
	CurrentColumnarStateDestroyFailed    CurrentColumnarState = "destroyFailed"
	CurrentColumnarStateDestroying       CurrentColumnarState = "destroying"
	CurrentColumnarStateHealthy          CurrentColumnarState = "healthy"
	CurrentColumnarStateScaleFailed      CurrentColumnarState = "scaleFailed"
	CurrentColumnarStateScaling          CurrentColumnarState = "scaling"
	CurrentColumnarStateTurnedOff        CurrentColumnarState = "turnedOff"
	CurrentColumnarStateTurningOff       CurrentColumnarState = "turningOff"
	CurrentColumnarStateTurningOn        CurrentColumnarState = "turningOn"
)

// Defines values for CurrentState.
const (
	CurrentStateDegraded         CurrentState = "degraded"
	CurrentStateDeploying        CurrentState = "deploying"
	CurrentStateDeploymentFailed CurrentState = "deploymentFailed"
	CurrentStateDestroyFailed    CurrentState = "destroyFailed"
	CurrentStateDestroying       CurrentState = "destroying"
	CurrentStateDraft            CurrentState = "draft"
	CurrentStateHealthy          CurrentState = "healthy"
	CurrentStateOffline          CurrentState = "offline"
	CurrentStatePeering          CurrentState = "peering"
	CurrentStatePeeringFailed    CurrentState = "peeringFailed"
	CurrentStateRebalanceFailed  CurrentState = "rebalanceFailed"
	CurrentStateRebalancing      CurrentState = "rebalancing"
	CurrentStateScaleFailed      CurrentState = "scaleFailed"
	CurrentStateScaling          CurrentState = "scaling"
	CurrentStateTurnedOff        CurrentState = "turnedOff"
	CurrentStateTurningOff       CurrentState = "turningOff"
	CurrentStateTurningOffFailed CurrentState = "turningOffFailed"
	CurrentStateTurningOn        CurrentState = "turningOn"
	CurrentStateTurningOnFailed  CurrentState = "turningOnFailed"
	CurrentStateUpgradeFailed    CurrentState = "upgradeFailed"
	CurrentStateUpgrading        CurrentState = "upgrading"
)

// Defines values for DaysDay.
const (
	DaysDayFriday    DaysDay = "friday"
	DaysDayMonday    DaysDay = "monday"
	DaysDaySaturday  DaysDay = "saturday"
	DaysDaySunday    DaysDay = "sunday"
	DaysDayThursday  DaysDay = "thursday"
	DaysDayTuesday   DaysDay = "tuesday"
	DaysDayWednesday DaysDay = "wednesday"
)

// Defines values for DaysState.
const (
	Custom DaysState = "custom"
	Off    DaysState = "off"
	On     DaysState = "on"
)

// Defines values for DiskAWSType.
const (
	Gp3 DiskAWSType = "gp3"
	Io2 DiskAWSType = "io2"
)

// Defines values for DiskAzureStorage.
const (
	DiskAzureStorageN1024  DiskAzureStorage = 1024
	DiskAzureStorageN10240 DiskAzureStorage = 10240
	DiskAzureStorageN11264 DiskAzureStorage = 11264
	DiskAzureStorageN12288 DiskAzureStorage = 12288
	DiskAzureStorageN128   DiskAzureStorage = 128
	DiskAzureStorageN13312 DiskAzureStorage = 13312
	DiskAzureStorageN14336 DiskAzureStorage = 14336
	DiskAzureStorageN15360 DiskAzureStorage = 15360
	DiskAzureStorageN2048  DiskAzureStorage = 2048
	DiskAzureStorageN256   DiskAzureStorage = 256
	DiskAzureStorageN3072  DiskAzureStorage = 3072
	DiskAzureStorageN4096  DiskAzureStorage = 4096
	DiskAzureStorageN512   DiskAzureStorage = 512
	DiskAzureStorageN5120  DiskAzureStorage = 5120
	DiskAzureStorageN6144  DiskAzureStorage = 6144
	DiskAzureStorageN64    DiskAzureStorage = 64
	DiskAzureStorageN7168  DiskAzureStorage = 7168
	DiskAzureStorageN8192  DiskAzureStorage = 8192
	DiskAzureStorageN9216  DiskAzureStorage = 9216
)

// Defines values for DiskAzureType.
const (
	P10   DiskAzureType = "P10"
	P15   DiskAzureType = "P15"
	P20   DiskAzureType = "P20"
	P30   DiskAzureType = "P30"
	P40   DiskAzureType = "P40"
	P50   DiskAzureType = "P50"
	P6    DiskAzureType = "P6"
	P60   DiskAzureType = "P60"
	Ultra DiskAzureType = "Ultra"
)

// Defines values for DiskGCPType.
const (
	PdSsd DiskGCPType = "pd-ssd"
)

// Defines values for DurabilityLevel.
const (
	DurabilityLevelMajority                 DurabilityLevel = "majority"
	DurabilityLevelMajorityAndPersistActive DurabilityLevel = "majorityAndPersistActive"
	DurabilityLevelNone                     DurabilityLevel = "none"
	DurabilityLevelPersistToMajority        DurabilityLevel = "persistToMajority"
)

// Defines values for EvictionPolicy.
const (
	FullEviction EvictionPolicy = "fullEviction"
	NoEviction   EvictionPolicy = "noEviction"
	NruEviction  EvictionPolicy = "nruEviction"
)

// Defines values for ExternalModelExternalModelName.
const (
	TextEmbedding3Large ExternalModelExternalModelName = "text-embedding-3-large"
	TextEmbedding3Small ExternalModelExternalModelName = "text-embedding-3-small"
	TextEmbeddingAda002 ExternalModelExternalModelName = "text-embedding-ada-002"
)

// Defines values for GetAlertResponseKind.
const (
	GetAlertResponseKindWebhook GetAlertResponseKind = "webhook"
)

// Defines values for GetAppServicePrivateEndpointStateResponseState.
const (
	GetAppServicePrivateEndpointStateResponseStateDisabled  GetAppServicePrivateEndpointStateResponseState = "disabled"
	GetAppServicePrivateEndpointStateResponseStateDisabling GetAppServicePrivateEndpointStateResponseState = "disabling"
	GetAppServicePrivateEndpointStateResponseStateEnabled   GetAppServicePrivateEndpointStateResponseState = "enabled"
	GetAppServicePrivateEndpointStateResponseStateEnabling  GetAppServicePrivateEndpointStateResponseState = "enabling"
	GetAppServicePrivateEndpointStateResponseStateFailed    GetAppServicePrivateEndpointStateResponseState = "failed"
)

// Defines values for GetAppServicePrivateEndpointStateResponseTargetState.
const (
	GetAppServicePrivateEndpointStateResponseTargetStateDisabled GetAppServicePrivateEndpointStateResponseTargetState = "disabled"
	GetAppServicePrivateEndpointStateResponseTargetStateEnabled  GetAppServicePrivateEndpointStateResponseTargetState = "enabled"
)

// Defines values for GetBucketResponseVbuckets.
const (
	N1024 GetBucketResponseVbuckets = 1024
	N128  GetBucketResponseVbuckets = 128
)

// Defines values for GetClusterAuditLogExportResponseStatus.
const (
	GetClusterAuditLogExportResponseStatusCompleted  GetClusterAuditLogExportResponseStatus = "Completed"
	GetClusterAuditLogExportResponseStatusFailed     GetClusterAuditLogExportResponseStatus = "Failed"
	GetClusterAuditLogExportResponseStatusInProgress GetClusterAuditLogExportResponseStatus = "In Progress"
	GetClusterAuditLogExportResponseStatusQueued     GetClusterAuditLogExportResponseStatus = "Queued"
)

// Defines values for GetMtlsConfigurationResponseState.
const (
	GetMtlsConfigurationResponseStateDisable   GetMtlsConfigurationResponseState = "disable"
	GetMtlsConfigurationResponseStateHybrid    GetMtlsConfigurationResponseState = "hybrid"
	GetMtlsConfigurationResponseStateMandatory GetMtlsConfigurationResponseState = "mandatory"
)

// Defines values for GetPrivateEndpointServiceConnectionResponseStatus.
const (
	GetPrivateEndpointServiceConnectionResponseStatusFailed            GetPrivateEndpointServiceConnectionResponseStatus = "failed"
	GetPrivateEndpointServiceConnectionResponseStatusLinked            GetPrivateEndpointServiceConnectionResponseStatus = "linked"
	GetPrivateEndpointServiceConnectionResponseStatusPending           GetPrivateEndpointServiceConnectionResponseStatus = "pending"
	GetPrivateEndpointServiceConnectionResponseStatusPendingAcceptance GetPrivateEndpointServiceConnectionResponseStatus = "pendingAcceptance"
	GetPrivateEndpointServiceConnectionResponseStatusRejected          GetPrivateEndpointServiceConnectionResponseStatus = "rejected"
	GetPrivateEndpointServiceConnectionResponseStatusUnrecognized      GetPrivateEndpointServiceConnectionResponseStatus = "unrecognized"
)

// Defines values for GetPrivateEndpointServiceResponseStatus.
const (
	DisableFailed GetPrivateEndpointServiceResponseStatus = "disableFailed"
	Disabled      GetPrivateEndpointServiceResponseStatus = "disabled"
	Disabling     GetPrivateEndpointServiceResponseStatus = "disabling"
	EnableFailed  GetPrivateEndpointServiceResponseStatus = "enableFailed"
	Enabled       GetPrivateEndpointServiceResponseStatus = "enabled"
	Enabling      GetPrivateEndpointServiceResponseStatus = "enabling"
	Idle          GetPrivateEndpointServiceResponseStatus = "idle"
	Unknown       GetPrivateEndpointServiceResponseStatus = "unknown"
)

// Defines values for GetReplicationResponseDirection.
const (
	GetReplicationResponseDirectionOneWay GetReplicationResponseDirection = "oneWay"
	GetReplicationResponseDirectionTwoWay GetReplicationResponseDirection = "twoWay"
)

// Defines values for GetReplicationResponsePriority.
const (
	GetReplicationResponsePriorityHigh   GetReplicationResponsePriority = "high"
	GetReplicationResponsePriorityLow    GetReplicationResponsePriority = "low"
	GetReplicationResponsePriorityMedium GetReplicationResponsePriority = "medium"
)

// Defines values for GetReplicationResponseStatus.
const (
	GetReplicationResponseStatusFailed  GetReplicationResponseStatus = "failed"
	GetReplicationResponseStatusPaused  GetReplicationResponseStatus = "paused"
	GetReplicationResponseStatusPausing GetReplicationResponseStatus = "pausing"
	GetReplicationResponseStatusPending GetReplicationResponseStatus = "pending"
	GetReplicationResponseStatusRunning GetReplicationResponseStatus = "running"
)

// Defines values for GetStructuredWorkflowResponseStructuredDataProcessingConfigJsonType.
const (
	GetStructuredWorkflowResponseStructuredDataProcessingConfigJsonTypeJson      GetStructuredWorkflowResponseStructuredDataProcessingConfigJsonType = "json"
	GetStructuredWorkflowResponseStructuredDataProcessingConfigJsonTypeJsonlines GetStructuredWorkflowResponseStructuredDataProcessingConfigJsonType = "jsonlines"
	GetStructuredWorkflowResponseStructuredDataProcessingConfigJsonTypeJsonlist  GetStructuredWorkflowResponseStructuredDataProcessingConfigJsonType = "jsonlist"
)

// Defines values for GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigChunkingStrategyStrategyType.
const (
	GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigChunkingStrategyStrategyTypeFIXEDTOKENSPLITTER GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigChunkingStrategyStrategyType = "FIXED_TOKEN_SPLITTER"
	GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigChunkingStrategyStrategyTypePARAGRAPHSPLITTER  GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigChunkingStrategyStrategyType = "PARAGRAPH_SPLITTER"
	GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigChunkingStrategyStrategyTypeRECURSIVESPLITTER  GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigChunkingStrategyStrategyType = "RECURSIVE_SPLITTER"
	GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigChunkingStrategyStrategyTypeSEMANTICSPLITTER   GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigChunkingStrategyStrategyType = "SEMANTIC_SPLITTER"
	GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigChunkingStrategyStrategyTypeSENTENCESPLITTER   GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigChunkingStrategyStrategyType = "SENTENCE_SPLITTER"
)

// Defines values for GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigExclusions.
const (
	GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigExclusionsFooter GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigExclusions = "footer"
	GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigExclusionsHeader GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigExclusions = "header"
	GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigExclusionsTable  GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigExclusions = "table"
)

// Defines values for GetUserResponseStatus.
const (
	NotVerified    GetUserResponseStatus = "not-verified"
	PendingPrimary GetUserResponseStatus = "pending-primary"
	Verified       GetUserResponseStatus = "verified"
)

// Defines values for GetWorkflowResponseType.
const (
	GetWorkflowResponseTypeStructuredDataProcessing   GetWorkflowResponseType = "structuredDataProcessing"
	GetWorkflowResponseTypeUnstructuredDataProcessing GetWorkflowResponseType = "unstructuredDataProcessing"
	GetWorkflowResponseTypeVectorization              GetWorkflowResponseType = "vectorization"
)

// Defines values for GetWorkflowRunProcessedFilesResponseDataFileStatus.
const (
	GetWorkflowRunProcessedFilesResponseDataFileStatusFailed  GetWorkflowRunProcessedFilesResponseDataFileStatus = "failed"
	GetWorkflowRunProcessedFilesResponseDataFileStatusSuccess GetWorkflowRunProcessedFilesResponseDataFileStatus = "success"
)

// Defines values for GetWorkflowRunResponseStatus.
const (
	GetWorkflowRunResponseStatusCompleted          GetWorkflowRunResponseStatus = "completed"
	GetWorkflowRunResponseStatusDeploying          GetWorkflowRunResponseStatus = "deploying"
	GetWorkflowRunResponseStatusFailed             GetWorkflowRunResponseStatus = "failed"
	GetWorkflowRunResponseStatusPartiallyCompleted GetWorkflowRunResponseStatus = "partiallyCompleted"
	GetWorkflowRunResponseStatusRunning            GetWorkflowRunResponseStatus = "running"
	GetWorkflowRunResponseStatusStopping           GetWorkflowRunResponseStatus = "stopping"
)

// Defines values for IndexBuildStatusResponseStatus.
const (
	IndexBuildStatusResponseStatusBuilding IndexBuildStatusResponseStatus = "Building"
	IndexBuildStatusResponseStatusCreated  IndexBuildStatusResponseStatus = "Created"
	IndexBuildStatusResponseStatusReady    IndexBuildStatusResponseStatus = "Ready"
)

// Defines values for Method.
const (
	Full        Method = "full"
	Incremental Method = "incremental"
)

// Defines values for MtlsCertificateStatus.
const (
	MtlsCertificateStatusAwaitingRemoval MtlsCertificateStatus = "awaiting_removal"
	MtlsCertificateStatusAwaitingUpdate  MtlsCertificateStatus = "awaiting_update"
	MtlsCertificateStatusLoadFailed      MtlsCertificateStatus = "load_failed"
	MtlsCertificateStatusLoaded          MtlsCertificateStatus = "loaded"
	MtlsCertificateStatusPending         MtlsCertificateStatus = "pending"
	MtlsCertificateStatusRemovalFailed   MtlsCertificateStatus = "removal_failed"
	MtlsCertificateStatusUpdateFailed    MtlsCertificateStatus = "update_failed"
)

// Defines values for MtlsPrefixPath.
const (
	SanDns    MtlsPrefixPath = "san.dns"
	SanEmail  MtlsPrefixPath = "san.email"
	SanUri    MtlsPrefixPath = "san.uri"
	SubjectCn MtlsPrefixPath = "subject.cn"
)

// Defines values for OrganizationRoles.
const (
	OrganizationRolesOrganizationMember OrganizationRoles = "organizationMember"
	OrganizationRolesOrganizationOwner  OrganizationRoles = "organizationOwner"
	OrganizationRolesProjectCreator     OrganizationRoles = "projectCreator"
)

// Defines values for PatchAuditLogStreamingRequestOp.
const (
	Update PatchAuditLogStreamingRequestOp = "update"
)

// Defines values for PatchEntryOp.
const (
	Add    PatchEntryOp = "add"
	Remove PatchEntryOp = "remove"
)

// Defines values for PostSampleBucketName.
const (
	BeerSample    PostSampleBucketName = "beer-sample"
	GamesimSample PostSampleBucketName = "gamesim-sample"
	TravelSample  PostSampleBucketName = "travel-sample"
)

// Defines values for PrivateEndpointStatus.
const (
	PrivateEndpointStatusFailed            PrivateEndpointStatus = "failed"
	PrivateEndpointStatusLinked            PrivateEndpointStatus = "linked"
	PrivateEndpointStatusPending           PrivateEndpointStatus = "pending"
	PrivateEndpointStatusPendingAcceptance PrivateEndpointStatus = "pendingAcceptance"
	PrivateEndpointStatusRejected          PrivateEndpointStatus = "rejected"
	PrivateEndpointStatusUnrecognized      PrivateEndpointStatus = "unrecognized"
)

// Defines values for ProjectRoles.
const (
	ProjectRolesProjectDataReader       ProjectRoles = "projectDataReader"
	ProjectRolesProjectDataReaderWriter ProjectRoles = "projectDataReaderWriter"
	ProjectRolesProjectManager          ProjectRoles = "projectManager"
	ProjectRolesProjectOwner            ProjectRoles = "projectOwner"
	ProjectRolesProjectViewer           ProjectRoles = "projectViewer"
)

// Defines values for Replicas.
const (
	ReplicasN1 Replicas = 1
	ReplicasN2 Replicas = 2
	ReplicasN3 Replicas = 3
)

// Defines values for RequestWebhookMethod.
const (
	RequestWebhookMethodPOST RequestWebhookMethod = "POST"
	RequestWebhookMethodPUT  RequestWebhookMethod = "PUT"
)

// Defines values for ResourceType.
const (
	Project ResourceType = "project"
)

// Defines values for ResponseWebhookMethod.
const (
	ResponseWebhookMethodPOST ResponseWebhookMethod = "POST"
	ResponseWebhookMethodPUT  ResponseWebhookMethod = "PUT"
)

// Defines values for ResyncStatusState.
const (
	ResyncStatusStateCompleted ResyncStatusState = "completed"
	ResyncStatusStateError     ResyncStatusState = "error"
	ResyncStatusStateRunning   ResyncStatusState = "running"
	ResyncStatusStateStopped   ResyncStatusState = "stopped"
	ResyncStatusStateStopping  ResyncStatusState = "stopping"
)

// Defines values for Service.
const (
	Analytics Service = "analytics"
	Data      Service = "data"
	Eventing  Service = "eventing"
	Index     Service = "index"
	Query     Service = "query"
	Search    Service = "search"
)

// Defines values for Source.
const (
	Manual    Source = "manual"
	Scheduled Source = "scheduled"
)

// Defines values for Status.
const (
	StatusFailed  Status = "failed"
	StatusPending Status = "pending"
	StatusReady   Status = "ready"
)

// Defines values for StorageBackend.
const (
	Couchstore StorageBackend = "couchstore"
	Magma      StorageBackend = "magma"
)

// Defines values for SupportPlan.
const (
	SupportPlanBasic        SupportPlan = "basic"
	SupportPlanDeveloperPro SupportPlan = "developer pro"
	SupportPlanEnterprise   SupportPlan = "enterprise"
)

// Defines values for SupportTimezone.
const (
	SupportTimezoneET  SupportTimezone = "ET"
	SupportTimezoneGMT SupportTimezone = "GMT"
	SupportTimezoneIST SupportTimezone = "IST"
	SupportTimezonePT  SupportTimezone = "PT"
)

// Defines values for Type.
const (
	Couchbase Type = "couchbase"
	Ephemeral Type = "ephemeral"
)

// Defines values for UpdateBucketRequestDurabilityLevel.
const (
	Majority                 UpdateBucketRequestDurabilityLevel = "majority"
	MajorityAndPersistActive UpdateBucketRequestDurabilityLevel = "majorityAndPersistActive"
	None                     UpdateBucketRequestDurabilityLevel = "none"
	PersistToMajority        UpdateBucketRequestDurabilityLevel = "persistToMajority"
)

// Defines values for UpdateBucketRequestReplicas.
const (
	N1 UpdateBucketRequestReplicas = 1
	N2 UpdateBucketRequestReplicas = 2
	N3 UpdateBucketRequestReplicas = 3
)

// Defines values for UpdateMtlsConfigRequestState.
const (
	UpdateMtlsConfigRequestStateDisable   UpdateMtlsConfigRequestState = "disable"
	UpdateMtlsConfigRequestStateHybrid    UpdateMtlsConfigRequestState = "hybrid"
	UpdateMtlsConfigRequestStateMandatory UpdateMtlsConfigRequestState = "mandatory"
)

// Defines values for UpdateReplicationRequestPriority.
const (
	High   UpdateReplicationRequestPriority = "high"
	Low    UpdateReplicationRequestPriority = "low"
	Medium UpdateReplicationRequestPriority = "medium"
)

// Defines values for UsageMetricsRequestsTrend.
const (
	UsageMetricsRequestsTrendDecreasing UsageMetricsRequestsTrend = "decreasing"
	UsageMetricsRequestsTrendIncreasing UsageMetricsRequestsTrend = "increasing"
)

// Defines values for UsageMetricsTokensTrend.
const (
	UsageMetricsTokensTrendDecreasing UsageMetricsTokensTrend = "decreasing"
	UsageMetricsTokensTrendIncreasing UsageMetricsTokensTrend = "increasing"
)

// Defines values for VectorizationConfigEmbeddingFieldMappingsEncodingFormat.
const (
	VectorizationConfigEmbeddingFieldMappingsEncodingFormatBase64 VectorizationConfigEmbeddingFieldMappingsEncodingFormat = "base64"
	VectorizationConfigEmbeddingFieldMappingsEncodingFormatFloat  VectorizationConfigEmbeddingFieldMappingsEncodingFormat = "float"
)

// Defines values for VectorizationConfigCreationEmbeddingFieldMappingsEncodingFormat.
const (
	VectorizationConfigCreationEmbeddingFieldMappingsEncodingFormatBase64 VectorizationConfigCreationEmbeddingFieldMappingsEncodingFormat = "base64"
	VectorizationConfigCreationEmbeddingFieldMappingsEncodingFormatFloat  VectorizationConfigCreationEmbeddingFieldMappingsEncodingFormat = "float"
)

// Defines values for ReplicationSourceType.
const (
	ReplicationSourceTypeCapella  ReplicationSourceType = "capella"
	ReplicationSourceTypeExternal ReplicationSourceType = "external"
)

// Defines values for ReplicationSummaryDirection.
const (
	OneWay ReplicationSummaryDirection = "oneWay"
	TwoWay ReplicationSummaryDirection = "twoWay"
)

// Defines values for ReplicationSummaryStatus.
const (
	ReplicationSummaryStatusFailed  ReplicationSummaryStatus = "failed"
	ReplicationSummaryStatusPaused  ReplicationSummaryStatus = "paused"
	ReplicationSummaryStatusPausing ReplicationSummaryStatus = "pausing"
	ReplicationSummaryStatusPending ReplicationSummaryStatus = "pending"
	ReplicationSummaryStatusRunning ReplicationSummaryStatus = "running"
)

// Defines values for ReplicationTargetType.
const (
	Capella  ReplicationTargetType = "capella"
	External ReplicationTargetType = "external"
)

// Defines values for FileStatus.
const (
	FileStatusFailed  FileStatus = "failed"
	FileStatusSuccess FileStatus = "success"
)

// Defines values for ProviderType.
const (
	ProviderTypeAwsS3  ProviderType = "awsS3"
	ProviderTypeOpenAI ProviderType = "openAI"
)

// Defines values for SortDirection.
const (
	SortDirectionAsc  SortDirection = "asc"
	SortDirectionDesc SortDirection = "desc"
)

// Defines values for ListModelsParamsModelStatus.
const (
	DeployFailed ListModelsParamsModelStatus = "deployFailed"
	Deploying    ListModelsParamsModelStatus = "deploying"
	Healthy      ListModelsParamsModelStatus = "healthy"
	PauseFailed  ListModelsParamsModelStatus = "pauseFailed"
	Paused       ListModelsParamsModelStatus = "paused"
	Pausing      ListModelsParamsModelStatus = "pausing"
	Pending      ListModelsParamsModelStatus = "pending"
	ResumeFailed ListModelsParamsModelStatus = "resumeFailed"
	Resuming     ListModelsParamsModelStatus = "resuming"
	Unhealthy    ListModelsParamsModelStatus = "unhealthy"
)

// Defines values for ListModelsParamsModelKind.
const (
	ListModelsParamsModelKindEmbeddingGeneration ListModelsParamsModelKind = "embedding-generation"
	ListModelsParamsModelKindTextGeneration      ListModelsParamsModelKind = "text-generation"
)

// Defines values for CreateModelJSONBodyOptimization.
const (
	CreateModelJSONBodyOptimizationLatency    CreateModelJSONBodyOptimization = "latency"
	CreateModelJSONBodyOptimizationThroughput CreateModelJSONBodyOptimization = "throughput"
)

// Defines values for CreateModelJSONBodyQuantization.
const (
	CreateModelJSONBodyQuantizationFp16          CreateModelJSONBodyQuantization = "fp16"
	CreateModelJSONBodyQuantizationFp8           CreateModelJSONBodyQuantization = "fp8"
	CreateModelJSONBodyQuantizationFullPrecision CreateModelJSONBodyQuantization = "fullPrecision"
)

// Defines values for ListProvidersParamsProviderType.
const (
	AwsS3  ListProvidersParamsProviderType = "awsS3"
	OpenAI ListProvidersParamsProviderType = "openAI"
)

// Defines values for ListOrganizationLevelAnalyticsClustersParamsSortDirection.
const (
	ListOrganizationLevelAnalyticsClustersParamsSortDirectionAsc  ListOrganizationLevelAnalyticsClustersParamsSortDirection = "asc"
	ListOrganizationLevelAnalyticsClustersParamsSortDirectionDesc ListOrganizationLevelAnalyticsClustersParamsSortDirection = "desc"
)

// Defines values for ListOrganizationAPIKeysParamsSortDirection.
const (
	ListOrganizationAPIKeysParamsSortDirectionAsc  ListOrganizationAPIKeysParamsSortDirection = "asc"
	ListOrganizationAPIKeysParamsSortDirectionDesc ListOrganizationAPIKeysParamsSortDirection = "desc"
)

// Defines values for ListAppServicesParamsSortDirection.
const (
	ListAppServicesParamsSortDirectionAsc  ListAppServicesParamsSortDirection = "asc"
	ListAppServicesParamsSortDirectionDesc ListAppServicesParamsSortDirection = "desc"
)

// Defines values for GetKeyMetadataListParamsSortDirection.
const (
	GetKeyMetadataListParamsSortDirectionAsc  GetKeyMetadataListParamsSortDirection = "asc"
	GetKeyMetadataListParamsSortDirectionDesc GetKeyMetadataListParamsSortDirection = "desc"
)

// Defines values for ListCMEKHistoryParamsSortBy.
const (
	Active       ListCMEKHistoryParamsSortBy = "active"
	AssociatedAt ListCMEKHistoryParamsSortBy = "associatedAt"
	AssociatedBy ListCMEKHistoryParamsSortBy = "associatedBy"
	Key          ListCMEKHistoryParamsSortBy = "key"
)

// Defines values for ListCMEKHistoryParamsSortDirection.
const (
	ListCMEKHistoryParamsSortDirectionAsc  ListCMEKHistoryParamsSortDirection = "asc"
	ListCMEKHistoryParamsSortDirectionDesc ListCMEKHistoryParamsSortDirection = "desc"
)

// Defines values for ListEventsParamsSortBy.
const (
	ListEventsParamsSortBySeverity  ListEventsParamsSortBy = "severity"
	ListEventsParamsSortByTimestamp ListEventsParamsSortBy = "timestamp"
)

// Defines values for ListEventsParamsSortDirection.
const (
	ListEventsParamsSortDirectionAsc  ListEventsParamsSortDirection = "asc"
	ListEventsParamsSortDirectionDesc ListEventsParamsSortDirection = "desc"
)

// Defines values for ListEventsParamsSeverityLevels.
const (
	ListEventsParamsSeverityLevelsCritical ListEventsParamsSeverityLevels = "critical"
	ListEventsParamsSeverityLevelsInfo     ListEventsParamsSeverityLevels = "info"
	ListEventsParamsSeverityLevelsWarning  ListEventsParamsSeverityLevels = "warning"
)

// Defines values for ListEventsParamsTags.
const (
	ListEventsParamsTagsAlert        ListEventsParamsTags = "alert"
	ListEventsParamsTagsAvailability ListEventsParamsTags = "availability"
	ListEventsParamsTagsBilling      ListEventsParamsTags = "billing"
	ListEventsParamsTagsMaintenance  ListEventsParamsTags = "maintenance"
	ListEventsParamsTagsPerformance  ListEventsParamsTags = "performance"
	ListEventsParamsTagsSecurity     ListEventsParamsTags = "security"
)

// Defines values for ListProjectsParamsSortDirection.
const (
	ListProjectsParamsSortDirectionAsc  ListProjectsParamsSortDirection = "asc"
	ListProjectsParamsSortDirectionDesc ListProjectsParamsSortDirection = "desc"
)

// Defines values for PostTestAlertIntegrationJSONBodyKind.
const (
	Webhook PostTestAlertIntegrationJSONBodyKind = "webhook"
)

// Defines values for ListAlertIntegrationsParamsSortDirection.
const (
	ListAlertIntegrationsParamsSortDirectionAsc  ListAlertIntegrationsParamsSortDirection = "asc"
	ListAlertIntegrationsParamsSortDirectionDesc ListAlertIntegrationsParamsSortDirection = "desc"
)

// Defines values for ListProjectLevelAnalyticsClustersParamsSortDirection.
const (
	ListProjectLevelAnalyticsClustersParamsSortDirectionAsc  ListProjectLevelAnalyticsClustersParamsSortDirection = "asc"
	ListProjectLevelAnalyticsClustersParamsSortDirectionDesc ListProjectLevelAnalyticsClustersParamsSortDirection = "desc"
)

// Defines values for ListAnalyticsAllowedCidrsParamsSortDirection.
const (
	ListAnalyticsAllowedCidrsParamsSortDirectionAsc  ListAnalyticsAllowedCidrsParamsSortDirection = "asc"
	ListAnalyticsAllowedCidrsParamsSortDirectionDesc ListAnalyticsAllowedCidrsParamsSortDirection = "desc"
)

// Defines values for ListColumnarAnalyticsBackupsParamsSortDirection.
const (
	ListColumnarAnalyticsBackupsParamsSortDirectionAsc  ListColumnarAnalyticsBackupsParamsSortDirection = "asc"
	ListColumnarAnalyticsBackupsParamsSortDirectionDesc ListColumnarAnalyticsBackupsParamsSortDirection = "desc"
)

// Defines values for ListColumnarAnalyticsRestoresParamsSortDirection.
const (
	ListColumnarAnalyticsRestoresParamsSortDirectionAsc  ListColumnarAnalyticsRestoresParamsSortDirection = "asc"
	ListColumnarAnalyticsRestoresParamsSortDirectionDesc ListColumnarAnalyticsRestoresParamsSortDirection = "desc"
)

// Defines values for ListProjectLevelCloudSnapshotBackupsParamsSortBy.
const (
	ListProjectLevelCloudSnapshotBackupsParamsSortByCloudProvider    ListProjectLevelCloudSnapshotBackupsParamsSortBy = "cloudProvider"
	ListProjectLevelCloudSnapshotBackupsParamsSortByCreatedBy        ListProjectLevelCloudSnapshotBackupsParamsSortBy = "createdBy"
	ListProjectLevelCloudSnapshotBackupsParamsSortByCreationDateTime ListProjectLevelCloudSnapshotBackupsParamsSortBy = "creationDateTime"
	ListProjectLevelCloudSnapshotBackupsParamsSortByCurrentStatus    ListProjectLevelCloudSnapshotBackupsParamsSortBy = "currentStatus"
	ListProjectLevelCloudSnapshotBackupsParamsSortByRegion           ListProjectLevelCloudSnapshotBackupsParamsSortBy = "region"
)

// Defines values for ListProjectLevelCloudSnapshotBackupsParamsSortDirection.
const (
	ListProjectLevelCloudSnapshotBackupsParamsSortDirectionAsc  ListProjectLevelCloudSnapshotBackupsParamsSortDirection = "asc"
	ListProjectLevelCloudSnapshotBackupsParamsSortDirectionDesc ListProjectLevelCloudSnapshotBackupsParamsSortDirection = "desc"
)

// Defines values for ListClustersParamsSortDirection.
const (
	ListClustersParamsSortDirectionAsc  ListClustersParamsSortDirection = "asc"
	ListClustersParamsSortDirectionDesc ListClustersParamsSortDirection = "desc"
)

// Defines values for GetAiWorkflowRunProcessedFilesParamsFileStatus.
const (
	GetAiWorkflowRunProcessedFilesParamsFileStatusFailed  GetAiWorkflowRunProcessedFilesParamsFileStatus = "failed"
	GetAiWorkflowRunProcessedFilesParamsFileStatusSuccess GetAiWorkflowRunProcessedFilesParamsFileStatus = "success"
)

// Defines values for ListAllowedCidrsParamsSortDirection.
const (
	ListAllowedCidrsParamsSortDirectionAsc  ListAllowedCidrsParamsSortDirection = "asc"
	ListAllowedCidrsParamsSortDirectionDesc ListAllowedCidrsParamsSortDirection = "desc"
)

// Defines values for ListAppServiceAdminUsersParamsSortDirection.
const (
	ListAppServiceAdminUsersParamsSortDirectionAsc  ListAppServiceAdminUsersParamsSortDirection = "asc"
	ListAppServiceAdminUsersParamsSortDirectionDesc ListAppServiceAdminUsersParamsSortDirection = "desc"
)

// Defines values for ListAppServiceAllowedCidrsParamsSortDirection.
const (
	ListAppServiceAllowedCidrsParamsSortDirectionAsc  ListAppServiceAllowedCidrsParamsSortDirection = "asc"
	ListAppServiceAllowedCidrsParamsSortDirectionDesc ListAppServiceAllowedCidrsParamsSortDirection = "desc"
)

// Defines values for ListAppEndpointsParamsSortDirection.
const (
	ListAppEndpointsParamsSortDirectionAsc  ListAppEndpointsParamsSortDirection = "asc"
	ListAppEndpointsParamsSortDirectionDesc ListAppEndpointsParamsSortDirection = "desc"
)

// Defines values for ListAppEndpointAdminUsersParamsSortDirection.
const (
	ListAppEndpointAdminUsersParamsSortDirectionAsc  ListAppEndpointAdminUsersParamsSortDirection = "asc"
	ListAppEndpointAdminUsersParamsSortDirectionDesc ListAppEndpointAdminUsersParamsSortDirection = "desc"
)

// Defines values for ListAppEndpointCollectionsParamsSortDirection.
const (
	ListAppEndpointCollectionsParamsSortDirectionAsc  ListAppEndpointCollectionsParamsSortDirection = "asc"
	ListAppEndpointCollectionsParamsSortDirectionDesc ListAppEndpointCollectionsParamsSortDirection = "desc"
)

// Defines values for ListAppEndpointOIDCProvidersParamsSortDirection.
const (
	ListAppEndpointOIDCProvidersParamsSortDirectionAsc  ListAppEndpointOIDCProvidersParamsSortDirection = "asc"
	ListAppEndpointOIDCProvidersParamsSortDirectionDesc ListAppEndpointOIDCProvidersParamsSortDirection = "desc"
)

// Defines values for ListAppServiceAuditLogExportsParamsSortDirection.
const (
	ListAppServiceAuditLogExportsParamsSortDirectionAsc  ListAppServiceAuditLogExportsParamsSortDirection = "asc"
	ListAppServiceAuditLogExportsParamsSortDirectionDesc ListAppServiceAuditLogExportsParamsSortDirection = "desc"
)

// Defines values for ListCloudSnapshotBackupsParamsSortDirection.
const (
	ListCloudSnapshotBackupsParamsSortDirectionAsc  ListCloudSnapshotBackupsParamsSortDirection = "asc"
	ListCloudSnapshotBackupsParamsSortDirectionDesc ListCloudSnapshotBackupsParamsSortDirection = "desc"
)

// Defines values for ListCloudSnapshotRestoresParamsSortDirection.
const (
	ListCloudSnapshotRestoresParamsSortDirectionAsc  ListCloudSnapshotRestoresParamsSortDirection = "asc"
	ListCloudSnapshotRestoresParamsSortDirectionDesc ListCloudSnapshotRestoresParamsSortDirection = "desc"
)

// Defines values for ListMtlsCertificatesParamsSortDirection.
const (
	ListMtlsCertificatesParamsSortDirectionAsc  ListMtlsCertificatesParamsSortDirection = "asc"
	ListMtlsCertificatesParamsSortDirectionDesc ListMtlsCertificatesParamsSortDirection = "desc"
)

// Defines values for ListNetworkPeeringRecordsParamsSortDirection.
const (
	ListNetworkPeeringRecordsParamsSortDirectionAsc  ListNetworkPeeringRecordsParamsSortDirection = "asc"
	ListNetworkPeeringRecordsParamsSortDirectionDesc ListNetworkPeeringRecordsParamsSortDirection = "desc"
)

// Defines values for ListClusterReplicationsParamsSortDirection.
const (
	ListClusterReplicationsParamsSortDirectionAsc  ListClusterReplicationsParamsSortDirection = "asc"
	ListClusterReplicationsParamsSortDirectionDesc ListClusterReplicationsParamsSortDirection = "desc"
)

// Defines values for ListDatabaseCredentialsParamsSortDirection.
const (
	ListDatabaseCredentialsParamsSortDirectionAsc  ListDatabaseCredentialsParamsSortDirection = "asc"
	ListDatabaseCredentialsParamsSortDirectionDesc ListDatabaseCredentialsParamsSortDirection = "desc"
)

// Defines values for ListProjectEventsParamsSortBy.
const (
	ListProjectEventsParamsSortBySeverity  ListProjectEventsParamsSortBy = "severity"
	ListProjectEventsParamsSortByTimestamp ListProjectEventsParamsSortBy = "timestamp"
)

// Defines values for ListProjectEventsParamsSortDirection.
const (
	ListProjectEventsParamsSortDirectionAsc  ListProjectEventsParamsSortDirection = "asc"
	ListProjectEventsParamsSortDirectionDesc ListProjectEventsParamsSortDirection = "desc"
)

// Defines values for ListProjectEventsParamsSeverityLevels.
const (
	ListProjectEventsParamsSeverityLevelsCritical ListProjectEventsParamsSeverityLevels = "critical"
	ListProjectEventsParamsSeverityLevelsInfo     ListProjectEventsParamsSeverityLevels = "info"
	ListProjectEventsParamsSeverityLevelsWarning  ListProjectEventsParamsSeverityLevels = "warning"
)

// Defines values for ListProjectEventsParamsTags.
const (
	ListProjectEventsParamsTagsAlert        ListProjectEventsParamsTags = "alert"
	ListProjectEventsParamsTagsAvailability ListProjectEventsParamsTags = "availability"
	ListProjectEventsParamsTagsBilling      ListProjectEventsParamsTags = "billing"
	ListProjectEventsParamsTagsMaintenance  ListProjectEventsParamsTags = "maintenance"
	ListProjectEventsParamsTagsPerformance  ListProjectEventsParamsTags = "performance"
	ListProjectEventsParamsTagsSecurity     ListProjectEventsParamsTags = "security"
)

// Defines values for ListProjectReplicationsParamsSortDirection.
const (
	ListProjectReplicationsParamsSortDirectionAsc  ListProjectReplicationsParamsSortDirection = "asc"
	ListProjectReplicationsParamsSortDirectionDesc ListProjectReplicationsParamsSortDirection = "desc"
)

// Defines values for ListUsersParamsSortDirection.
const (
	ListUsersParamsSortDirectionAsc  ListUsersParamsSortDirection = "asc"
	ListUsersParamsSortDirectionDesc ListUsersParamsSortDirection = "desc"
)

// APIKeyAllowedCIDRs List of inbound CIDRs for the API key.
// The system making a request must come from one of the allowed CIDRs.
type APIKeyAllowedCIDRs = []string

// APIKeyDescription Description for the API key.
type APIKeyDescription = string

// APIKeyExpiry Expiry of the API key in number of days.
// If set to -1, the token will not expire.
type APIKeyExpiry = float32

// APIKeyId The id is a unique identifier for an apiKey.
type APIKeyId = string

// APIKeyName Name of the API key.
type APIKeyName = string

// APIKeyOrganizationRoles Organization roles assigned to the API key.
//
// To learn more, see [Organization Roles](https://docs.couchbase.com/cloud/organizations/organization-user-roles.html).
type APIKeyOrganizationRoles string

// APIKeyResources Resources are the resource level permissions associated with the API key.
//
// To learn more about Organization Roles, see [Organization Roles](https://docs.couchbase.com/cloud/organizations/organization-user-roles.html).
type APIKeyResources = []APIKeyResourcesItems

// APIKeyResourcesItems defines model for APIKeyResourcesItems.
type APIKeyResourcesItems struct {
	// Id ID of the project.
	Id openapi_types.UUID `json:"id"`

	// Roles Project Roles associated with the API key.
	//
	// To learn more about Project Roles, see [Project Roles](https://docs.couchbase.com/cloud/projects/project-roles.html).
	Roles []APIKeyResourcesItemsRoles `json:"roles"`

	// Type Type of the resource.
	Type *string `json:"type,omitempty"`
}

// APIKeyResourcesItemsRoles defines model for APIKeyResourcesItems.Roles.
type APIKeyResourcesItemsRoles string

// AWS defines model for AWS.
type AWS struct {
	// AWSConfig AWS config data required to establish a VPC peering relationship. Refer to the docs for other limitations to AWS VPC Peering - [ref](https://docs.aws.amazon.com/vpc/latest/peering/vpc-peering-basics.html#vpc-peering-limitations).
	AWSConfig *AWSConfigData `json:"AWSConfig,omitempty"`

	// ProviderId The ID of the VPC peer on AWS.
	ProviderId *string `json:"providerId,omitempty"`
}

// AWSConfig defines model for AWSConfig.
type AWSConfig struct {
	// Arn The Amazon Resource Name (ARN) that uniquely identifies the AWS KMS key.
	Arn string `json:"arn"`
}

// AWSConfigData AWS config data required to establish a VPC peering relationship. Refer to the docs for other limitations to AWS VPC Peering - [ref](https://docs.aws.amazon.com/vpc/latest/peering/vpc-peering-basics.html#vpc-peering-limitations).
type AWSConfigData struct {
	// AccountId The numeric AWS Account ID or Owner ID.
	AccountId string `json:"accountId"`

	// Cidr The AWS VPC CIDR block of network in which your application runs. This cannot overlap with your Capella CIDR Block.
	Cidr string `json:"cidr"`

	// Region The AWS region where your VPC is deployed.
	Region string `json:"region"`

	// VpcId The alphanumeric VPC ID which starts with \"vpc-\". This is also known as the networkId.
	VpcId string `json:"vpcId"`
}

// AZURE defines model for AZURE.
type AZURE struct {
	// AzureConfig Azure config data required to establish a VNet peering relationship. Refer to the docs for other limitations to Azure VNet Peering - [ref](https://learn.microsoft.com/en-us/azure/virtual-network/virtual-network-peering-overview#constraints-for-peered-virtual-networks)
	AzureConfig *AzureConfigData `json:"AzureConfig,omitempty"`

	// ProviderId The ID of the VNet peer on Azure.
	ProviderId *string `json:"providerId,omitempty"`
}

// Access defines model for Access.
type Access struct {
	// Privileges The `privileges` field in this API represents the privilege level for users.
	// It accepts one of the following values:
	//
	// - `data_reader`
	// - `data_writer`
	// - `read`: Equivalent to `data_reader`.
	// - `write`: Equivalent to `data_writer`.
	Privileges []string `json:"privileges"`

	// Resources The resources for which access will be granted on. Leaving this empty will grant access to all buckets.
	Resources *struct {
		Buckets *[]ResourceBucket `json:"buckets,omitempty"`
	} `json:"resources,omitempty"`
}

// AccessFunction All mutations in this collection are processed by this Javascript function
type AccessFunction = string

// Actions Actions that can be performed on the language model.
type Actions = []string

// AddMtlsCertificateResponse defines model for AddMtlsCertificateResponse.
type AddMtlsCertificateResponse struct {
	// Id The UUID of the certificate created.
	Id string `json:"id"`
}

// AllowedCidr defines model for AllowedCidr.
type AllowedCidr struct {
	Audit CouchbaseAuditData `json:"audit"`

	// Cidr The trusted CIDR to allow the database connections from. The example
	// represents a single IP address (i.e. a subnet mask of 32).
	Cidr string `json:"cidr"`

	// Comment A short description of the allowed CIDR.
	Comment *string `json:"comment,omitempty"`

	// ExpiresAt An RFC3339 timestamp determining when the allowed CIDR will expire.
	// If this field is omitted then the allowed CIDR is permanent and will never automatically expire.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Id The ID of the allowed CIDR.
	Id string `json:"id"`

	// Status The current status of the allowed CIDR.
	Status AllowedCidrStatus `json:"status"`

	// Type Whether the allowed CIDR is permanent or has an expiry.
	Type AllowedCidrType `json:"type"`
}

// AllowedCidrStatus The current status of the allowed CIDR.
type AllowedCidrStatus string

// AllowedCidrType Whether the allowed CIDR is permanent or has an expiry.
type AllowedCidrType string

// AppServiceAdminUser defines model for AppServiceAdminUser.
type AppServiceAdminUser struct {
	// AccessAllEndpoints Give user access to all App Endpoints.
	AccessAllEndpoints *bool               `json:"accessAllEndpoints,omitempty"`
	Audit              *CouchbaseAuditData `json:"audit,omitempty"`

	// ClusterId The GUID4 ID of the cluster.
	ClusterId *string `json:"clusterId,omitempty"`

	// Endpoints The list of App Endpoints that the user has access to.
	Endpoints *[]string `json:"endpoints,omitempty"`

	// Id The unique identifier for the user.
	Id *string `json:"id,omitempty"`

	// Name The name of the user.
	Name *string `json:"name,omitempty"`

	// ProjectId The GUID4 ID of the project.
	ProjectId *string `json:"projectId,omitempty"`

	// TenantId The GUID4 ID of the tenant.
	TenantId *string `json:"tenantId,omitempty"`
}

// AppServiceAllowedCidr defines model for AppServiceAllowedCidr.
type AppServiceAllowedCidr struct {
	Audit CouchbaseAuditData `json:"audit"`

	// Cidr The trusted CIDR to allow network connections from. The example
	// represents a single IP address (i.e. a subnet mask of 32).
	Cidr string `json:"cidr"`

	// Comment A short description of the allowed CIDR.
	Comment *string `json:"comment,omitempty"`

	// ExpiresAt An RFC3339 timestamp determining when the allowed CIDR will expire.
	// If this field is omitted then the allowed CIDR is permanent and will never automatically expire.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Id The ID of the allowed CIDR.
	Id string `json:"id"`

	// Status The current status of the allowed CIDR.
	Status AppServiceAllowedCidrStatus `json:"status"`

	// Type Whether the allowed CIDR is permanent or has an expiry.
	Type AppServiceAllowedCidrType `json:"type"`
}

// AppServiceAllowedCidrStatus The current status of the allowed CIDR.
type AppServiceAllowedCidrStatus string

// AppServiceAllowedCidrType Whether the allowed CIDR is permanent or has an expiry.
type AppServiceAllowedCidrType string

// AppServiceCompute The CPU and RAM configuration of the App Service. The supported combinations are:
// | CPU (cores)| RAM  (GB)   |
// | --------   |   -------   |
// | 2          | 4           |
// | 4          | 8           |
// | 8          | 16          |
// | 16         | 32          |
// | 36         | 72          |
type AppServiceCompute struct {
	// Cpu CPU units (cores).
	Cpu int `json:"cpu"`

	// Ram RAM units (GB).
	Ram int `json:"ram"`
}

// AppServiceStates defines model for AppServiceStates.
type AppServiceStates string

// AuditFilterableEvent defines model for AuditFilterableEvent.
type AuditFilterableEvent struct {
	Description string `json:"description"`
	Id          int32  `json:"id"`
	Module      string `json:"module"`
	Name        string `json:"name"`
}

// AuditLogEventsResponse defines model for AuditLogEventsResponse.
type AuditLogEventsResponse struct {
	// Events A map of audit event IDs to their verbose details
	Events *map[string]interface{} `json:"events,omitempty"`
}

// AuditSettingsDisabledUser defines model for AuditSettingsDisabledUser.
type AuditSettingsDisabledUser struct {
	// Domain Specifies whether the user is local or external.
	Domain *string `json:"domain,omitempty"`

	// Name The user name.
	Name *string `json:"name,omitempty"`
}

// AuditSettingsDisabledUsers List of users whose filterable events will not be logged.
type AuditSettingsDisabledUsers = []AuditSettingsDisabledUser

// Availability defines model for Availability.
type Availability struct {
	// Type Availability zone type, either 'single' or 'multi'. Availability zone type allowed for singleNode cluster is only 'single'.
	Type AvailabilityType `json:"type"`
}

// AvailabilityType Availability zone type, either 'single' or 'multi'. Availability zone type allowed for singleNode cluster is only 'single'.
type AvailabilityType string

// AzureConfigData Azure config data required to establish a VNet peering relationship. Refer to the docs for other limitations to Azure VNet Peering - [ref](https://learn.microsoft.com/en-us/azure/virtual-network/virtual-network-peering-overview#constraints-for-peered-virtual-networks)
type AzureConfigData struct {
	// AzureTenantId The tenant ID. To find your tenant ID, see [How to find your Azure Active Directory tenant ID](https://learn.microsoft.com/en-us/entra/fundamentals/how-to-find-tenant).
	AzureTenantId string `json:"azureTenantId"`

	// Cidr The CIDR block from the virtual network that you created in Azure.
	Cidr string `json:"cidr"`

	// ResourceGroup The resource group name holding the resource you’re connecting with Capella.
	ResourceGroup string `json:"resourceGroup"`

	// SubscriptionId The subscription ID. To find your subscription ID, see [Find your Azure subscription](https://learn.microsoft.com/en-us/azure/azure-portal/get-subscription-tenant-id#find-your-azure-subscription).
	SubscriptionId string `json:"subscriptionId"`

	// VnetId The VNet ID is the name of the virtual network peering in Azure.
	VnetId string `json:"vnetId"`
}

// BackupStats Represents various backup level data that couchbase provides. To learn more, see [Backup Summary](https://docs.couchbase.com/cloud/clusters/manage-backup.html#backup-summary)
type BackupStats struct {
	// Cbas The number of analytics entities saved during the backup.
	Cbas int `json:"cbas"`

	// Event The number of event entities saved during the backup.
	Event int `json:"event"`

	// Fts The number of full text search entities saved during the backup.
	Fts int `json:"fts"`

	// Gsi The number of global secondary indexes saved during the backup.
	Gsi int `json:"gsi"`

	// Items The number of items saved during the backup.
	Items int `json:"items"`

	// Mutations The number of mutations saved during the backup.
	Mutations int `json:"mutations"`

	// SizeInMb Backup size in megabytes.
	SizeInMb float32 `json:"sizeInMb"`

	// Tombstones The number of tombstones saved during the backup.
	Tombstones int `json:"tombstones"`
}

// BasicAuth defines model for BasicAuth.
type BasicAuth struct {
	// Password Authentication password of the alert API (up to 1024 characters).
	Password string `json:"password"`

	// User Authentication username of the alert API (up to 1024 characters).
	User string `json:"user"`
}

// BucketConflictResolution The means by which conflicts are resolved during replication.
//
// - This field may be referred to as "conflict resolution" in the Couchbase documentation, and `seqno` and `lww` may be referred to as "sequence number" and "timestamp" respectively.
//
// - This field cannot be changed later.
//
//	To learn more, see [Conflict Resolution](https://docs.couchbase.com/cloud/clusters/xdcr/xdcr.html#conflict-resolution).
type BucketConflictResolution string

// BucketPriority Priority of the bucket.
//
// - Specify relative bucket priority so that buckets will be recovered in the order specified during failover.
//
// - Bucket ranking/priority is only available in Couchbase Server 7.6 and above
//
// - Default bucket priority is 0 and can be set to a value between 0 and 1000. 1000 is the highest priority and 0 is the lowest.
type BucketPriority = int

// CORSConfig defines model for CORSConfig.
type CORSConfig struct {
	// Disabled disable CORS
	Disabled *bool `json:"disabled,omitempty"`

	// Headers List of allowed headers
	Headers *[]string `json:"headers,omitempty"`

	// LoginOrigin List of allowed login origins
	LoginOrigin *[]string `json:"loginOrigin,omitempty"`

	// MaxAge Specifies the duration (in seconds) for which the results of a preflight request can be cached.
	MaxAge *int `json:"maxAge,omitempty"`

	// Origin List of allowed origins, use ['*'] to allow access from everywhere
	Origin []string `json:"origin"`
}

// Caching Caching configuration for the model. Caching improves system efficiency by caching frequently accessed data, both at the conversational level (storing request-specific conversation history) and at the semantic level (saving the embeddings for queries and results), ensuring optimal performance while managing memory costs effectively. Supports multiple caching strategies for improved response times and reduced strain on backend LLM services.
type Caching struct {
	// Conversational Conversational caching can be enabled for both standard and semantic caching strategies. This enables contextual session-based caching where conversation context (session topic) is stored along with either standard or semantic cache. Allows searching entire conversations for matches and can return all conversations for a given context/session or only specific matched responses. Essential for maintaining conversation history and context.
	Conversational *struct {
		// EnableConversational Enables conversational caching for maintaining conversation history and context for both standard and semantic caching strategies.
		EnableConversational *bool `json:"enableConversational,omitempty"`
	} `json:"conversational,omitempty"`

	// DefaultCache Specifies the primary caching strategy when multiple types are enabled. Choose 'standard' for exact SHA-256 hash matching or 'semantic' for vector similarity-based matching as the default behavior.
	DefaultCache *CachingDefaultCache `json:"defaultCache,omitempty"`

	// ExpiryTTL Cache expiry time-to-live (TTL) in seconds. Determines how long cached responses, embeddings, and conversation context remain valid before being automatically removed from the cache store.
	ExpiryTTL *int `json:"expiryTTL,omitempty"`

	// Semantic Semantic caching configuration that enables similarity-based caching using Couchbase FTS vector search. Creates embeddings for prompt queries, performs vector search with configurable score threshold, and returns cached responses for semantically similar requests.
	Semantic *struct {
		// Dimensions The vector dimensions for semantic caching.
		Dimensions *int `json:"dimensions,omitempty"`

		// DistanceMetric The vector similarity metric used for semantic matching.
		DistanceMetric *string `json:"distanceMetric,omitempty"`

		// EmbeddingModel Specifies the embedding model deployed by the customer to use for generating vector embeddings. This model converts text queries into numerical vectors for semantic similarity matching in the cache.
		EmbeddingModel *string `json:"embeddingModel,omitempty"`

		// EnableSemantic Enables semantic similarity-based caching using vector embeddings.
		EnableSemantic *bool `json:"enableSemantic,omitempty"`

		// ScoreThreshold The threshold value for semantic similarity matching, should be > 0. Default is 0.75.
		ScoreThreshold *float32 `json:"scoreThreshold,omitempty"`
	} `json:"semantic,omitempty"`

	// Standard Standard caching configuration using exact match caching with SHA-256 hash of the prompt request/query as the document key. Returns cached response if hash matches, otherwise stores the new response with the SHA-256 hash as the key. Ideal for identical repeated requests.
	Standard *struct {
		// EnableStandard Enables exact match caching using SHA-256 hash.
		EnableStandard *bool `json:"enableStandard,omitempty"`
	} `json:"standard,omitempty"`
}

// CachingDefaultCache Specifies the primary caching strategy when multiple types are enabled. Choose 'standard' for exact SHA-256 hash matching or 'semantic' for vector similarity-based matching as the default behavior.
type CachingDefaultCache string

// CapellaHostedModel defines model for CapellaHostedModel.
type CapellaHostedModel struct {
	CapellaHostedModel struct {
		// Id The ID of the model hosted with Capella.
		Id string `json:"id"`

		// ModelName The name of the model hosted with Capella.
		ModelName string `json:"modelName"`
	} `json:"capellaHostedModel"`
}

// CloudAccounts defines model for CloudAccounts.
type CloudAccounts struct {
	// AwsCapellaAccount The AWS account ID.
	AwsCapellaAccount string `json:"aws-capella-account"`

	// AzureCapellaSubscription The Azure subscription name.
	AzureCapellaSubscription string `json:"azure-capella-subscription"`

	// GcpCapellaProject The GCP project name.
	GcpCapellaProject string `json:"gcp-capella-project"`
}

// CloudConfig The cloud configuration for the model.
type CloudConfig struct {
	// Compute Type of the compute on which the model is deployed.
	Compute struct {
		// Cpu The number of cpu vCPUs. For AWS instances g6.xlarge, g6e.xlarge use 4 vCPUs, and for p3.8xlarge use 32 vCPUs.
		Cpu CloudConfigComputeCpu `json:"cpu"`

		// GpuMemory The memory in GB for the GPU. For AWS instance g6.xlarge use 24 GB GPU Memory, for g6e.xlarge use 48 GB GPU Memory, and for g6e.12xlarge use 192 GB RAM.
		GpuMemory CloudConfigComputeGpuMemory `json:"gpuMemory"`
	} `json:"compute"`

	// Provider The cloud service provider where the model will be deployed. Currently only AWS is supported.
	Provider CloudConfigProvider `json:"provider"`

	// Region Cloud provider region, for example `us-west-2`.
	Region string `json:"region"`
}

// CloudConfigComputeCpu The number of cpu vCPUs. For AWS instances g6.xlarge, g6e.xlarge use 4 vCPUs, and for p3.8xlarge use 32 vCPUs.
type CloudConfigComputeCpu int32

// CloudConfigComputeGpuMemory The memory in GB for the GPU. For AWS instance g6.xlarge use 24 GB GPU Memory, for g6e.xlarge use 48 GB GPU Memory, and for g6e.12xlarge use 192 GB RAM.
type CloudConfigComputeGpuMemory int

// CloudConfigProvider The cloud service provider where the model will be deployed. Currently only AWS is supported.
type CloudConfigProvider string

// CloudProvider The cloud provider where the cluster will be hosted.
// For information about providers and supported regions, see:
//
// - [Amazon Web Services](https://docs.couchbase.com/cloud/reference/aws.html)
//
// - [Google Cloud Platform](https://docs.couchbase.com/cloud/reference/gcp.html)
//
// - [Microsoft Azure](https://docs.couchbase.com/cloud/reference/azure.html)
type CloudProvider struct {
	// Cidr CIDR block for Cloud Provider.
	Cidr *string `json:"cidr,omitempty"`

	// Region Cloud provider region, for example `us-west-2`.
	Region string `json:"region"`

	// Type Cloud provider type. Note: For singleNode cluster, only AWS type cloud provider is allowed.
	//
	// 1. `aws`: Amazon Web Services
	//
	// 2. `gcp`: Google Cloud Platform
	//
	// 3. `azure`: Microsoft Azure
	Type CloudProviderType `json:"type"`
}

// CloudProviderType Cloud provider type. Note: For singleNode cluster, only AWS type cloud provider is allowed.
//
// 1. `aws`: Amazon Web Services
//
// 2. `gcp`: Google Cloud Platform
//
// 3. `azure`: Microsoft Azure
type CloudProviderType string

// CloudSnapshotBackupCrossRegionCopies defines model for CloudSnapshotBackupCrossRegionCopies.
type CloudSnapshotBackupCrossRegionCopies struct {
	RegionCode *string    `json:"regionCode,omitempty"`
	Status     *string    `json:"status,omitempty"`
	Time       *time.Time `json:"time,omitempty"`
}

// CloudSnapshotBackupProgress defines model for CloudSnapshotBackupProgress.
type CloudSnapshotBackupProgress struct {
	Status *string    `json:"status,omitempty"`
	Time   *time.Time `json:"time,omitempty"`
}

// CloudSnapshotGeographicRegions defines model for CloudSnapshotGeographicRegions.
type CloudSnapshotGeographicRegions = []string

// ClusterCMEKConfig defines model for ClusterCMEKConfig.
type ClusterCMEKConfig struct {
	// Id UUID of the customer managed encryption key.
	Id openapi_types.UUID `json:"id"`

	// ProviderId ProviderId is the ID of the customer managed encryption key as stored by the cloud provider.
	ProviderId *string `json:"providerId,omitempty"`
}

// ClusterOnOffSchedule Cluster schedule on/off .
type ClusterOnOffSchedule struct {
	Days []Days `json:"days"`

	// Timezone Timezone for the schedule
	Timezone ClusterOnOffScheduleTimezone `json:"timezone"`
}

// ClusterOnOffScheduleTimezone Timezone for the schedule
type ClusterOnOffScheduleTimezone string

// Collection defines model for Collection.
type Collection struct {
	// MaxTTL Max TTL of the collection.
	MaxTTL *int `json:"maxTTL,omitempty"`

	// Name Name of the collection.
	Name *string `json:"name,omitempty"`
}

// CollectionConfig defines model for CollectionConfig.
type CollectionConfig struct {
	// AccessControlFunction The Javascript function that is used to specify the access control policies to be applied to documents in this collection.
	// Every document update is processed by this function. The default access control function is 'function(doc){channel(doc.channels);}'
	// for the default collection and 'function(doc){channel(collectionName);}' for named collections.
	AccessControlFunction *string `json:"accessControlFunction,omitempty"`

	// ImportFilter The Javascript function used to specify the documents in this collection that are to be imported by the App Endpoint. By default, all documents in corresponding collection are imported.
	ImportFilter *string `json:"importFilter,omitempty"`
}

// CollectionsConfig The collection config, defining Access control and validation functions and import filters for this collection. The key to the collection config object is the name of the collection.
type CollectionsConfig map[string]CollectionConfig

// ColumnarAnalyticsBackupProgress defines model for ColumnarAnalyticsBackupProgress.
type ColumnarAnalyticsBackupProgress struct {
	// Status The status of the backup.
	Status *string `json:"status,omitempty"`

	// Time The time the backup was created.
	Time *time.Time `json:"time,omitempty"`
}

// ColumnarAnalyticsOnOffSchedule Columnar schedule on/off
type ColumnarAnalyticsOnOffSchedule struct {
	Days []Days `json:"days"`

	// Timezone Timezone for the schedule
	Timezone ColumnarAnalyticsOnOffScheduleTimezone `json:"timezone"`
}

// ColumnarAnalyticsOnOffScheduleTimezone Timezone for the schedule
type ColumnarAnalyticsOnOffScheduleTimezone string

// ColumnarSupport defines model for ColumnarSupport.
type ColumnarSupport struct {
	// Plan Plan type, 'Developer Pro', or 'Enterprise'.
	Plan ColumnarSupportPlan `json:"plan"`

	// Timezone The standard timezone for the cluster. Should be the TZ identifier.
	Timezone ColumnarSupportTimezone `json:"timezone"`
}

// ColumnarSupportPlan Plan type, 'Developer Pro', or 'Enterprise'.
type ColumnarSupportPlan string

// ColumnarSupportTimezone The standard timezone for the cluster. Should be the TZ identifier.
type ColumnarSupportTimezone string

// Compute Following are the supported compute combinations for CPU and RAM for different cloud providers.
// To learn more, see [Amazon Web Services](https://docs.couchbase.com/cloud/reference/aws.html).
type Compute struct {
	// Cpu CPU units (cores).
	Cpu int `json:"cpu"`

	// Ram RAM units (GB).
	Ram int `json:"ram"`
}

// Config Contains all the model information.
type Config struct {
	// Caching Caching configuration for the model. Caching improves system efficiency by caching frequently accessed data, both at the conversational level (storing request-specific conversation history) and at the semantic level (saving the embeddings for queries and results), ensuring optimal performance while managing memory costs effectively. Supports multiple caching strategies for improved response times and reduced strain on backend LLM services.
	Caching *Caching `json:"caching,omitempty"`

	// CatalogModelName Name of the model deployed from the model catalog.
	CatalogModelName *string `json:"catalogModelName,omitempty"`

	// Dimensions Dimensions specifies the number of dimensions for the embedding vectors. This field is only present     and relevant when the underlying model is an embedding model.
	Dimensions *int `json:"dimensions,omitempty"`

	// IsBatchingEnabled Enables batch processing to provide cost savings and improved efficiency for users making multiple similar large volume requests. When enabled, the system groups requests together and processes them in bulk, resulting in lower inference costs and better resource utilization. Note that batching is good for processing large volumes of requests asynchronously, but it can have delayed results (no streaming), lack of real-time feedback, limited debugging visibility, and a longer turnaround time, hence unsuitable for latency-sensitive use cases. Users can check the status of their batches or cancel an ongoing batch using the AI gateway APIs for batching.
	IsBatchingEnabled *bool `json:"isBatchingEnabled,omitempty"`

	// KeywordFiltering Keywords in a comma-separated string to filter the input.
	KeywordFiltering *[]string `json:"keywordFiltering,omitempty"`

	// Optimization Optimization profile option for the model.
	Optimization *ConfigOptimization `json:"optimization,omitempty"`

	// Provider The provider of the model.
	Provider *ConfigProvider `json:"provider,omitempty"`

	// Quantization Quantization options for the model. Options include 8-bit, 16bit, and full-precision.
	Quantization *ConfigQuantization `json:"quantization,omitempty"`

	// Type The kind of model.
	Type *ConfigType `json:"type,omitempty"`
}

// ConfigOptimization Optimization profile option for the model.
type ConfigOptimization string

// ConfigProvider The provider of the model.
type ConfigProvider string

// ConfigQuantization Quantization options for the model. Options include 8-bit, 16bit, and full-precision.
type ConfigQuantization string

// ConfigType The kind of model.
type ConfigType string

// ConfigurationType - Multi-node databases are best for deployments that require high availability. If your app requires high performance and high availability, choose the Multi-node option.
// - Single-node databases have resource limitations that make them a good choice for learning, prototyping, and non-production uses. They have limited availability.
// - Single-node databases should contain only 1 node and 1 Service Group. Adding number of nodes or service groups > 1 is not allowed for such databases.
// - By default the configurationType is multiNode.
type ConfigurationType string

// CouchbaseAuditData defines model for CouchbaseAuditData.
type CouchbaseAuditData struct {
	// CreatedAt The RFC3339 timestamp associated with when the resource was initially
	// created.
	CreatedAt time.Time `json:"createdAt"`

	// CreatedBy The user who created the resource; this will be a UUID4 ID for standard
	// users and will be a string such as "internal-support" for internal
	// Couchbase support users.
	CreatedBy string `json:"createdBy"`

	// ModifiedAt The RFC3339 timestamp associated with when the resource was last modified.
	ModifiedAt time.Time `json:"modifiedAt"`

	// ModifiedBy The user who last modified the resource; this will be a UUID4 ID for
	// standard users and wilmal be a string such as "internal-support" for
	// internal Couchbase support users.
	ModifiedBy string `json:"modifiedBy"`

	// Version The version of the document. This value is incremented each time the
	// resource is modified.
	Version int `json:"version"`
}

// CouchbaseKeyspace defines model for CouchbaseKeyspace.
type CouchbaseKeyspace struct {
	// Bucket The name of the target bucket for the workflow.
	Bucket string `json:"bucket"`

	// Collection The name of the target collection for the workflow.
	Collection string `json:"collection"`

	// Scope The name of the target scope for the workflow.
	Scope string `json:"scope"`
}

// CouchbaseServer defines model for CouchbaseServer.
type CouchbaseServer struct {
	// Version Version of the Couchbase Server to be installed in the cluster. Refer to documentation [here](https://docs.couchbase.com/cloud/clusters/upgrade-database.html#server-version-maintenance-support) for list of supported versions. The latest Couchbase Server version will be deployed by default.
	Version *string `json:"version,omitempty"`
}

// CreateAPIKeyRequest defines model for CreateAPIKeyRequest.
type CreateAPIKeyRequest struct {
	// AllowedCIDRs List of inbound CIDRs for the API key.
	// The system making a request must come from one of the allowed CIDRs.
	AllowedCIDRs *APIKeyAllowedCIDRs `json:"allowedCIDRs,omitempty"`

	// Description Description for the API key.
	Description *APIKeyDescription `json:"description,omitempty"`

	// Expiry Expiry of the API key in number of days.
	// If set to -1, the token will not expire.
	Expiry *APIKeyExpiry `json:"expiry,omitempty"`

	// Name Name of the API key.
	Name              APIKeyName                `json:"name"`
	OrganizationRoles []APIKeyOrganizationRoles `json:"organizationRoles"`

	// Resources Resources are the resource level permissions associated with the API key.
	//
	// To learn more about Organization Roles, see [Organization Roles](https://docs.couchbase.com/cloud/organizations/organization-user-roles.html).
	Resources *APIKeyResources `json:"resources,omitempty"`
}

// CreateAPIKeyResponse defines model for CreateAPIKeyResponse.
type CreateAPIKeyResponse struct {
	// Id The id is a unique identifier for an apiKey.
	Id APIKeyId `json:"id"`

	// Token The Token is a confidential piece of information that is used to authorize requests made to v4 endpoints.
	Token Token `json:"token"`
}

// CreateAlertRequest defines model for CreateAlertRequest.
type CreateAlertRequest struct {
	Config RequestConfig `json:"config"`

	// Kind Type of alert integration, currently supports only 'webhook'.
	Kind CreateAlertRequestKind `json:"kind"`

	// Name Name of the alert integration (up to 1024 characters).
	Name string `json:"name"`
}

// CreateAlertRequestKind Type of alert integration, currently supports only 'webhook'.
type CreateAlertRequestKind string

// CreateAlertResponse defines model for CreateAlertResponse.
type CreateAlertResponse struct {
	// Id The ID of the alert integration created.
	Id openapi_types.UUID `json:"id"`
}

// CreateAllowedCidrRequest defines model for CreateAllowedCidrRequest.
type CreateAllowedCidrRequest struct {
	// Cidr The trusted CIDR to allow the database connections from. The example
	// represents a single IP address (i.e. a subnet mask of 32).
	Cidr string `json:"cidr"`

	// Comment A short description of the allowed CIDR.
	Comment *string `json:"comment,omitempty"`

	// ExpiresAt An RFC3339 timestamp determining when the allowed CIDR should expire.
	// If this field is empty/omitted then the allowed CIDR is permanent and will never automatically expire.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
}

// CreateAllowedCidrResponse defines model for CreateAllowedCidrResponse.
type CreateAllowedCidrResponse struct {
	// Id The ID of the allowed CIDR.
	Id string `json:"id"`
}

// CreateAppEndpointRequest defines model for CreateAppEndpointRequest.
type CreateAppEndpointRequest struct {
	// Bucket The Capella Cluster backing bucket for the App Endpoint.
	Bucket string      `json:"bucket"`
	Cors   *CORSConfig `json:"cors,omitempty"`

	// DeltaSyncEnabled Enable/disable delta sync
	DeltaSyncEnabled *bool `json:"deltaSyncEnabled,omitempty"`

	// Name App Endpoint name. Must be less than 228 characters. It can only contain lowercase letters, numbers, or the following characters `-_$+()`
	Name string `json:"name"`

	// Oidc OpenID Connect provider configuration.
	Oidc   *[]OIDCProvider `json:"oidc,omitempty"`
	Scopes *ScopesConfig   `json:"scopes,omitempty"`

	// UserXattrKey The key of the user-extended attributes (xattr) that will be accessible from the Access control and validation function. If left empty, the feature will be disabled.
	UserXattrKey *string `json:"userXattrKey,omitempty"`
}

// CreateAppServiceAdminUserRequest defines model for CreateAppServiceAdminUserRequest.
type CreateAppServiceAdminUserRequest struct {
	Access CreateAppServiceAdminUserRequest_Access `json:"access"`

	// EnableBucketLevelAccess When set to true, the user will automatically be granted admin access to all App Endpoints in a bucket (that is currently associated with the App Endpoint(s) specified in the endpoints field), including ones that are created in future.
	// The flag defaults to true. Currently, the only supported value is true, which means that the user will have admin access to all App Endpoints in this bucket.
	// In the future, there will be the option to set this to false.
	EnableBucketLevelAccess *bool `json:"enableBucketLevelAccess,omitempty"`

	// Name The name of the user.
	Name string `json:"name"`

	// Password The password of the user.
	Password string `json:"password"`
}

// CreateAppServiceAdminUserRequest_Access defines model for CreateAppServiceAdminUserRequest.Access.
type CreateAppServiceAdminUserRequest_Access struct {
	union json.RawMessage
}

// CreateAppServiceAdminUserResponse defines model for CreateAppServiceAdminUserResponse.
type CreateAppServiceAdminUserResponse struct {
	// Id The ID of the user
	Id *string `json:"id,omitempty"`
}

// CreateAppServiceAuditLogRequest defines model for CreateAppServiceAuditLogRequest.
type CreateAppServiceAuditLogRequest struct {
	// AuditEnabled Determines whether audit logging is enabled or not on the App Service.
	AuditEnabled bool `json:"auditEnabled"`
}

// CreateAppServicerRequest defines model for CreateAppServicerRequest.
type CreateAppServicerRequest struct {
	// Compute The CPU and RAM configuration of the App Service. The supported combinations are:
	// | CPU (cores)| RAM  (GB)   |
	// | --------   |   -------   |
	// | 2          | 4           |
	// | 4          | 8           |
	// | 8          | 16          |
	// | 16         | 32          |
	// | 36         | 72          |
	Compute *AppServiceCompute `json:"compute,omitempty"`

	// Description A short description of the App Service.
	Description *string `json:"description,omitempty"`

	// Name Name of the cluster (up to 256 characters).
	Name string `json:"name"`

	// Nodes Number of nodes configured for the App Service. Number of nodes configured for the App Service. The number of nodes can range from 2 to 12.
	Nodes *int `json:"nodes,omitempty"`

	// Version The version of the App Service server. If left empty, it will be defaulted to the latest available version.
	Version *string `json:"version,omitempty"`
}

// CreateAppServicesResponse defines model for CreateAppServicesResponse.
type CreateAppServicesResponse struct {
	// Id The ID of the App Service created.
	Id openapi_types.UUID `json:"id"`
}

// CreateAzurePrivateEndpointCommandRequest defines model for CreateAzurePrivateEndpointCommandRequest.
type CreateAzurePrivateEndpointCommandRequest struct {
	// ResourceGroupName The name of your resource group
	ResourceGroupName string `json:"resourceGroupName"`

	// VirtualNetwork The virtual network and subnet name
	VirtualNetwork string `json:"virtualNetwork"`
}

// CreateBucketRequest defines model for CreateBucketRequest.
type CreateBucketRequest struct {
	// BucketConflictResolution The means by which conflicts are resolved during replication.
	//
	// - This field may be referred to as "conflict resolution" in the Couchbase documentation, and `seqno` and `lww` may be referred to as "sequence number" and "timestamp" respectively.
	//
	// - This field cannot be changed later.
	//
	//  To learn more, see [Conflict Resolution](https://docs.couchbase.com/cloud/clusters/xdcr/xdcr.html#conflict-resolution).
	BucketConflictResolution *BucketConflictResolution `json:"bucketConflictResolution,omitempty"`

	// DurabilityLevel This is the minimum level at which all writes to the bucket must occur.
	//
	//  The options for Durability level are as follows, according to the bucket type.
	//
	//  - For a Couchbase bucket:
	//
	//    1. None
	//
	//    2. Replicate to Majority
	//
	//    3. Majority and Persist to Active
	//
	//    4. Persist to Majority
	//
	//  - For an Ephemeral bucket:
	//
	//    1. None
	//
	//    2. Replicate to Majority
	//
	//  To learn more, see [Create a Bucket](https://docs.couchbase.com/cloud/clusters/data-service/manage-buckets.html#add-bucket).
	DurabilityLevel *DurabilityLevel `json:"durabilityLevel,omitempty"`

	// EvictionPolicy The policy which Capella adopts to prevent data loss due to memory exhaustion.
	// This may be also known as Ejection Policy in the Couchbase documentation.
	//
	// - For Couchbase bucket, Eviction Policy is `fullEviction` by default.
	//
	// - For Ephemeral buckets, Eviction Policy is a required field, and should be one of the following:
	//
	//    1. noEviction
	//
	//    2. nruEviction
	//
	//   To learn more, see [Ejection Policy](https://docs.couchbase.com/server/current/rest-api/rest-bucket-create.html#evictionpolicy).
	EvictionPolicy *EvictionPolicy `json:"evictionPolicy,omitempty"`

	// Flush Replaced by flushEnabled. This property is deprecated and will be removed in a future release.
	//
	// Determines whether flushing is enabled on the bucket. Enable Flush to delete all items in this bucket at the earliest opportunity. Disable Flush to avoid inadvertent data loss.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Flush *bool `json:"flush,omitempty"`

	// FlushEnabled Determines whether bucket flush is enabled. Set flushEnabled to true to be able to delete all items in this bucket using the /flush endpoint. Disable flushEnabled to avoid inadvertent data loss by calling the /flush endpoint .
	FlushEnabled *bool `json:"flushEnabled,omitempty"`

	// MemoryAllocationInMb The amount of memory to allocate for the bucket memory in MiB. This is the maximum limit is dependent on the allocation of the KV service. For example, 80% of the allocation.
	//
	// - For Couchbase buckets, the default and minimum memory allocation changes according to the Storage Backend type as follows:
	//
	//   1. For Couchstore, the default and minimum memory allocation is 100 MiB.
	//
	//   2. For Magma, the default and minimum memory allocation is 1024 MiB with 1024 buckets for Couchbase server below 8.0.
	//      The default and minimum memory allocation is 100 MiB with 128 vbuckets for Couchbase server version 8.0 and above.
	//
	// - For Ephemeral buckets, the default and minimum memory allocation is 100 MiB.
	MemoryAllocationInMb *int `json:"memoryAllocationInMb,omitempty"`

	// Name Name of the bucket. This field cannot be changed later. The name should adhere to the following rules:
	//
	// 1. Characters used for the name should be in the ranges of A-Z, a-z, and 0-9; plus the underscore, period, dash, and percent characters.
	//
	// 2. The name can be a maximum of 100 characters in length.
	//
	// 3. The name cannot have 0 characters or empty. Minimum length of name is 1.
	//
	// 4. The name cannot start with a `.` (period).
	Name string `json:"name"`

	// Priority Priority of the bucket.
	//
	// - Specify relative bucket priority so that buckets will be recovered in the order specified during failover.
	//
	// - Bucket ranking/priority is only available in Couchbase Server 7.6 and above
	//
	// - Default bucket priority is 0 and can be set to a value between 0 and 1000. 1000 is the highest priority and 0 is the lowest.
	Priority *BucketPriority `json:"priority,omitempty"`

	// Replicas The number of replicas for the bucket.
	// To learn more, see [Create a Bucket](https://docs.couchbase.com/cloud/clusters/data-service/manage-buckets.html#add-bucket).
	Replicas *Replicas `json:"replicas,omitempty"`

	// StorageBackend The storage engine to be assigned to and used by the bucket.
	//
	// - Ephemeral buckets do not support StorageBackend, hence not applicable for Ephemeral buckets and throws an error if this field is added.
	//
	// - This field is only applicable for a Couchbase bucket. The default value before Couchbase Server 8.0 is `couchstore`.
	//   The default value for Couchbase Server 8.0 and above is `magma` with 128 vbuckets.
	//
	// - This field cannot be changed later.
	//
	//   To learn more, see [Storage Engines](https://docs.couchbase.com/cloud/clusters/data-service/storage-engines.html).
	StorageBackend *StorageBackend `json:"storageBackend,omitempty"`

	// TimeToLiveInSeconds Specify the time to live (TTL) value in seconds. This is the maximum time to live for items in the bucket. Default is 0, that means TTL is disabled. This is a non-negative value.
	TimeToLiveInSeconds *int `json:"timeToLiveInSeconds,omitempty"`

	// Type Type of the bucket.
	//
	// - If selected Ephemeral, it is not eligible for imports or App Endpoints creation. This field cannot be changed later.
	//
	// - The options may also be referred to as Memory and Disk (Couchbase), Memory Only (Ephemeral) in the Couchbase documentation.
	//
	// To learn more, see [Create a Bucket](https://docs.couchbase.com/cloud/clusters/data-service/manage-buckets.html#add-bucket).
	Type *Type `json:"type,omitempty"`

	// Vbuckets This field only applies to Couchbase Server 8.0 and above for magma buckets.
	//
	// There are two options for the number of vBuckets: 128 and 1024. The number of vBuckets cannot be changed after the bucket is created.
	Vbuckets *CreateBucketRequestVbuckets `json:"vbuckets,omitempty"`
}

// CreateBucketRequestVbuckets This field only applies to Couchbase Server 8.0 and above for magma buckets.
//
// There are two options for the number of vBuckets: 128 and 1024. The number of vBuckets cannot be changed after the bucket is created.
type CreateBucketRequestVbuckets int

// CreateBucketResponse defines model for CreateBucketResponse.
type CreateBucketResponse struct {
	// Id The ID of the bucket. This is the base64 encoding of the bucket name.
	Id string `json:"id"`
}

// CreateCMEKMetadata defines model for CreateCMEKMetadata.
type CreateCMEKMetadata struct {
	Config CreateCMEKMetadata_Config `json:"config"`

	// Description Description of the key (up to 1024 characters).
	Description *string `json:"description,omitempty"`

	// Name Name of the key (up to 256 characters).
	Name string `json:"name"`
}

// CreateCMEKMetadata_Config defines model for CreateCMEKMetadata.Config.
type CreateCMEKMetadata_Config struct {
	union json.RawMessage
}

// CreateCMEKMetadataResponse defines model for CreateCMEKMetadataResponse.
type CreateCMEKMetadataResponse struct {
	// Id The ID of the KMS metadata created.
	Id openapi_types.UUID `json:"id"`
}

// CreateCloudSnapshotBackupRequest defines model for CreateCloudSnapshotBackupRequest.
type CreateCloudSnapshotBackupRequest struct {
	// RegionsToCopy Specifies the regions where the backup will be copied. A maximum of two regions can be selected.
	// If not provided, the backup will remain single-region.
	RegionsToCopy *[]string `json:"regionsToCopy,omitempty"`

	// Retention Represents interval in hours to retain the backup.
	Retention *int `json:"retention,omitempty"`
}

// CreateCloudSnapshotBackupResponse defines model for CreateCloudSnapshotBackupResponse.
type CreateCloudSnapshotBackupResponse struct {
	// BackupId The id is a unique identifier for a backup.
	BackupId *string `json:"backupId,omitempty"`
}

// CreateCloudSnapshotCloneRequest defines model for CreateCloudSnapshotCloneRequest.
type CreateCloudSnapshotCloneRequest struct {
	Availability Availability `json:"availability"`

	// CloudProvider The cloud provider where the cluster will be hosted.
	// For information about providers and supported regions, see:
	//
	// - [Amazon Web Services](https://docs.couchbase.com/cloud/reference/aws.html)
	//
	// - [Google Cloud Platform](https://docs.couchbase.com/cloud/reference/gcp.html)
	//
	// - [Microsoft Azure](https://docs.couchbase.com/cloud/reference/azure.html)
	CloudProvider CloudProvider `json:"cloudProvider"`

	// Description Description of the cloned cluster (up to 1024 characters).
	Description *string `json:"description,omitempty"`

	// Name Name of the cloned cluster (up to 256 characters).
	Name    string  `json:"name"`
	Support Support `json:"support"`

	// Zones Zones is the cloud services provider availability zones for the cloned cluster. Currently Supported only for single AZ clusters so only 1 zone is allowed in list.
	Zones *[]string `json:"zones,omitempty"`
}

// CreateCloudSnapshotCloneResponse defines model for CreateCloudSnapshotCloneResponse.
type CreateCloudSnapshotCloneResponse struct {
	// ClusterId The id is a unique identifier for a cluster.
	ClusterId *string `json:"clusterId,omitempty"`

	// RestoreId The id is a unique identifier for a restore.
	RestoreId *RestoreId `json:"restoreId,omitempty"`
}

// CreateCloudSnapshotRestoreRequest defines model for CreateCloudSnapshotRestoreRequest.
type CreateCloudSnapshotRestoreRequest struct {
	// CrossRegionRestorePreference Defines the priority order of cross-regional cloud snapshots, based on the index of the array, to be used as a fallback for cluster restoration when the primary backup in the cluster's region is not restorable. The first region in the list is assigned the highest priority, followed by each subsequent region in order.
	CrossRegionRestorePreference *[]string `json:"crossRegionRestorePreference,omitempty"`
}

// CreateCloudSnapshotRestoreResponse defines model for CreateCloudSnapshotRestoreResponse.
type CreateCloudSnapshotRestoreResponse struct {
	// RestoreId The id is a unique identifier for a restore.
	RestoreId *RestoreId `json:"restoreId,omitempty"`
}

// CreateClusterAuditLogExportRequest defines model for CreateClusterAuditLogExportRequest.
type CreateClusterAuditLogExportRequest struct {
	// End Specifies the audit log's end date and time.
	End time.Time `json:"end"`

	// Start Specifies the audit log's start date and time.
	Start time.Time `json:"start"`
}

// CreateClusterAuditLogExportResponse defines model for CreateClusterAuditLogExportResponse.
type CreateClusterAuditLogExportResponse struct {
	// ExportId The export ID of the export job.
	ExportId string `json:"exportId"`
}

// CreateClusterAuditSettingsRequest defines model for CreateClusterAuditSettingsRequest.
type CreateClusterAuditSettingsRequest struct {
	// AuditEnabled Determines whether audit logging is enabled or not on the cluster.
	AuditEnabled bool `json:"auditEnabled"`

	// DisabledUsers List of users whose filterable events will not be logged.
	DisabledUsers AuditSettingsDisabledUsers `json:"disabledUsers"`

	// EnabledEventIDs List of enabled filterable audit events for the cluster.
	EnabledEventIDs []int32 `json:"enabledEventIDs"`
}

// CreateClusterOnRequest defines model for CreateClusterOnRequest.
type CreateClusterOnRequest struct {
	// TurnOnLinkedAppService Set this value to true if you want to turn on the app service linked with the cluster, false if not.
	// If set to true, the app service, if present, will turn on with the cluster.
	// Default value for this is false, which means the linked app service will be kept off.
	TurnOnLinkedAppService *bool `json:"turnOnLinkedAppService,omitempty"`
}

// CreateClusterRequest defines model for CreateClusterRequest.
type CreateClusterRequest struct {
	Availability Availability `json:"availability"`

	// CloudProvider The cloud provider where the cluster will be hosted.
	// For information about providers and supported regions, see:
	//
	// - [Amazon Web Services](https://docs.couchbase.com/cloud/reference/aws.html)
	//
	// - [Google Cloud Platform](https://docs.couchbase.com/cloud/reference/gcp.html)
	//
	// - [Microsoft Azure](https://docs.couchbase.com/cloud/reference/azure.html)
	CloudProvider CloudProvider `json:"cloudProvider"`

	// CmekId The ID of the CMEK Key.
	CmekId *openapi_types.UUID `json:"cmekId,omitempty"`

	// ConfigurationType - Multi-node databases are best for deployments that require high availability. If your app requires high performance and high availability, choose the Multi-node option.
	// - Single-node databases have resource limitations that make them a good choice for learning, prototyping, and non-production uses. They have limited availability.
	// - Single-node databases should contain only 1 node and 1 Service Group. Adding number of nodes or service groups > 1 is not allowed for such databases.
	// - By default the configurationType is multiNode.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	ConfigurationType *ConfigurationType `json:"configurationType,omitempty"`
	CouchbaseServer   *CouchbaseServer   `json:"couchbaseServer,omitempty"`

	// Description Description of the cluster (up to 1024 characters).
	Description *string `json:"description,omitempty"`

	// EnablePrivateDNSResolution EnablePrivateDNSResolution signals that the cluster should have hostnames that are hosted in a public DNS zone that resolve to a private DNS address. This exists to support the use case of customers connecting from their own data centers where it is not possible to make use of a cloud service provider DNS zone.
	EnablePrivateDNSResolution *bool `json:"enablePrivateDNSResolution,omitempty"`

	// Name Name of the cluster (up to 256 characters).
	Name string `json:"name"`

	// ServiceGroups The couchbase service groups to be run. - The set of nodes that share the same disk, number of nodes and services. - At least one service group must contain the data service.
	ServiceGroups []ServiceGroup `json:"serviceGroups"`
	Support       Support        `json:"support"`

	// Zones Zones is the cloud services provider availability zones for the cluster. Currently Supported only for single AZ clusters so only 1 zone is allowed in list.
	Zones *[]string `json:"zones,omitempty"`
}

// CreateClusterResponse defines model for CreateClusterResponse.
type CreateClusterResponse struct {
	// Id The ID of the cluster created.
	Id openapi_types.UUID `json:"id"`
}

// CreateCollectionRequest defines model for CreateCollectionRequest.
type CreateCollectionRequest struct {
	// MaxTTL Specify the time to live (TTL) value in seconds. Defines the duration (Seconds) for which the documents in a collection are kept before automatic removal from the database. -  For server versions < 7.6.0, this is a non-negative value. Set to 0 to use the bucket's maxTTL value. -  For server versions >= 7.6.0, this value should be >= -1. Set to -1 to disable expiry for that collection. Set to 0 to use the bucket's maxTTL value. -  The maximum value that can be set for maxTTL is 2147483647.
	MaxTTL *int `json:"maxTTL,omitempty"`

	// Name The name of the collection. The name should adhere to the following rules:
	//
	// 1. The name must be between 1 and 251 characters in length.
	//
	// 2. The name can contain only the characters A-Z, a-z, 0-9, and the symbols _, -, and %.
	//
	// 3. The name cannot start with _ or %.
	//
	// Note that scope and collection names are case-sensitive.
	Name string `json:"name"`
}

// CreateColumnarAnalyticsBackupRequest defines model for CreateColumnarAnalyticsBackupRequest.
type CreateColumnarAnalyticsBackupRequest struct {
	// Retention Represents interval in hours to retain the backup.
	Retention *int `json:"retention,omitempty"`
}

// CreateColumnarAnalyticsBackupResponse defines model for CreateColumnarAnalyticsBackupResponse.
type CreateColumnarAnalyticsBackupResponse struct {
	// BackupId The unique identifier for a backup.
	BackupId *string `json:"backupId,omitempty"`
}

// CreateColumnarAnalyticsClusterRequest Create an analytics cluster
type CreateColumnarAnalyticsClusterRequest struct {
	Availability Availability `json:"availability"`

	// CloudProvider Cloud provider selection
	//
	// 1. `aws`: Amazon Web Services
	//
	// 2. `gcp`: Google Cloud Platform
	CloudProvider CreateColumnarAnalyticsClusterRequestCloudProvider `json:"cloudProvider"`

	// Compute Following are the supported compute combinations for CPU and RAM for different cloud providers.
	// To learn more, see [Amazon Web Services](https://docs.couchbase.com/cloud/reference/aws.html).
	Compute Compute `json:"compute"`

	// Description The description of the analytics cluster.
	Description *string `json:"description,omitempty"`

	// Name Name of the analytics cluster
	Name string `json:"name"`

	// Nodes The number of nodes.
	Nodes int `json:"nodes"`

	// Region Which region should the analytics cluster be deployed in.
	Region  string          `json:"region"`
	Support ColumnarSupport `json:"support"`
}

// CreateColumnarAnalyticsClusterRequestCloudProvider Cloud provider selection
//
// 1. `aws`: Amazon Web Services
//
// 2. `gcp`: Google Cloud Platform
type CreateColumnarAnalyticsClusterRequestCloudProvider string

// CreateColumnarAnalyticsClusterResponse Create an analytics cluster
type CreateColumnarAnalyticsClusterResponse struct {
	// Id The UUID of the analytics cluster created.
	Id openapi_types.UUID `json:"id"`
}

// CreateColumnarAnalyticsRestoreResponse defines model for CreateColumnarAnalyticsRestoreResponse.
type CreateColumnarAnalyticsRestoreResponse struct {
	// RestoreId The id is a unique identifier for a restore.
	RestoreId *string `json:"restoreId,omitempty"`
}

// CreateDatabaseCredentialRequest defines model for CreateDatabaseCredentialRequest.
type CreateDatabaseCredentialRequest struct {
	// Access Describes the access information of the database credential.
	Access []Access `json:"access"`

	// Name Username for the database credential. The name should adhere to the following rules:
	//
	// 1. The name must be between 2 & 128 characters.
	//
	// 2. The name cannot contain spaces.
	//
	// 3. The name cannot contain the following characters - `) ( > < , ; : " \ / ] [ ? = } {`
	//
	// 4. The name cannot begin with `@` character.
	Name string `json:"name"`

	// Password A password associated with the database credential. If this field is left empty, a password will be auto-generated.
	//
	// - The password should adhere to the following rules:
	//
	//   1. The password should have at least 8 characters.
	//
	//   2. Characters used for the password should contain at least one uppercase (A-Z), one lowercase (a-z), one numerical (0-9), and one special character.
	//
	//   3. The password must not contain any of the following characters: `< > ; . * & | £`
	Password *string `json:"password,omitempty"`
}

// CreateDatabaseCredentialResponse defines model for CreateDatabaseCredentialResponse.
type CreateDatabaseCredentialResponse struct {
	// Id The ID of the database credential created.
	Id openapi_types.UUID `json:"id"`

	// Password A password associated with the database credential. Password will have a minimum length of 8 characters and contain at least one lowercase letter, one uppercase letter, one number, and one special character.
	Password string `json:"password"`
}

// CreateFreeTierAppServiceRequest defines model for CreateFreeTierAppServiceRequest.
type CreateFreeTierAppServiceRequest struct {
	// Description A short description of the App Service.
	Description *string `json:"description,omitempty"`

	// Name Name of App Service.
	Name string `json:"name"`
}

// CreateFreeTierBucketRequest defines model for CreateFreeTierBucketRequest.
type CreateFreeTierBucketRequest struct {
	// MemoryAllocationInMb The bucket memory quota. It defaults to 100 MiB.
	MemoryAllocationInMb *int `json:"memoryAllocationInMb,omitempty"`

	// Name Name of the bucket. This field cannot be changed later. The name should adhere to the following rules:
	//
	// 1. Characters used for the name should be in the ranges of A-Z, a-z, and 0-9; plus the underscore, period, dash, and percent characters.
	//
	// 2. The name can be a maximum of 100 characters in length.
	//
	// 3. The name cannot have 0 characters or empty. Minimum length of name is 1.
	//
	// 4. The name cannot start with a `.` (period).
	Name string `json:"name"`
}

// CreateFreeTierClusterRequest defines model for CreateFreeTierClusterRequest.
type CreateFreeTierClusterRequest struct {
	// CloudProvider The cloud provider where the cluster will be hosted.
	// For information about providers and supported regions, see:
	//
	// - [Amazon Web Services](https://docs.couchbase.com/cloud/reference/aws.html)
	//
	// - [Google Cloud Platform](https://docs.couchbase.com/cloud/reference/gcp.html)
	//
	// - [Microsoft Azure](https://docs.couchbase.com/cloud/reference/azure.html)
	CloudProvider CloudProvider `json:"cloudProvider"`

	// Description Description of the cluster (up to 1024 characters).
	Description *string `json:"description,omitempty"`

	// Name Name of the cluster (up to 256 characters).
	Name string `json:"name"`
}

// CreateGCPPrivateEndpointCommandRequest defines model for CreateGCPPrivateEndpointCommandRequest.
type CreateGCPPrivateEndpointCommandRequest struct {
	SubnetIDs []string `json:"subnetIDs"`

	// VpcNetworkID The ID of your vpc network in gcp
	VpcNetworkID string `json:"vpcNetworkID"`
}

// CreateLanguageModelAPIKeyRequest defines model for CreateLanguageModelAPIKeyRequest.
type CreateLanguageModelAPIKeyRequest struct {
	// AllowedCIDRs List of IP addresses or CIDR blocks that are allowed to use this API key.
	AllowedCIDRs *[]string `json:"allowedCIDRs,omitempty"`

	// Description Description of the Language Model API Key.
	Description *string `json:"description,omitempty"`

	// Expiry Expiry of the API key in number of days. Maximum value is 365 days.
	Expiry *float32 `json:"expiry,omitempty"`

	// Name Name of the Language Model API Key.
	Name string `json:"name"`
}

// CreateLanguageModelAPIKeyResponse defines model for CreateLanguageModelAPIKeyResponse.
type CreateLanguageModelAPIKeyResponse struct {
	// Id Unique identifier for the Model API key.
	Id *string `json:"id,omitempty"`

	// Token Generated API key token (only returned during creation).
	Token *string `json:"token,omitempty"`
}

// CreateLanguageModelResponse Response for language model creation request.
type CreateLanguageModelResponse struct {
	// Id Unique identifier for the created language model.
	Id *openapi_types.UUID `json:"id,omitempty"`
}

// CreateNetworkPeeringRequest defines model for CreateNetworkPeeringRequest.
type CreateNetworkPeeringRequest struct {
	// Name Name of the peering relationship. -  The name of the peering relationship must be at least 2 characters long. -  The name can not exceed 128 characters.
	Name string `json:"name"`

	// ProviderConfig The config data for a peering relationship for a cluster on AWS, GCP, or Azure.
	ProviderConfig CreateNetworkPeeringRequest_ProviderConfig `json:"providerConfig"`

	// ProviderType Type of the cloud provider for which the peering connection is created. Which are- 1. aws 2. gcp 3. azure
	ProviderType string `json:"providerType"`
}

// CreateNetworkPeeringRequest_ProviderConfig The config data for a peering relationship for a cluster on AWS, GCP, or Azure.
type CreateNetworkPeeringRequest_ProviderConfig struct {
	union json.RawMessage
}

// CreateNetworkPeeringResponse defines model for CreateNetworkPeeringResponse.
type CreateNetworkPeeringResponse struct {
	// Id The ID is the unique UUID generated when a VPC record is created.
	Id openapi_types.UUID `json:"id"`
}

// CreateOIDCProviderRequest defines model for CreateOIDCProviderRequest.
type CreateOIDCProviderRequest struct {
	// ClientId The OpenID Connect provider client ID.
	ClientId string `json:"clientId"`

	// DiscoveryUrl The URL for the non-standard discovery endpoint.
	DiscoveryUrl *string `json:"discoveryUrl,omitempty"`

	// Issuer The URL for the OpenID Connect issuer.
	Issuer string `json:"issuer"`

	// Register Indicates whether to register a new App Service user account when a user logs in using OpenID Connect.
	Register *bool `json:"register,omitempty"`

	// RolesClaim If set, the value(s) of the given OpenID Connect authentication token claim will be added to the user's roles.
	// The value of this claim in the OIDC token must be either a string or an array of strings, any other type will result in an error.
	RolesClaim *string `json:"rolesClaim,omitempty"`

	// UserPrefix Username prefix for all users created for this provider
	UserPrefix *string `json:"userPrefix,omitempty"`

	// UsernameClaim Allows a different OpenID Connect field to be specified instead of the Subject (sub).
	UsernameClaim *string `json:"usernameClaim,omitempty"`
}

// CreateOnDemandRestoreRequest defines model for CreateOnDemandRestoreRequest.
type CreateOnDemandRestoreRequest struct {
	// AutoRemoveCollections Automatically delete scopes/collections which are known to be deleted in the backup.
	AutoRemoveCollections *bool `json:"autoRemoveCollections,omitempty"`

	// BackupID The backup record ID that contains the backup to restore from.
	BackupID openapi_types.UUID `json:"backupID"`

	// ExcludeData Skips restoring the data specified here.
	ExcludeData *string `json:"excludeData,omitempty"`

	// FilterKeys Only restore data where the key matches a particular regular expression.
	FilterKeys *string `json:"filterKeys,omitempty"`

	// FilterValues Only restore data where the value matches a particular regular expression.
	FilterValues *string `json:"filterValues,omitempty"`

	// ForceUpdates Forces data in the Couchbase cluster to be overwritten even if the data in the cluster is newer.
	ForceUpdates *bool `json:"forceUpdates,omitempty"`

	// IncludeData Restores only the data specified here.
	IncludeData *string `json:"includeData,omitempty"`

	// MapData Specified when you want to restore source data into a different location.
	MapData *string `json:"mapData,omitempty"`

	// ReplaceTTL Sets a new expiration (time-to-live) value for the specified keys.
	ReplaceTTL *CreateOnDemandRestoreRequestReplaceTTL `json:"replaceTTL,omitempty"`

	// ReplaceTTLWith Updates the expiration for the keys.
	ReplaceTTLWith *string  `json:"replaceTTLWith,omitempty"`
	Services       Services `json:"services"`

	// SourceClusterID The ID of the source cluster the restore is based on.
	SourceClusterID openapi_types.UUID `json:"sourceClusterID"`

	// TargetClusterID The ID of the target cluster to restore to.
	TargetClusterID openapi_types.UUID `json:"targetClusterID"`
}

// CreateOnDemandRestoreRequestReplaceTTL Sets a new expiration (time-to-live) value for the specified keys.
type CreateOnDemandRestoreRequestReplaceTTL string

// CreateOpenAIConfigurationRequest defines model for CreateOpenAIConfigurationRequest.
type CreateOpenAIConfigurationRequest struct {
	// ApiKey The API key to access the OpenAI API.
	ApiKey string `json:"apiKey"`
}

// CreatePrivateEndpointCommandResponse defines model for CreatePrivateEndpointCommandResponse.
type CreatePrivateEndpointCommandResponse struct {
	// Command The CLI command or script used to create private endpoint within your CSP.
	Command string `json:"command"`
}

// CreatePrivateEndpointServiceCommandRequest defines model for CreatePrivateEndpointServiceCommandRequest.
type CreatePrivateEndpointServiceCommandRequest struct {
	SubnetIDs []string `json:"subnetIDs"`

	// VpcID The ID of your virtual network
	VpcID string `json:"vpcID"`
}

// CreatePrivateEndpointServiceCommandResponse defines model for CreatePrivateEndpointServiceCommandResponse.
type CreatePrivateEndpointServiceCommandResponse struct {
	// Command The CLI command or script used to create private endpoint within your CSP.
	Command string `json:"command"`
}

// CreateProjectRequest defines model for CreateProjectRequest.
type CreateProjectRequest struct {
	// Description A short description of the project (up to 256 characters).
	Description *string `json:"description,omitempty"`

	// Name The name of the project (up to 128 characters).
	Name string `json:"name"`
}

// CreateProjectResponse defines model for CreateProjectResponse.
type CreateProjectResponse struct {
	// Id The ID of the project created.
	Id openapi_types.UUID `json:"id"`
}

// CreateProviderRequest defines model for CreateProviderRequest.
type CreateProviderRequest struct {
	// Configuration The configuration for the provider to create.
	Configuration CreateProviderRequest_Configuration `json:"configuration"`

	// Name The name for the provider integration to create.
	Name string `json:"name"`

	// Type The type of provider to create.
	Type CreateProviderRequestType `json:"type"`
}

// CreateProviderRequest_Configuration The configuration for the provider to create.
type CreateProviderRequest_Configuration struct {
	union json.RawMessage
}

// CreateProviderRequestType The type of provider to create.
type CreateProviderRequestType string

// CreateProviderResponse defines model for CreateProviderResponse.
type CreateProviderResponse struct {
	// Id The ID of the created provider.
	Id string `json:"id"`
}

// CreateReplicationJSONResponse defines model for CreateReplicationJSONResponse.
type CreateReplicationJSONResponse struct {
	// ReplicationId The ID of the replication. This field is present for both oneWay and twoWay replications.
	ReplicationId string `json:"replicationId"`

	// ReverseReplicationId The ID of the replication from target to source. This field is only present for twoWay replications.
	ReverseReplicationId *string `json:"reverseReplicationId,omitempty"`
}

// CreateReplicationRequest defines model for CreateReplicationRequest.
type CreateReplicationRequest struct {
	// Direction Direction specifies the replication flow — whether it's oneWay (source to target only) or twoWay (also from target back to source).
	Direction *CreateReplicationRequestDirection `json:"direction,omitempty"`

	// Filter Filter contains the replication settings which are passed to the Couchbase server API while creating a replication.
	Filter *Filter `json:"filter,omitempty"`

	// Mappings Defines mappings from source to target scopes and collections.
	// This field is only required if you are replicating specific scopes and collections.
	//
	// Note: If the collections array is empty or omitted, it implies all collections under that scope would be replicated.
	Mappings *Mappings `json:"mappings,omitempty"`

	// Mode This specifies the replication creation mode.
	Mode CreateReplicationRequestMode `json:"mode"`

	// NetworkUsageLimit Network usage limit in MiB per second. 0 means unlimited.
	NetworkUsageLimit *int `json:"networkUsageLimit,omitempty"`

	// Priority Priority represents the resource allocation to the replication.
	//
	// - low: Resource constraints are applied when competing with high priority replications
	// - medium: Resource constraints are applied during initial processing when competing with high priority replications, then operates as high priority
	// - high: No resource constraints are applied (default priority)
	Priority *CreateReplicationRequestPriority `json:"priority,omitempty"`

	// SourceBucket The ID of the source bucket.
	SourceBucket string `json:"sourceBucket"`

	// Target Target contains all the metadata about a replication target.
	Target struct {
		// Bucket The target bucket identifier.
		// - For Capella buckets, use bucket ID
		// - For external clusters, use bucket name
		Bucket string `json:"bucket"`

		// Cluster The target cluster identifier.
		// - For Capella clusters, use cluster ID
		// - For external clusters, use cluster reference name
		Cluster string `json:"cluster"`

		// Type Type tells us if the target cluster is capella or external.
		Type *CreateReplicationRequestTargetType `json:"type,omitempty"`
	} `json:"target"`
}

// CreateReplicationRequestDirection Direction specifies the replication flow — whether it's oneWay (source to target only) or twoWay (also from target back to source).
type CreateReplicationRequestDirection string

// CreateReplicationRequestMode This specifies the replication creation mode.
type CreateReplicationRequestMode string

// CreateReplicationRequestPriority Priority represents the resource allocation to the replication.
//
// - low: Resource constraints are applied when competing with high priority replications
// - medium: Resource constraints are applied during initial processing when competing with high priority replications, then operates as high priority
// - high: No resource constraints are applied (default priority)
type CreateReplicationRequestPriority string

// CreateReplicationRequestTargetType Type tells us if the target cluster is capella or external.
type CreateReplicationRequestTargetType string

// CreateS3ConfigurationRequest defines model for CreateS3ConfigurationRequest.
type CreateS3ConfigurationRequest struct {
	// AccessKeyId The access key ID to access the S3 bucket.
	AccessKeyId string `json:"accessKeyId"`

	// AwsRegion The AWS region the S3 bucket is located in.
	AwsRegion string `json:"awsRegion"`

	// Bucket The name of the S3 bucket.
	Bucket string `json:"bucket"`

	// FolderPath The path to the folder in the S3 bucket where the files are stored. Leave empty for root folder.
	FolderPath *string `json:"folderPath,omitempty"`

	// SecretAccessKey The secret access key to access the S3 bucket.
	SecretAccessKey string `json:"secretAccessKey"`

	// SessionToken The session token to access the S3 bucket in case of temporary credentials.
	SessionToken *string `json:"sessionToken,omitempty"`
}

// CreateScheduledBackupRequest Backup schedule type.
type CreateScheduledBackupRequest struct {
	Type *CreateScheduledBackupRequestType `json:"type,omitempty"`

	// WeeklySchedule Schedule a full backup once a week with regular incrementals.
	WeeklySchedule *struct {
		// CostOptimizedRetention Optimize backup retention to reduce total cost of ownership (TCO). This gives the option to keep all but the last backup cycle of the month for thirty days; the last cycle will be kept for the defined retention period. To learn more, see [Cost Optimized Retention Policy](https://docs.couchbase.com/cloud/clusters/backup-restore.html#cost-optimized-retention-policy).
		CostOptimizedRetention bool `json:"costOptimizedRetention"`

		// DayOfWeek Day of the week for the backup.
		DayOfWeek CreateScheduledBackupRequestWeeklyScheduleDayOfWeek `json:"dayOfWeek"`

		// IncrementalEvery Interval in hours for incremental backup.
		IncrementalEvery CreateScheduledBackupRequestWeeklyScheduleIncrementalEvery `json:"incrementalEvery"`

		// RetentionTime Retention time in days.
		RetentionTime CreateScheduledBackupRequestWeeklyScheduleRetentionTime `json:"retentionTime"`

		// StartAt Start at hour (in 24-Hour format).
		StartAt CreateScheduledBackupRequestWeeklyScheduleStartAt `json:"startAt"`
	} `json:"weeklySchedule,omitempty"`
}

// CreateScheduledBackupRequestType defines model for CreateScheduledBackupRequest.Type.
type CreateScheduledBackupRequestType string

// CreateScheduledBackupRequestWeeklyScheduleDayOfWeek Day of the week for the backup.
type CreateScheduledBackupRequestWeeklyScheduleDayOfWeek string

// CreateScheduledBackupRequestWeeklyScheduleIncrementalEvery Interval in hours for incremental backup.
type CreateScheduledBackupRequestWeeklyScheduleIncrementalEvery int

// CreateScheduledBackupRequestWeeklyScheduleRetentionTime Retention time in days.
type CreateScheduledBackupRequestWeeklyScheduleRetentionTime string

// CreateScheduledBackupRequestWeeklyScheduleStartAt Start at hour (in 24-Hour format).
type CreateScheduledBackupRequestWeeklyScheduleStartAt int

// CreateScopeRequest defines model for CreateScopeRequest.
type CreateScopeRequest struct {
	// Name The name of the scope. The name should adhere to the following rules:
	//
	// 1. The name must be between 1 and 251 characters in length.
	//
	// 2. The name can contain only the characters A-Z, a-z, 0-9, and the symbols _, -, and %.
	//
	// 3. The name cannot start with _ or %.
	//
	// Note that scope and collection names are case-sensitive.
	Name string `json:"name"`
}

// CreateStructuredWorkflowRequest defines model for CreateStructuredWorkflowRequest.
type CreateStructuredWorkflowRequest struct {
	Source struct {
		// ProviderId The unique identifier of the source's provider. This is used to identify the integration in the Capella platform.
		ProviderId string `json:"providerId"`
	} `json:"source"`

	// StructuredDataProcessingConfig Configuration for structured data processing.
	StructuredDataProcessingConfig struct {
		// JsonType The type of JSON that has to be processed by the structured data processing workflow.
		JsonType CreateStructuredWorkflowRequestStructuredDataProcessingConfigJsonType `json:"jsonType"`

		// KeyFieldName The name of the field that will be used as the key for the Couchbase document. Random UUID will be generated if not provided.
		KeyFieldName *string `json:"keyFieldName,omitempty"`
	} `json:"structuredDataProcessingConfig"`
	TargetCouchbaseKeyspace CouchbaseKeyspace `json:"targetCouchbaseKeyspace"`

	// VectorizationConfig Configuration for vectorization in a workflow.
	VectorizationConfig VectorizationConfigCreation `json:"vectorizationConfig"`
}

// CreateStructuredWorkflowRequestStructuredDataProcessingConfigJsonType The type of JSON that has to be processed by the structured data processing workflow.
type CreateStructuredWorkflowRequestStructuredDataProcessingConfigJsonType string

// CreateUnstructuredWorkflowRequest defines model for CreateUnstructuredWorkflowRequest.
type CreateUnstructuredWorkflowRequest struct {
	Source struct {
		// ProviderId The unique identifier of the source's provider. This is used to identify the integration in the Capella platform.
		ProviderId string `json:"providerId"`
	} `json:"source"`
	TargetCouchbaseKeyspace CouchbaseKeyspace `json:"targetCouchbaseKeyspace"`

	// UnstructuredDataProcessingConfig Configuration for unstructured data processing.
	UnstructuredDataProcessingConfig struct {
		// ChunkingStrategy The strategy to use for chunking the file.
		ChunkingStrategy struct {
			// ChunkOverlap The overlap between the chunks.
			ChunkOverlap *int `json:"chunkOverlap,omitempty"`

			// ChunkSize The size of the chunks.
			ChunkSize    *int                                                                                           `json:"chunkSize,omitempty"`
			StrategyType *CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigChunkingStrategyStrategyType `json:"strategyType,omitempty"`
		} `json:"chunkingStrategy"`

		// EnableOCR Whether to enable OCR scanning for the file.
		// If not provided, OCR will be disabled.
		EnableOCR *bool `json:"enableOCR,omitempty"`

		// Exclusions The sections of the file that have to be excluded from the unstructured data processing workflow.
		// Should be an array of strings, each representing a section of the file to be excluded.
		// The possible values are:
		//   - Header
		//   - Footer
		//   - Table
		//
		// If not provided, all sections will be processed.
		Exclusions *[]CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigExclusions `json:"exclusions,omitempty"`

		// PageNumbers The page range of the file which has to be processed.
		// If not provided, all pages will be processed.
		// Should be an array of size 2, with the first element being the start page and the second element being the end page.
		PageNumbers *[]int `json:"pageNumbers,omitempty"`
	} `json:"unstructuredDataProcessingConfig"`

	// VectorizationConfig Configuration for vectorization in a workflow.
	VectorizationConfig VectorizationConfigCreation `json:"vectorizationConfig"`
}

// CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigChunkingStrategyStrategyType defines model for CreateUnstructuredWorkflowRequest.UnstructuredDataProcessingConfig.ChunkingStrategy.StrategyType.
type CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigChunkingStrategyStrategyType string

// CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigExclusions defines model for CreateUnstructuredWorkflowRequest.UnstructuredDataProcessingConfig.Exclusions.
type CreateUnstructuredWorkflowRequestUnstructuredDataProcessingConfigExclusions string

// CreateUserRequest defines model for CreateUserRequest.
type CreateUserRequest struct {
	// Email Email of the user.
	Email Email `json:"email"`

	// Name The name of the user.
	Name              *string             `json:"name,omitempty"`
	OrganizationRoles []OrganizationRoles `json:"organizationRoles"`
	Resources         *[]Resource         `json:"resources,omitempty"`
}

// CreateUserResponse defines model for CreateUserResponse.
type CreateUserResponse struct {
	// Id The UUID of the user created.
	Id *string `json:"id,omitempty"`
}

// CreateVPCEndpointCommandRequest defines model for CreateVPCEndpointCommandRequest.
type CreateVPCEndpointCommandRequest struct {
	SubnetIDs []string `json:"subnetIDs"`

	// VpcID The ID of your virtual network
	VpcID string `json:"vpcID"`
}

// CreateVectorizationWorkflowRequest defines model for CreateVectorizationWorkflowRequest.
type CreateVectorizationWorkflowRequest struct {
	TargetCouchbaseKeyspace CouchbaseKeyspace `json:"targetCouchbaseKeyspace"`

	// VectorizationConfig Configuration for vectorization in a workflow.
	VectorizationConfig VectorizationConfigCreation `json:"vectorizationConfig"`
}

// CreateWorkflowRequest defines model for CreateWorkflowRequest.
type CreateWorkflowRequest struct {
	Configuration CreateWorkflowRequest_Configuration `json:"configuration"`

	// Name The name of the workflow.
	Name string `json:"name"`

	// Type The type of workflow.
	Type CreateWorkflowRequestType `json:"type"`
}

// CreateWorkflowRequest_Configuration defines model for CreateWorkflowRequest.Configuration.
type CreateWorkflowRequest_Configuration struct {
	union json.RawMessage
}

// CreateWorkflowRequestType The type of workflow.
type CreateWorkflowRequestType string

// CreateWorkflowResponse defines model for CreateWorkflowResponse.
type CreateWorkflowResponse struct {
	// Id The ID of the workflow created.
	Id string `json:"id"`
}

// CreateWorkflowRunResponse defines model for CreateWorkflowRunResponse.
type CreateWorkflowRunResponse struct {
	// Id The ID of the workflow run created.
	Id string `json:"id"`
}

// CurrentColumnarState defines model for CurrentColumnarState.
type CurrentColumnarState string

// CurrentState defines model for CurrentState.
type CurrentState string

// Cursor defines model for Cursor.
type Cursor struct {
	Hrefs Hrefs `json:"hrefs"`
	Pages Pages `json:"pages"`
}

// Days defines model for Days.
type Days struct {
	// Day Day of the week for scheduling on/off.
	// - The days of the week should be in proper sequence starting from Monday and ending with Sunday.
	// - The On/Off schedule requires 7 days for the schedule, one for each day of the week. There cannot be more or less than 7 days in the schedule.
	// - Clusters cannot be scheduled to be off for the entire day for every day of the week.
	Day DaysDay `json:"day"`

	// From OnTimeBoundary corresponds to "from" and "to" time boundaries for when the cluster needs to be in the turned on (healthy) state on a day with "custom" scheduling timings.
	// The time boundary should be according to the following rules:
	//   - If the schedule is a non-custom day - with state `on` or `off`, it cannot contain a time boundary.
	//   - If the schedule is a `custom` day -
	//       - It should contain the `from` time boundary. If the `to` time boundary is not specified then the default value of 0 hour 0 minute is set and the cluster will be turned on for the entire day from the time set in `from` time boundary.
	//       - Time boundary should have a valid `hour` value. The valid hour values are from 0 to 23 inclusive.
	//       - Time boundary should have a valid `minute` value. The valid minute values are 0 and 30.
	//       - The `from` time boundary should not be later than the `to` time boundary.
	//       - If the `hour` and `minute` values are not provided for the time boundaries, it is set to a default value of 0 for both. (0 hour 0 minute)
	From *OnTimeBoundary `json:"from,omitempty"`

	// State Cluster state (on, off, or custom).
	// - On state turns the cluster on (healthy state) for the whole day.
	// - Off state turns the cluster off for the whole day.
	// - Custom state should be used for the days when a cluster needs to be in the turned on (healthy) state during the specified time window instead of all day.
	State DaysState `json:"state"`

	// To OnTimeBoundary corresponds to "from" and "to" time boundaries for when the cluster needs to be in the turned on (healthy) state on a day with "custom" scheduling timings.
	// The time boundary should be according to the following rules:
	//   - If the schedule is a non-custom day - with state `on` or `off`, it cannot contain a time boundary.
	//   - If the schedule is a `custom` day -
	//       - It should contain the `from` time boundary. If the `to` time boundary is not specified then the default value of 0 hour 0 minute is set and the cluster will be turned on for the entire day from the time set in `from` time boundary.
	//       - Time boundary should have a valid `hour` value. The valid hour values are from 0 to 23 inclusive.
	//       - Time boundary should have a valid `minute` value. The valid minute values are 0 and 30.
	//       - The `from` time boundary should not be later than the `to` time boundary.
	//       - If the `hour` and `minute` values are not provided for the time boundaries, it is set to a default value of 0 for both. (0 hour 0 minute)
	To *OnTimeBoundary `json:"to,omitempty"`
}

// DaysDay Day of the week for scheduling on/off.
// - The days of the week should be in proper sequence starting from Monday and ending with Sunday.
// - The On/Off schedule requires 7 days for the schedule, one for each day of the week. There cannot be more or less than 7 days in the schedule.
// - Clusters cannot be scheduled to be off for the entire day for every day of the week.
type DaysDay string

// DaysState Cluster state (on, off, or custom).
// - On state turns the cluster on (healthy state) for the whole day.
// - Off state turns the cluster off for the whole day.
// - Custom state should be used for the days when a cluster needs to be in the turned on (healthy) state during the specified time window instead of all day.
type DaysState string

// DisabledUserRole defines model for DisabledUserRole.
type DisabledUserRole struct {
	// Domain Domain of the user/role. Can be used to filter logs by domain. Example values:
	//   - sgw
	//   - cbs
	Domain string `json:"domain"`

	// Name Name of the user/role
	Name string `json:"name"`
}

// DisabledUserRoles defines model for DisabledUserRoles.
type DisabledUserRoles = []DisabledUserRole

// DiskAWS defines model for DiskAWS.
type DiskAWS struct {
	// Iops Please refer to documentation for supported IOPS.
	Iops int `json:"iops"`

	// Storage Storage in GB. See documentation for supported storage.
	Storage int `json:"storage"`

	// Type Type of disk. Please choose from the given list for AWS cloud provider.
	Type DiskAWSType `json:"type"`
}

// DiskAWSType Type of disk. Please choose from the given list for AWS cloud provider.
type DiskAWSType string

// DiskAzure defines model for DiskAzure.
type DiskAzure struct {
	// AutoExpansion Determine if disk storage should automatically expand. Defaults to "false" if not specified.
	AutoExpansion *bool `json:"autoExpansion,omitempty"`

	// Iops Only required for Ultra Disk types. Not used in other storage types. See [IOPS Defaults](https://docs.couchbase.com/cloud/clusters/scale-database.html#IOPS-Defaults) for a list of supported IOPS values.
	Iops *int `json:"iops,omitempty"`

	// Storage Storage in GB. Only required for Ultra Disk types. Not used in other storage types.
	Storage *DiskAzureStorage `json:"storage,omitempty"`

	// Type Type of disk. Please choose from the given list for Azure cloud provider.
	Type DiskAzureType `json:"type"`
}

// DiskAzureStorage Storage in GB. Only required for Ultra Disk types. Not used in other storage types.
type DiskAzureStorage int

// DiskAzureType Type of disk. Please choose from the given list for Azure cloud provider.
type DiskAzureType string

// DiskGCP defines model for DiskGCP.
type DiskGCP struct {
	// Storage Storage in GB. Please refer to documentation for supported storage.
	Storage int `json:"storage"`

	// Type Type of disk. Please choose from the given list for GCP cloud provider.
	Type DiskGCPType `json:"type"`
}

// DiskGCPType Type of disk. Please choose from the given list for GCP cloud provider.
type DiskGCPType string

// DurabilityLevel This is the minimum level at which all writes to the bucket must occur.
//
//	The options for Durability level are as follows, according to the bucket type.
//
//	- For a Couchbase bucket:
//
//	  1. None
//
//	  2. Replicate to Majority
//
//	  3. Majority and Persist to Active
//
//	  4. Persist to Majority
//
//	- For an Ephemeral bucket:
//
//	  1. None
//
//	  2. Replicate to Majority
//
//	To learn more, see [Create a Bucket](https://docs.couchbase.com/cloud/clusters/data-service/manage-buckets.html#add-bucket).
type DurabilityLevel string

// EditCloudSnapshotBackupRetentionRequest defines model for EditCloudSnapshotBackupRetentionRequest.
type EditCloudSnapshotBackupRetentionRequest struct {
	// Retention Represents interval in hours to retain the backup.
	Retention *int `json:"retention,omitempty"`
}

// EditColumnarAnalyticsBackupRetentionRequest defines model for EditColumnarAnalyticsBackupRetentionRequest.
type EditColumnarAnalyticsBackupRetentionRequest struct {
	// Retention Represents interval in hours to retain the backup.
	Retention int `json:"retention"`
}

// Email Email of the user.
type Email = string

// Error defines model for Error.
type Error struct {
	Code           int    `json:"code"`
	Hint           string `json:"hint"`
	HttpStatusCode int    `json:"httpStatusCode"`
	Message        string `json:"message"`
}

// EvictionPolicy The policy which Capella adopts to prevent data loss due to memory exhaustion.
// This may be also known as Ejection Policy in the Couchbase documentation.
//
// - For Couchbase bucket, Eviction Policy is `fullEviction` by default.
//
// - For Ephemeral buckets, Eviction Policy is a required field, and should be one of the following:
//
//  1. noEviction
//
//  2. nruEviction
//
//     To learn more, see [Ejection Policy](https://docs.couchbase.com/server/current/rest-api/rest-bucket-create.html#evictionpolicy).
type EvictionPolicy string

// ExternalModel defines model for ExternalModel.
type ExternalModel struct {
	External struct {
		// ModelName The name of the external embedding model.
		ModelName         ExternalModelExternalModelName `json:"modelName"`
		OpenAiIntegration IntegrationConfig              `json:"openAiIntegration"`
	} `json:"external"`
}

// ExternalModelExternalModelName The name of the external embedding model.
type ExternalModelExternalModelName string

// ExternalToken The bearer authentication token is a third-party token that you set for the alert notifications sent through the webhook integration.
type ExternalToken = string

// GCP defines model for GCP.
type GCP struct {
	// GCPConfig GCP config data required to establish a VPC peering relationship. Refer to the docs for other limitations to GCP VPC Peering - [ref](https://cloud.google.com/vpc/docs/vpc-peering).
	GCPConfig *GCPConfigData `json:"GCPConfig,omitempty"`

	// ProviderId The ID of the VPC peer on GCP.
	ProviderId *string `json:"providerId,omitempty"`
}

// GCPConfig defines model for GCPConfig.
type GCPConfig struct {
	// ResourceName The unique identifier for a GCP resource, specifying the project, location, key ring, and the key within Cloud KMS.
	ResourceName string `json:"resourceName"`
}

// GCPConfigData GCP config data required to establish a VPC peering relationship. Refer to the docs for other limitations to GCP VPC Peering - [ref](https://cloud.google.com/vpc/docs/vpc-peering).
type GCPConfigData struct {
	// Cidr The GCP VPC CIDR block of network in which your application runs. This cannot overlap with your Capella CIDR Block.
	Cidr string `json:"cidr"`

	// NetworkName The name of the network that you want to peer with.
	NetworkName string `json:"networkName"`

	// ProjectId The unique identifier for your GCP project.
	ProjectId string `json:"projectId"`

	// ServiceAccount ServiceAccount created or assigned on the external VPC project. GCP Service Account with below permissions
	// - DNS Admin
	// - Compute.NetworkAdmin
	// It should be in the form of an email that is shown under `gcloud iam service-accounts list` command.
	// [Reference](https://cloud.google.com/iam/docs/creating-managing-service-accounts#creating)
	ServiceAccount string `json:"serviceAccount"`
}

// GetAPIKey defines model for GetAPIKey.
type GetAPIKey struct {
	// AllowedCIDRs List of inbound CIDRs for the API key.
	// The system making a request must come from one of the allowed CIDRs.
	AllowedCIDRs APIKeyAllowedCIDRs `json:"allowedCIDRs"`
	Audit        CouchbaseAuditData `json:"audit"`

	// Description Description for the API key.
	Description APIKeyDescription `json:"description"`

	// Expiry Expiry of the API key in number of days.
	// If set to -1, the token will not expire.
	Expiry APIKeyExpiry `json:"expiry"`

	// Id The id is a unique identifier for an apiKey.
	Id APIKeyId `json:"id"`

	// Name Name of the API key.
	Name              APIKeyName                `json:"name"`
	OrganizationRoles []APIKeyOrganizationRoles `json:"organizationRoles"`

	// Resources Resources are the resource level permissions associated with the API key.
	//
	// To learn more about Organization Roles, see [Organization Roles](https://docs.couchbase.com/cloud/organizations/organization-user-roles.html).
	Resources APIKeyResources `json:"resources"`
}

// GetAPIKeys defines model for GetAPIKeys.
type GetAPIKeys struct {
	Cursor Cursor      `json:"cursor"`
	Data   []GetAPIKey `json:"data"`
}

// GetAlertResponse defines model for GetAlertResponse.
type GetAlertResponse struct {
	Audit  CouchbaseAuditData `json:"audit"`
	Config ResponseConfig     `json:"config"`

	// ConfigKey ConfigKey is the key that was used to store the alert integration config and secrets.
	ConfigKey string `json:"configKey"`

	// Enabled Enables or disables the integration. Only 1 integration can be active at any time.
	Enabled bool `json:"enabled"`

	// Id The ID of the alert integration created.
	Id openapi_types.UUID `json:"id"`

	// Kind Type of alert integration, currently supports only 'webhook'.
	Kind GetAlertResponseKind `json:"kind"`

	// Name Name of the alert integration (up to 1024 characters).
	Name string `json:"name"`

	// ProjectId The project ID to which the alert integration belongs to.
	ProjectId *openapi_types.UUID `json:"projectId,omitempty"`

	// Status Status is either healthy or unhealthy showing if the integration is functional or not.
	Status string `json:"status"`

	// TenantId The tenant ID to which the alert integration belongs to.
	TenantId openapi_types.UUID `json:"tenantId"`
}

// GetAlertResponseKind Type of alert integration, currently supports only 'webhook'.
type GetAlertResponseKind string

// GetAlertsResponse defines model for GetAlertsResponse.
type GetAlertsResponse struct {
	Cursor Cursor             `json:"cursor"`
	Data   []GetAlertResponse `json:"data"`
}

// GetAllowedCidrsResponse defines model for GetAllowedCidrsResponse.
type GetAllowedCidrsResponse struct {
	Cursor Cursor        `json:"cursor"`
	Data   []AllowedCidr `json:"data"`
}

// GetAppEndpointAuditLogResponse defines model for GetAppEndpointAuditLogResponse.
type GetAppEndpointAuditLogResponse struct {
	// AuditEnabled Determines whether audit logging is enabled
	AuditEnabled    *bool              `json:"auditEnabled,omitempty"`
	DisabledRoles   *DisabledUserRoles `json:"disabledRoles,omitempty"`
	DisabledUsers   *DisabledUserRoles `json:"disabledUsers,omitempty"`
	EnabledEventIds *[]struct {
		// Id ID of the enabled event
		Id *int `json:"id,omitempty"`
	} `json:"enabledEventIds,omitempty"`
}

// GetAppEndpointResponse defines model for GetAppEndpointResponse.
type GetAppEndpointResponse struct {
	// AdminURL A URL for the admin API used for the administration of App Endpoints. For more information, read the [Capella App Services Admin API Reference](https://docs.couchbase.com/cloud/app-services/references/rest-api-introduction.html#:~:text=Capella%20App%20Services%20Admin%20API%20Reference)
	AdminURL *string `json:"adminURL,omitempty"`

	// Bucket The Capella Cluster backing bucket for the App Endpoint.
	Bucket string      `json:"bucket"`
	Cors   *CORSConfig `json:"cors,omitempty"`

	// DeltaSyncEnabled Enable or disable delta sync
	DeltaSyncEnabled *bool `json:"deltaSyncEnabled,omitempty"`

	// IsRequireResync Indicates whether the App Endpoint requires resyncing.
	IsRequireResync *bool `json:"isRequireResync,omitempty"`

	// MetricsURL A URL for the metrics API used for monitoring App Services performance metrics. For more information, read the [Capella App Services Metrics API Reference](https://docs.couchbase.com/cloud/app-services/references/rest_api_metric.html)
	MetricsURL *string `json:"metricsURL,omitempty"`

	// Name App Endpoint name.
	Name string `json:"name"`

	// Oidc OpenID Connect provider configuration.
	Oidc *[]OIDCProvider `json:"oidc,omitempty"`

	// PublicURL A URL for the public API used for access to functions for data access and manipulation. For more information, read the [Capella App Services Public API Reference](https://docs.couchbase.com/cloud/app-services/references/rest_api_public.html)
	PublicURL *string `json:"publicURL,omitempty"`

	// RequireResync Scopes and collections that require resyncing.
	RequireResync *map[string][]string `json:"requireResync,omitempty"`
	Scopes        *ScopesConfig        `json:"scopes,omitempty"`

	// State App Endpoint state.
	State *string `json:"state,omitempty"`

	// UserXattrKey The key of the user-extended attributes (xattr) that will be accessible from the Access control and validation function. If left empty, the feature will be disabled.
	UserXattrKey *string `json:"userXattrKey,omitempty"`
}

// GetAppServiceAllowedCidrsResponse defines model for GetAppServiceAllowedCidrsResponse.
type GetAppServiceAllowedCidrsResponse struct {
	Cursor Cursor                  `json:"cursor"`
	Data   []AppServiceAllowedCidr `json:"data"`
}

// GetAppServicePrivateEndpointStateResponse defines model for GetAppServicePrivateEndpointStateResponse.
type GetAppServicePrivateEndpointStateResponse struct {
	// State The status of the Private Endpoint service.
	State *GetAppServicePrivateEndpointStateResponseState `json:"state,omitempty"`

	// TargetState The target state of the Private Endpoint service. This is the desired end state of the service. The possible values are enabled and disabled.
	TargetState *GetAppServicePrivateEndpointStateResponseTargetState `json:"targetState,omitempty"`
}

// GetAppServicePrivateEndpointStateResponseState The status of the Private Endpoint service.
type GetAppServicePrivateEndpointStateResponseState string

// GetAppServicePrivateEndpointStateResponseTargetState The target state of the Private Endpoint service. This is the desired end state of the service. The possible values are enabled and disabled.
type GetAppServicePrivateEndpointStateResponseTargetState string

// GetAppServiceResponse defines model for GetAppServiceResponse.
type GetAppServiceResponse struct {
	Audit CouchbaseAuditData `json:"audit"`

	// CloudProvider Provider is the cloud service provider for the App Service.
	CloudProvider string `json:"cloudProvider"`

	// ClusterId The ID of the cluster linked to the App Service.
	ClusterId openapi_types.UUID `json:"clusterId"`

	// Compute The CPU and RAM configuration of the App Service. The supported combinations are:
	// | CPU (cores)| RAM  (GB)   |
	// | --------   |   -------   |
	// | 2          | 4           |
	// | 4          | 8           |
	// | 8          | 16          |
	// | 16         | 32          |
	// | 36         | 72          |
	Compute      AppServiceCompute `json:"compute"`
	CurrentState AppServiceStates  `json:"currentState"`

	// Description Description of the App Service (up to 1024 characters).
	Description string `json:"description"`

	// Id The ID of the App Service created.
	Id openapi_types.UUID `json:"id"`

	// Name Name of the App Service (up to 256 characters).
	Name string `json:"name"`

	// Nodes Number of nodes configured for the App Service.
	Nodes int `json:"nodes"`

	// Plan Plan type, either 'Basic', 'Developer Pro', or 'Enterprise'.
	// Plan type allowed for singleNode cluster is either 'Basic', or 'Developer Pro'.
	// In case of 'Basic' plan timezone field value is ignored.
	Plan SupportPlan `json:"plan"`

	// Version The version of the App Service server. If left empty, it will be defaulted to the latest available version.
	Version string `json:"version"`
}

// GetAppServicesResponse defines model for GetAppServicesResponse.
type GetAppServicesResponse struct {
	Cursor Cursor                  `json:"cursor"`
	Data   []GetAppServiceResponse `json:"data"`
}

// GetAuditExportDocResponse defines model for GetAuditExportDocResponse.
type GetAuditExportDocResponse struct {
	AppServiceId    *string             `json:"appServiceId"`
	Audit           *CouchbaseAuditData `json:"audit,omitempty"`
	ClusterId       *string             `json:"clusterId"`
	DownloadExpires *time.Time          `json:"download_expires"`
	DownloadId      *string             `json:"download_id"`
	Id              *string             `json:"id"`
	Status          *string             `json:"status"`
	TenantId        *string             `json:"tenantId"`
}

// GetAuditLogEventsResponse defines model for GetAuditLogEventsResponse.
type GetAuditLogEventsResponse struct {
	Events []AuditFilterableEvent `json:"events"`
}

// GetAuditLogStreamingResponse defines model for GetAuditLogStreamingResponse.
type GetAuditLogStreamingResponse struct {
	// DisabledAppEndpoints List of App Endpoints to be excluded from audit log streaming.
	DisabledAppEndpoints *[]string `json:"disabledAppEndpoints,omitempty"`

	// LogStreamingState The current status of audit log streaming
	LogStreamingState *string `json:"logStreamingState,omitempty"`

	// OutputType The type of output for the audit log streaming
	OutputType *string `json:"outputType,omitempty"`

	// StreamingEnabled Determines whether audit log streaming is enabled or not.
	StreamingEnabled *bool `json:"streamingEnabled,omitempty"`
}

// GetAzureVNetPeeringCommandRequest defines model for GetAzureVNetPeeringCommandRequest.
type GetAzureVNetPeeringCommandRequest struct {
	// ResourceGroup The resource group name holding the resource you’re connecting with Capella.
	ResourceGroup string `json:"resourceGroup"`

	// SubscriptionId Subscription ID is a GUID that uniquely identifies your subscription to use Azure services. To find your subscription ID, see [Find your Azure subscription](https://learn.microsoft.com/en-us/azure/azure-portal/get-subscription-tenant-id#find-your-azure-subscription).
	SubscriptionId string `json:"subscriptionId"`

	// TenantId The Azure tenant ID. To find your tenant ID, see [How to find your Azure Active Directory tenant ID](https://learn.microsoft.com/en-us/entra/fundamentals/how-to-find-tenant).
	TenantId string `json:"tenantId"`

	// VnetId The VNet ID is the name of the virtual network in Azure.
	VnetId string `json:"vnetId"`

	// VnetPeeringServicePrincipal The enterprise application object ID for the Capella service principal. You can find the enterprise application object ID in Azure by selecting Azure Active Directory -> Enterprise applications. Next, select the application name, the object ID is in the Object ID box.
	VnetPeeringServicePrincipal string `json:"vnetPeeringServicePrincipal"`
}

// GetAzureVNetPeeringCommandResponse defines model for GetAzureVNetPeeringCommandResponse.
type GetAzureVNetPeeringCommandResponse struct {
	// Command The command to be run by the customer in is their external azure account in order to grant the service principal a network contributor role that is required for VNET peering.
	Command string `json:"command"`
}

// GetBackupByIDResponse defines model for GetBackupByIDResponse.
type GetBackupByIDResponse struct {
	// BucketID The ID of the bucket.This is the base64 encoding of the bucket name.
	BucketID string `json:"bucketID"`

	// BucketName The name of the bucket for which the backup belongs to.
	BucketName string `json:"bucketName"`

	// ClusterID The ID of the cluster.
	ClusterID openapi_types.UUID `json:"clusterID"`

	// CycleID The ID of the cycle this backup belongs to.
	CycleID string `json:"cycleID"`

	// Date The RFC3339 timestamp representing the time at which backup was created.
	Date *time.Time `json:"date,omitempty"`

	// ElapsedTimeInSeconds The amount of seconds that have elapsed between the creation and completion of the backup.
	ElapsedTimeInSeconds int `json:"elapsedTimeInSeconds"`

	// Id The ID of the backup created.
	Id openapi_types.UUID `json:"id"`

	// Method The mechanism of the backup.
	// 1. Incremental backups include the data that has changed since the last scheduled backup.
	// 2. Full backup includes all bucket data from the time the backup was created.
	Method Method `json:"method"`

	// ProjectID The ID of the project.
	ProjectID openapi_types.UUID `json:"projectID"`

	// Provider The cloud provider where the cluster is hosted.
	Provider string `json:"provider"`

	// RestoreBefore The RFC3339 timestamp representing the time at which backup will expire.
	RestoreBefore *time.Time `json:"restoreBefore,omitempty"`

	// ScheduleInfo Represents the schedule information of the backup.
	ScheduleInfo ScheduleInfo `json:"scheduleInfo"`

	// Source The way a backup job was initiated.
	// 1. Manual represents a manually triggered backup job or on-demand.
	// 2. Scheduled represents a backup job created from a schedule.
	Source Source `json:"source"`

	// Stats Represents various backup level data that couchbase provides. To learn more, see [Backup Summary](https://docs.couchbase.com/cloud/clusters/manage-backup.html#backup-summary)
	Stats BackupStats `json:"stats"`

	// Status The status of the backup.
	Status Status `json:"status"`

	// TenantID The ID of the organization.
	TenantID openapi_types.UUID `json:"tenantID"`
}

// GetBackupResponse defines model for GetBackupResponse.
type GetBackupResponse struct {
	// BucketDownloadsCount The number of downloadable backups the bucket this backup belongs to has.
	BucketDownloadsCount *int `json:"bucketDownloadsCount,omitempty"`

	// BucketID The ID of the bucket.This is the base64 encoding of the bucket name.
	BucketID string `json:"bucketID"`

	// BucketName The name of the bucket for which the backup belongs to.
	BucketName string `json:"bucketName"`

	// ClusterID The ID of the cluster.
	ClusterID openapi_types.UUID `json:"clusterID"`

	// CycleID The ID of the cycle this backup belongs to.
	CycleID string `json:"cycleID"`

	// Date The RFC3339 timestamp representing the time at which backup was created.
	Date *time.Time `json:"date,omitempty"`

	// ElapsedTimeInSeconds The amount of seconds that have elapsed between the creation and completion of the backup.
	ElapsedTimeInSeconds int `json:"elapsedTimeInSeconds"`

	// Id The ID of the backup created.
	Id openapi_types.UUID `json:"id"`

	// Method The mechanism of the backup.
	// 1. Incremental backups include the data that has changed since the last scheduled backup.
	// 2. Full backup includes all bucket data from the time the backup was created.
	Method Method `json:"method"`

	// ProjectID The ID of the project.
	ProjectID openapi_types.UUID `json:"projectID"`

	// Provider The cloud provider where the cluster is hosted.
	Provider string `json:"provider"`

	// RestoreBefore The RFC3339 timestamp representing the time at which backup will expire.
	RestoreBefore *time.Time `json:"restoreBefore,omitempty"`

	// ScheduleInfo Represents the schedule information of the backup.
	ScheduleInfo ScheduleInfo `json:"scheduleInfo"`

	// Source The way a backup job was initiated.
	// 1. Manual represents a manually triggered backup job or on-demand.
	// 2. Scheduled represents a backup job created from a schedule.
	Source Source `json:"source"`

	// Stats Represents various backup level data that couchbase provides. To learn more, see [Backup Summary](https://docs.couchbase.com/cloud/clusters/manage-backup.html#backup-summary)
	Stats BackupStats `json:"stats"`

	// Status The status of the backup.
	Status Status `json:"status"`

	// TenantID The ID of the organization.
	TenantID openapi_types.UUID `json:"tenantID"`
}

// GetBackupsResponse defines model for GetBackupsResponse.
type GetBackupsResponse struct {
	Data []GetBackupResponse `json:"data"`
}

// GetBucketResponse defines model for GetBucketResponse.
type GetBucketResponse struct {
	// BucketConflictResolution The means in which conflicts are resolved during replication. This field may be referred to as conflictResolution in the Couchbase documentation, and seqno and lww may be referred to as sequence Number and Timestamp respectively.
	// To learn more, see [Conflict Resolution](https://docs.couchbase.com/cloud/clusters/xdcr/xdcr.html#conflict-resolution).
	BucketConflictResolution string `json:"bucketConflictResolution"`

	// DurabilityLevel This is the minimum level at which all writes to the Couchbase bucket must occur.
	//
	// The options for Durability level are as follows, according to the bucket type.
	//
	// - For a Couchbase bucket:
	//
	//   1. None
	//
	//   2. Replicate to Majority
	//
	//   3. Majority and Persist to Active
	//
	//   4. Persist to Majority
	//
	// - For an Ephemeral bucket:
	//
	//   1. None
	//
	//   2. Replicate to Majority
	//
	//  To learn more, see [Create a Bucket](https://docs.couchbase.com/cloud/clusters/data-service/manage-buckets.html#add-bucket).
	DurabilityLevel string `json:"durabilityLevel"`

	// EvictionPolicy The policy which Capella adopts to prevent data loss due to memory exhaustion.
	// This may be also known as Ejection Policy in the Couchbase documentation.
	//
	// - For Couchbase bucket, Eviction Policy is `fullEviction` by default.
	//
	// - For Ephemeral buckets, Eviction Policy is a required field, and should be one of the following:
	//
	//    1. noEviction
	//
	//    2. nruEviction
	//
	//   To learn more, see [Ejection Policy](https://docs.couchbase.com/server/current/rest-api/rest-bucket-create.html#evictionpolicy).
	EvictionPolicy EvictionPolicy `json:"evictionPolicy"`

	// Flush Replaced by flushEnabled.
	//
	// Determines whether bucket flush is enabled. Set property to true to be able to delete all items in this bucket using the /flush endpoint. Disable property to avoid inadvertent data loss by calling the  the /flush endpoint .
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Flush *bool `json:"flush,omitempty"`

	// FlushEnabled Determines whether bucket flush is enabled. Set flushEnabled to true to be able to delete all items in this bucket using the /flush endpoint. Disable flushEnabled to avoid inadvertent data loss by calling the /flush endpoint .
	FlushEnabled *bool `json:"flushEnabled,omitempty"`

	// Id The ID of the bucket. This is the base64 encoding of the bucket name.
	Id string `json:"id"`

	// MemoryAllocationInMb The amount of memory to allocate for the bucket memory in MiB. The maximum limit is dependent on the allocation of the KV service.For example, 80% of the allocation.
	MemoryAllocationInMb int `json:"memoryAllocationInMb"`

	// Name Name of the bucket.
	Name string `json:"name"`

	// Priority Priority of the bucket.
	//
	// - Specify relative bucket priority so that buckets will be recovered in the order specified during failover.
	//
	// - Bucket ranking/priority is only available in Couchbase Server 7.6 and above
	//
	// - Default bucket priority is 0 and can be set to a value between 0 and 1000. 1000 is the highest priority and 0 is the lowest.
	Priority *BucketPriority `json:"priority,omitempty"`

	// Replicas The number of replicas for the bucket.
	// To learn more, see [Create a Bucket](https://docs.couchbase.com/cloud/clusters/data-service/manage-buckets.html#add-bucket).
	Replicas int   `json:"replicas"`
	Stats    Stats `json:"stats"`

	// StorageBackend Type of the bucket. If selected Ephemeral, it is not eligible for imports or App Endpoints creation.
	// The options may also be referred to as Memory and Disk (Couchbase), Memory Only (Ephemeral) in the Couchbase documentation.
	// To learn more, see [Create a Bucket](https://docs.couchbase.com/cloud/clusters/data-service/manage-buckets.html#add-bucket).
	StorageBackend string `json:"storageBackend"`

	// TimeToLiveInSeconds Specifies the time to live (TTL) value in seconds. This is the maximum time to live for items in the bucket. If specified as 0, TTL is disabled. This is a non-negative value.
	TimeToLiveInSeconds int `json:"timeToLiveInSeconds"`

	// Type Type of the bucket. If selected Ephemeral, it is not eligible for imports or App Endpoints creation. The options may also be referred to as Memory and Disk (Couchbase), Memory Only (Ephemeral) in the Couchbase documentation.
	// To learn more, see [Create a Bucket](https://docs.couchbase.com/cloud/clusters/data-service/manage-buckets.html#add-bucket).
	Type string `json:"type"`

	// Vbuckets For Couchbase Server below 8.0, this is always 1024.
	//
	// For Couchbase Server 8.0 and above, this can be either 128 or 1024 depending on the storage backend.
	Vbuckets *GetBucketResponseVbuckets `json:"vbuckets,omitempty"`
}

// GetBucketResponseVbuckets For Couchbase Server below 8.0, this is always 1024.
//
// For Couchbase Server 8.0 and above, this can be either 128 or 1024 depending on the storage backend.
type GetBucketResponseVbuckets int

// GetBucketsResponse defines model for GetBucketsResponse.
type GetBucketsResponse struct {
	Data []GetBucketResponse `json:"data"`
}

// GetCMEKHistoryMetadataListResponse defines model for GetCMEKHistoryMetadataListResponse.
type GetCMEKHistoryMetadataListResponse struct {
	Cursor Cursor                           `json:"cursor"`
	Data   []GetCMEKHistoryMetadataResponse `json:"data"`
}

// GetCMEKHistoryMetadataResponse defines model for GetCMEKHistoryMetadataResponse.
type GetCMEKHistoryMetadataResponse struct {
	// Active Whether the key is currently active or not.
	Active *bool `json:"active,omitempty"`

	// AssociatedAt The RFC3339 timestamp associated with when the resource was last modified.
	AssociatedAt *time.Time `json:"associatedAt,omitempty"`

	// AssociatedBy The user who last modified the key; this will be a UUID4 ID for
	// standard users and wilmal be a string such as "internal-support" for
	// internal Couchbase support users.
	AssociatedBy *string                                `json:"associatedBy,omitempty"`
	Config       *GetCMEKHistoryMetadataResponse_Config `json:"config,omitempty"`

	// Key The customer managed enycrption key name.
	Key *string `json:"key,omitempty"`
}

// GetCMEKHistoryMetadataResponse_Config defines model for GetCMEKHistoryMetadataResponse.Config.
type GetCMEKHistoryMetadataResponse_Config struct {
	union json.RawMessage
}

// GetCMEKMetadata defines model for GetCMEKMetadata.
type GetCMEKMetadata struct {
	Audit  CouchbaseAuditData     `json:"audit"`
	Config GetCMEKMetadata_Config `json:"config"`

	// Description Description of the Key (up to 1024 characters).
	Description string `json:"description"`

	// Id The ID of the key created.
	Id openapi_types.UUID `json:"id"`

	// Name Name of the key (up to 256 characters).
	Name string `json:"name"`
}

// GetCMEKMetadata_Config defines model for GetCMEKMetadata.Config.
type GetCMEKMetadata_Config struct {
	union json.RawMessage
}

// GetCMEKMetadataListResponse defines model for GetCMEKMetadataListResponse.
type GetCMEKMetadataListResponse struct {
	Cursor Cursor            `json:"cursor"`
	Data   []GetCMEKMetadata `json:"data"`
}

// GetCertificateResponse defines model for GetCertificateResponse.
type GetCertificateResponse struct {
	Certificate string `json:"certificate"`
}

// GetCloudSnapshotBackupResponse defines model for GetCloudSnapshotBackupResponse.
type GetCloudSnapshotBackupResponse struct {
	// AppService The version of any App Services which are associated with the cluster.
	AppService        *string                                 `json:"appService,omitempty"`
	ClusterId         *string                                 `json:"clusterId,omitempty"`
	Cmek              *[]ClusterCMEKConfig                    `json:"cmek,omitempty"`
	CreatedAt         *time.Time                              `json:"createdAt,omitempty"`
	CrossRegionCopies *[]CloudSnapshotBackupCrossRegionCopies `json:"crossRegionCopies,omitempty"`
	DatabaseSize      *uint64                                 `json:"databaseSize,omitempty"`
	Expiration        *time.Time                              `json:"expiration,omitempty"`
	Id                *string                                 `json:"id,omitempty"`
	Progress          *CloudSnapshotBackupProgress            `json:"progress,omitempty"`
	ProjectId         *string                                 `json:"projectId,omitempty"`
	Retention         *int                                    `json:"retention,omitempty"`
	Server            *CouchbaseServer                        `json:"server,omitempty"`
	TenantId          *string                                 `json:"tenantId,omitempty"`
	Type              *string                                 `json:"type,omitempty"`
}

// GetCloudSnapshotBackupScheduleResponse defines model for GetCloudSnapshotBackupScheduleResponse.
type GetCloudSnapshotBackupScheduleResponse struct {
	// CopyToRegions Represents the list of geographical regions where snapshot copies are stored in addition to the primary region.
	CopyToRegions *[]string `json:"copyToRegions,omitempty"`

	// Interval Represents the time interval.
	Interval *int `json:"interval,omitempty"`

	// Retention Represents interval in hours to retain the backup.
	Retention *int `json:"retention,omitempty"`

	// StartTime Represents the start time in ISO 8601 format.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// GetCloudSnapshotRestoreResponse defines model for GetCloudSnapshotRestoreResponse.
type GetCloudSnapshotRestoreResponse struct {
	ClusterId  *string    `json:"clusterId,omitempty"`
	CreatedAt  *time.Time `json:"createdAt,omitempty"`
	Id         *string    `json:"id,omitempty"`
	ProjectId  *string    `json:"projectId,omitempty"`
	RestoreEnd *time.Time `json:"restoreEnd,omitempty"`
	RestoreTo  *string    `json:"restoreTo,omitempty"`
	Snapshot   *time.Time `json:"snapshot,omitempty"`
	Status     *string    `json:"status,omitempty"`
	TenantId   *string    `json:"tenantId,omitempty"`
}

// GetClusterAuditLogExportResponse defines model for GetClusterAuditLogExportResponse.
type GetClusterAuditLogExportResponse struct {
	// AuditLogDownloadURL Pre-signed URL to download cluster audit logs.
	AuditLogDownloadURL *string `json:"auditLogDownloadURL,omitempty"`

	// AuditLogExportId The export ID of the audit log export job.
	AuditLogExportId string `json:"auditLogExportId"`

	// CreatedAt The timestamp when the audit logs were exported.
	CreatedAt time.Time `json:"createdAt"`

	// End The timestamp of when audit logs should end.
	End time.Time `json:"end"`

	// Expiration The timestamp when the download link expires.
	Expiration *time.Time `json:"expiration,omitempty"`

	// Start The timestamp of when audit logs should start.
	Start time.Time `json:"start"`

	// Status Indicates status of audit log creation. When status is complete, the compressed file can be manually downloaded.
	Status GetClusterAuditLogExportResponseStatus `json:"status"`
}

// GetClusterAuditLogExportResponseStatus Indicates status of audit log creation. When status is complete, the compressed file can be manually downloaded.
type GetClusterAuditLogExportResponseStatus string

// GetClusterAuditLogExportsResponse defines model for GetClusterAuditLogExportsResponse.
type GetClusterAuditLogExportsResponse struct {
	Cursor Cursor                             `json:"cursor"`
	Data   []GetClusterAuditLogExportResponse `json:"data"`
}

// GetClusterAuditSettingsResponse defines model for GetClusterAuditSettingsResponse.
type GetClusterAuditSettingsResponse struct {
	// AuditEnabled Determines whether audit logging is enabled or not on the cluster.
	AuditEnabled bool `json:"auditEnabled"`

	// DisabledUsers List of users whose filterable events will not be logged.
	DisabledUsers AuditSettingsDisabledUsers `json:"disabledUsers"`

	// EnabledEventIDs List of enabled filterable audit events for the cluster.
	EnabledEventIDs []int32 `json:"enabledEventIDs"`
}

// GetClusterResponse defines model for GetClusterResponse.
type GetClusterResponse struct {
	// AppServiceId The ID of the linked App Service.
	AppServiceId *openapi_types.UUID `json:"appServiceId,omitempty"`
	Audit        CouchbaseAuditData  `json:"audit"`
	Availability Availability        `json:"availability"`

	// CloudProvider The cloud provider where the cluster will be hosted.
	// For information about providers and supported regions, see:
	//
	// - [Amazon Web Services](https://docs.couchbase.com/cloud/reference/aws.html)
	//
	// - [Google Cloud Platform](https://docs.couchbase.com/cloud/reference/gcp.html)
	//
	// - [Microsoft Azure](https://docs.couchbase.com/cloud/reference/azure.html)
	CloudProvider CloudProvider `json:"cloudProvider"`

	// CmekId The ID of the CMEK Key.
	CmekId *string `json:"cmekId,omitempty"`

	// ConfigurationType - Multi-node databases are best for deployments that require high availability. If your app requires high performance and high availability, choose the Multi-node option.
	// - Single-node databases have resource limitations that make them a good choice for learning, prototyping, and non-production uses. They have limited availability.
	// - Single-node databases should contain only 1 node and 1 Service Group. Adding number of nodes or service groups > 1 is not allowed for such databases.
	// - By default the configurationType is multiNode.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	ConfigurationType ConfigurationType `json:"configurationType"`

	// ConnectionString ConnectionString specifies the Capella database endpoint for your client connection.
	ConnectionString string          `json:"connectionString"`
	CouchbaseServer  CouchbaseServer `json:"couchbaseServer"`
	CurrentState     CurrentState    `json:"currentState"`

	// Description Description of the cluster (up to 1024 characters).
	Description                string `json:"description"`
	EnablePrivateDNSResolution *bool  `json:"enablePrivateDNSResolution,omitempty"`

	// Id The ID of the cluster created.
	Id openapi_types.UUID `json:"id"`

	// Name Name of the cluster (up to 256 characters).
	Name          string            `json:"name"`
	ServiceGroups []ServiceGroup    `json:"serviceGroups"`
	Support       GetClusterSupport `json:"support"`
}

// GetClusterSupport defines model for GetClusterSupport.
type GetClusterSupport struct {
	// Plan Plan type, either 'Basic', 'Developer Pro', or 'Enterprise'.
	// Plan type allowed for singleNode cluster is either 'Basic', or 'Developer Pro'.
	// In case of 'Basic' plan timezone field value is ignored.
	Plan SupportPlan `json:"plan"`

	// Timezone The standard timezone for the cluster. Should be the TZ identifier.
	Timezone SupportTimezone `json:"timezone"`
}

// GetClustersResponse defines model for GetClustersResponse.
type GetClustersResponse struct {
	Cursor Cursor               `json:"cursor"`
	Data   []GetClusterResponse `json:"data"`
}

// GetCollectionResponse defines model for GetCollectionResponse.
type GetCollectionResponse struct {
	// MaxTTL Max TTL of the collection.
	MaxTTL *int `json:"maxTTL,omitempty"`

	// Name Name of the collection.
	Name *string `json:"name,omitempty"`
}

// GetCollectionsResponse defines model for GetCollectionsResponse.
type GetCollectionsResponse struct {
	Data []GetCollectionResponse `json:"data"`
}

// GetColumnarAnalyticsBackupResponse defines model for GetColumnarAnalyticsBackupResponse.
type GetColumnarAnalyticsBackupResponse struct {
	// CreatedAt The time the backup was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// DatabaseSize The size of the database at the time of the backup.
	DatabaseSize *uint64 `json:"databaseSize,omitempty"`

	// Expiration The time the backup will expire.
	Expiration *time.Time `json:"expiration,omitempty"`

	// Id The unique identifier for the backup.
	Id       *string                          `json:"id,omitempty"`
	Progress *ColumnarAnalyticsBackupProgress `json:"progress,omitempty"`

	// Region The region where the backup is stored.
	Region *string `json:"region,omitempty"`

	// Retention The retention period for the backup.
	Retention *int `json:"retention,omitempty"`

	// Type The type of backup.
	Type *string `json:"type,omitempty"`
}

// GetColumnarAnalyticsBackupScheduleResponse defines model for GetColumnarAnalyticsBackupScheduleResponse.
type GetColumnarAnalyticsBackupScheduleResponse struct {
	// Interval Represents the time interval in hours.
	Interval *int `json:"interval,omitempty"`

	// Retention Represents interval in hours to retain the backup.
	Retention *int `json:"retention,omitempty"`

	// StartTime Represents the start time in ISO 8601 format.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// GetColumnarAnalyticsClusterResponse defines model for GetColumnarAnalyticsClusterResponse.
type GetColumnarAnalyticsClusterResponse struct {
	Availability Availability `json:"availability"`

	// CloudProvider Cloud provider selection is currently limited to Amazon Web Services (AWS).
	CloudProvider string `json:"cloudProvider"`

	// Compute Following are the supported compute combinations for CPU and RAM for different cloud providers.
	// To learn more, see [Amazon Web Services](https://docs.couchbase.com/cloud/reference/aws.html).
	Compute      Compute              `json:"compute"`
	CurrentState CurrentColumnarState `json:"currentState"`

	// Description The description of the analytics cluster.
	Description *string `json:"description,omitempty"`

	// Id UUID of the analytics cluster.
	Id openapi_types.UUID `json:"id"`

	// Name Name of the analytics cluster
	Name string `json:"name"`

	// Nodes The number of nodes.
	Nodes int `json:"nodes"`

	// Region Which region should the analytics cluster be deployed in.
	Region  string          `json:"region"`
	Support ColumnarSupport `json:"support"`
}

// GetColumnarAnalyticsClustersResponse defines model for GetColumnarAnalyticsClustersResponse.
type GetColumnarAnalyticsClustersResponse struct {
	Cursor Cursor                                `json:"cursor"`
	Data   []GetColumnarAnalyticsClusterResponse `json:"data"`
}

// GetColumnarAnalyticsRestoreResponse defines model for GetColumnarAnalyticsRestoreResponse.
type GetColumnarAnalyticsRestoreResponse struct {
	// CreatedAt The time the restore was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id The unique identifier for the restore.
	Id *string `json:"id,omitempty"`

	// RestoreEnd The time the restore ended.
	RestoreEnd *time.Time `json:"restoreEnd,omitempty"`

	// RestoreTo The destination of the restore.
	RestoreTo *string `json:"restoreTo,omitempty"`

	// Snapshot The snapshot used for the restore.
	Snapshot *time.Time `json:"snapshot,omitempty"`

	// Status The status of the restore.
	Status *string `json:"status,omitempty"`
}

// GetConnectionStringResponse Response for get connection string request.
type GetConnectionStringResponse struct {
	ConnectionString *string `json:"connectionString,omitempty"`
}

// GetCycleResponse defines model for GetCycleResponse.
type GetCycleResponse struct {
	// CreatedAt The RFC3339 timestamp representing the time at which first backup was created in the cycle.
	CreatedAt time.Time `json:"createdAt"`

	// CycleID The ID of the cycle.
	CycleID openapi_types.UUID `json:"cycleID"`
}

// GetCyclesResponse defines model for GetCyclesResponse.
type GetCyclesResponse struct {
	Data []GetCycleResponse `json:"data"`
}

// GetDatabaseCredentialResponse defines model for GetDatabaseCredentialResponse.
type GetDatabaseCredentialResponse struct {
	Access []Access           `json:"access"`
	Audit  CouchbaseAuditData `json:"audit"`

	// Id The ID of the database credential created.
	Id openapi_types.UUID `json:"id"`

	// Name Name of the database credential created (up to 256 characters).
	Name string `json:"name"`
}

// GetDatabaseCredentialsResponse defines model for GetDatabaseCredentialsResponse.
type GetDatabaseCredentialsResponse struct {
	Cursor Cursor                          `json:"cursor"`
	Data   []GetDatabaseCredentialResponse `json:"data"`
}

// GetEventResponse defines model for GetEventResponse.
type GetEventResponse struct {
	// AlertKey Populated on demand based on the Event.Key and select labels in KV.
	AlertKey *string `json:"alertKey,omitempty"`

	// AppServiceId SyncGatewayID this Event refers to.
	AppServiceId *openapi_types.UUID `json:"appServiceId,omitempty"`

	// AppServiceName Name of the sync gateway at the time of event emission.
	AppServiceName *string `json:"appServiceName,omitempty"`

	// ClusterId ClusterID this Event refers to.
	ClusterId *openapi_types.UUID `json:"clusterId,omitempty"`

	// ClusterName Name of the cluster at the time of event emission.
	ClusterName *string `json:"clusterName,omitempty"`

	// Id UUID for this instance of an Event.
	Id openapi_types.UUID `json:"id"`

	// ImageURL Rendered chart image to display for an Alert Event.
	ImageURL *string `json:"imageURL,omitempty"`

	// IncidentIds Group events related to an alert incident.
	IncidentIds *[]openapi_types.UUID `json:"incidentIds,omitempty"`

	// Key Defines the specific kind of Event.
	Key string `json:"key"`

	// Kv Key-value pairs for additional event data.
	Kv *map[string]interface{} `json:"kv,omitempty"`

	// OccurrenceCount Number of times the alert has fired within this "incident".
	OccurrenceCount *int `json:"occurrenceCount,omitempty"`

	// ProjectId ProjectID this Event refers to.
	ProjectId *openapi_types.UUID `json:"projectId,omitempty"`

	// ProjectName Name of the project at the time of event emission.
	ProjectName *string `json:"projectName,omitempty"`

	// RequestId RequestID for an Event.
	RequestId *openapi_types.UUID `json:"requestId,omitempty"`

	// SessionId User that initiated the request for this Event.
	SessionId *openapi_types.UUID `json:"sessionId,omitempty"`

	// Severity Severity of the event.
	Severity string `json:"severity"`

	// Source Identifies the originator of the event.
	Source string `json:"source"`

	// Summary Metadata.SummaryTemplate rendered for this event.
	Summary *string `json:"summary,omitempty"`

	// Timestamp Time when the event was emitted.
	Timestamp time.Time `json:"timestamp"`

	// UserEmail Email of the associated user at the time of event emission.
	UserEmail *string `json:"userEmail,omitempty"`

	// UserId User id that initiated the request for this Event.
	UserId *string `json:"userId,omitempty"`

	// UserName Name of the associated user at the time of event emission.
	UserName *string `json:"userName,omitempty"`
}

// GetEventsResponse defines model for GetEventsResponse.
type GetEventsResponse struct {
	Cursor Cursor             `json:"cursor"`
	Data   []GetEventResponse `json:"data"`
}

// GetLanguageModelAPIKeyResponse defines model for GetLanguageModelAPIKeyResponse.
type GetLanguageModelAPIKeyResponse struct {
	// AllowedCIDRs List of IP addresses or CIDR blocks that are allowed to use this API key.
	AllowedCIDRs *[]string           `json:"allowedCIDRs,omitempty"`
	Audit        *CouchbaseAuditData `json:"audit,omitempty"`

	// Description Description of the Language Model API Key
	Description *string `json:"description,omitempty"`

	// Expiry Expiry of the API key in number of days. Maximum value is 365 days.
	Expiry *float32 `json:"expiry,omitempty"`

	// KeyId Unique identifier for the Language Model API key
	KeyId *string `json:"keyId,omitempty"`

	// Name Name of the Language Model API key
	Name *string `json:"name,omitempty"`
}

// GetLanguageModelResponse Response schema for getting a language model
type GetLanguageModelResponse struct {
	Model *struct {
		// Actions Actions that can be performed on the language model.
		Actions *Actions            `json:"actions,omitempty"`
		Audit   *CouchbaseAuditData `json:"audit,omitempty"`

		// CloudConfig The cloud configuration for the model.
		CloudConfig *CloudConfig `json:"cloudConfig,omitempty"`

		// Config Contains all the model information.
		Config *Config `json:"config,omitempty"`

		// ConnectionString The endpoint URL for the model.
		ConnectionString *string `json:"connectionString,omitempty"`

		// Id Unique identifier for the language model.
		Id *openapi_types.UUID `json:"id,omitempty"`

		// Name Name of the deployed model.
		Name *string `json:"name,omitempty"`

		// Status Current status of the deployed model. Would be one of the following - deploying, destroying, deployFailed, destroyFailed.
		Status *string `json:"status,omitempty"`

		// UsageMetrics Token and request information.
		UsageMetrics *UsageMetrics `json:"usageMetrics,omitempty"`
	} `json:"model,omitempty"`
}

// GetLanguageModelsResponse defines model for GetLanguageModelsResponse.
type GetLanguageModelsResponse struct {
	Cursor Cursor                     `json:"cursor"`
	Data   []GetLanguageModelResponse `json:"data"`
}

// GetMtlsConfigurationResponse defines model for GetMtlsConfigurationResponse.
type GetMtlsConfigurationResponse struct {
	Prefixes *[]MtlsPrefix `json:"prefixes,omitempty"`

	// State The state of the mTLS configuration.
	State GetMtlsConfigurationResponseState `json:"state"`
}

// GetMtlsConfigurationResponseState The state of the mTLS configuration.
type GetMtlsConfigurationResponseState string

// GetNetworkPeeringRecordResponse defines model for GetNetworkPeeringRecordResponse.
type GetNetworkPeeringRecordResponse struct {
	Audit CouchbaseAuditData `json:"audit"`

	// Commands Commands contains the list of commands that the user must execute in order to complete the association of the network. For Azure, please refer to the *Get Azure VNet Peering CLI Command* API to fetch the role assignment command to be run in the Azure CLI.
	Commands []string `json:"commands"`

	// Id The ID is the unique UUID generated when a VPC record is created.
	Id string `json:"id"`

	// Name Name of the peering relationship.
	Name string `json:"name"`

	// ProviderConfig This provides details about the configuration and the ID of the VPC peer on AWS, GCP, or Azure.
	ProviderConfig GetNetworkPeeringRecordResponse_ProviderConfig `json:"providerConfig"`
	Status         PeeringStatus                                  `json:"status"`
}

// GetNetworkPeeringRecordResponse_ProviderConfig This provides details about the configuration and the ID of the VPC peer on AWS, GCP, or Azure.
type GetNetworkPeeringRecordResponse_ProviderConfig struct {
	union json.RawMessage
}

// GetOpenAIConfigurationResponse defines model for GetOpenAIConfigurationResponse.
type GetOpenAIConfigurationResponse = map[string]interface{}

// GetOrganizationResponse defines model for GetOrganizationResponse.
type GetOrganizationResponse struct {
	Audit CouchbaseAuditData `json:"audit"`

	// Description The description of a particular organization.
	Description string `json:"description"`

	// Id A GUID4 identifier of the organization.
	Id openapi_types.UUID `json:"id"`

	// Name The name of the organization.
	Name string `json:"name"`

	// Preferences Preferences stores preferences for the organization.
	Preferences Preferences `json:"preferences"`

	// Subdomain The new name of the subdomain for the organization.
	Subdomain *string `json:"subdomain,omitempty"`
}

// GetOrganizationsResponse defines model for GetOrganizationsResponse.
type GetOrganizationsResponse struct {
	Data []GetOrganizationResponse `json:"data"`
}

// GetPrivateEndpointServiceConnectionResponse defines model for GetPrivateEndpointServiceConnectionResponse.
type GetPrivateEndpointServiceConnectionResponse struct {
	// EndpointId endpoint id
	EndpointId string `json:"endpointId"`

	// Status satus of the private endpoint connection
	Status GetPrivateEndpointServiceConnectionResponseStatus `json:"status"`
}

// GetPrivateEndpointServiceConnectionResponseStatus satus of the private endpoint connection
type GetPrivateEndpointServiceConnectionResponseStatus string

// GetPrivateEndpointServiceResponse defines model for GetPrivateEndpointServiceResponse.
type GetPrivateEndpointServiceResponse struct {
	// Enabled Returns true if private endpoint is enabled
	Enabled bool `json:"enabled"`

	// PrivateDns Private endpoint DNS name
	PrivateDns string `json:"privateDns"`

	// ServiceName AWS private DNS service name
	ServiceName string `json:"serviceName"`

	// Status status of the private endpoint
	Status GetPrivateEndpointServiceResponseStatus `json:"status"`
}

// GetPrivateEndpointServiceResponseStatus status of the private endpoint
type GetPrivateEndpointServiceResponseStatus string

// GetPrivateEndpointServiceStatusResponse defines model for GetPrivateEndpointServiceStatusResponse.
type GetPrivateEndpointServiceStatusResponse struct {
	// Enabled The status of the private endpoint service.
	Enabled bool `json:"enabled"`
}

// GetPrivateEndpointsResponse defines model for GetPrivateEndpointsResponse.
type GetPrivateEndpointsResponse struct {
	Endpoints []PrivateEndpoint `json:"endpoints"`
}

// GetProjectLevelCloudSnapshotBackupResponse defines model for GetProjectLevelCloudSnapshotBackupResponse.
type GetProjectLevelCloudSnapshotBackupResponse struct {
	// CloudProvider The cloud service provider hosting the cluster (e.g., AWS, Azure, GCP).
	CloudProvider *string `json:"cloudProvider,omitempty"`

	// ClusterId The unique identifier of the cluster.
	ClusterId *string `json:"clusterId,omitempty"`

	// ClusterName The name assigned to the cluster.
	ClusterName *string `json:"clusterName,omitempty"`

	// CreatedBy The identifier or name of the user who created the cluster.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreationDateTime The date and time when the cluster was created, in ISO 8601 format.
	CreationDateTime *time.Time `json:"creationDateTime,omitempty"`

	// CurrentStatus The current operational status of the cluster (e.g., healthy, destroyed, scaling).
	CurrentStatus      *string                         `json:"currentStatus,omitempty"`
	MostRecentSnapshot *GetCloudSnapshotBackupResponse `json:"mostRecentSnapshot,omitempty"`
	OldestSnapshot     *GetCloudSnapshotBackupResponse `json:"oldestSnapshot,omitempty"`

	// Region The geographical region where the cluster is deployed.
	Region *string `json:"region,omitempty"`
}

// GetProjectResponse defines model for GetProjectResponse.
type GetProjectResponse struct {
	Audit CouchbaseAuditData `json:"audit"`

	// Description The description of a particular project.
	Description string `json:"description"`

	// Id A GUID4 identifier of the project.
	Id openapi_types.UUID `json:"id"`

	// Name The name of the project.
	Name string `json:"name"`
}

// GetProjectsResponse defines model for GetProjectsResponse.
type GetProjectsResponse struct {
	Cursor Cursor               `json:"cursor"`
	Data   []GetProjectResponse `json:"data"`
}

// GetProviderResponse defines model for GetProviderResponse.
type GetProviderResponse struct {
	Audit *CouchbaseAuditData `json:"audit,omitempty"`

	// Configuration The credentials for the provider.
	Configuration *GetProviderResponse_Configuration `json:"configuration,omitempty"`

	// Name The name of the provider.
	Name *string `json:"name,omitempty"`

	// Type The type of the provider.
	Type *string `json:"type,omitempty"`
}

// GetProviderResponse_Configuration The credentials for the provider.
type GetProviderResponse_Configuration struct {
	union json.RawMessage
}

// GetReplicationResponse defines model for GetReplicationResponse.
type GetReplicationResponse struct {
	Audit ReplicationAuditData `json:"audit"`

	// ChangesLeft The number of remaining mutations to the replication.
	ChangesLeft int `json:"changesLeft"`

	// Direction Direction specifies the replication flow — whether it's oneWay (source to target only) or twoWay (also from target back to source).
	Direction GetReplicationResponseDirection `json:"direction"`

	// Error The error message if the replication has failed.
	Error *string `json:"error,omitempty"`

	// Filter Filter contains the replication settings which are passed to the Couchbase server API while creating a replication.
	Filter *GetFilter `json:"filter,omitempty"`

	// Id The ID of the specified replication.
	Id string `json:"id"`

	// Mappings Defines mappings from source to target scopes and collections.
	// This field is only required if you are replicating specific scopes and collections.
	//
	// Note: If the collections array is empty or omitted, it implies all collections under that scope would be replicated.
	Mappings *Mappings `json:"mappings,omitempty"`

	// NetworkUsageLimit Network usage limit in MiB per second. 0 means unlimited.
	NetworkUsageLimit *int `json:"networkUsageLimit,omitempty"`

	// Priority Priority represents the resource allocation to the replication.
	//
	// - low: Resource constraints are applied when competing with high priority replications
	// - medium: Resource constraints are applied during initial processing when competing with high priority replications, then operates as high priority
	// - high: No resource constraints are applied (default priority)
	Priority *GetReplicationResponsePriority `json:"priority,omitempty"`

	// Source Source contains all the metadata about a replication source.
	Source ReplicationSource `json:"source"`

	// Status The status of the replication.
	Status GetReplicationResponseStatus `json:"status"`

	// Target Target contains all the metadata about a replication target.
	Target ReplicationTarget `json:"target"`
}

// GetReplicationResponseDirection Direction specifies the replication flow — whether it's oneWay (source to target only) or twoWay (also from target back to source).
type GetReplicationResponseDirection string

// GetReplicationResponsePriority Priority represents the resource allocation to the replication.
//
// - low: Resource constraints are applied when competing with high priority replications
// - medium: Resource constraints are applied during initial processing when competing with high priority replications, then operates as high priority
// - high: No resource constraints are applied (default priority)
type GetReplicationResponsePriority string

// GetReplicationResponseStatus The status of the replication.
type GetReplicationResponseStatus string

// GetS3ConfigurationResponse defines model for GetS3ConfigurationResponse.
type GetS3ConfigurationResponse struct {
	// AwsRegion The AWS region the S3 bucket is located in.
	AwsRegion *string `json:"awsRegion,omitempty"`

	// Bucket The name of the S3 bucket.
	Bucket *string `json:"bucket,omitempty"`

	// FolderPath The path to the folder in the S3 bucket where the files are stored. Empty denotes the root folder.
	FolderPath *string `json:"folderPath,omitempty"`
}

// GetScheduledBackupResponse Backup schedule type.
type GetScheduledBackupResponse struct {
	// BucketId The ID of the bucket. This is the Base64 encoding of the bucket name.
	BucketId string `json:"bucketId"`

	// ClusterID The ID of the cluster.
	ClusterID openapi_types.UUID `json:"clusterID"`
	Type      string             `json:"type"`

	// WeeklySchedule Schedule a full backup once a week with regular incrementals.
	WeeklySchedule WeeklySchedule `json:"weeklySchedule"`
}

// GetScopeResponse defines model for GetScopeResponse.
type GetScopeResponse struct {
	Collections *[]Collection `json:"collections,omitempty"`

	// Name Name of the scope.
	Name *string `json:"name,omitempty"`
}

// GetScopesResponse defines model for GetScopesResponse.
type GetScopesResponse struct {
	Scopes []Scope `json:"scopes"`
}

// GetStructuredWorkflowResponse defines model for GetStructuredWorkflowResponse.
type GetStructuredWorkflowResponse struct {
	Source IntegrationConfig `json:"source"`

	// StructuredDataProcessingConfig Configuration for structured data processing.
	StructuredDataProcessingConfig struct {
		// JsonType The type of JSON that has to be processed by the structured data processing workflow.
		JsonType GetStructuredWorkflowResponseStructuredDataProcessingConfigJsonType `json:"jsonType"`

		// KeyFieldName The name of the field that will be used as the key for the Capella document. Random UUID will be generated if not provided.
		KeyFieldName *string `json:"keyFieldName,omitempty"`
	} `json:"structuredDataProcessingConfig"`
	TargetCouchbaseKeyspace CouchbaseKeyspace `json:"targetCouchbaseKeyspace"`

	// VectorizationConfig Configuration for vectorization in a workflow.
	VectorizationConfig VectorizationConfig `json:"vectorizationConfig"`
}

// GetStructuredWorkflowResponseStructuredDataProcessingConfigJsonType The type of JSON that has to be processed by the structured data processing workflow.
type GetStructuredWorkflowResponseStructuredDataProcessingConfigJsonType string

// GetUnstructuredWorkflowResponse defines model for GetUnstructuredWorkflowResponse.
type GetUnstructuredWorkflowResponse struct {
	Source                  IntegrationConfig `json:"source"`
	TargetCouchbaseKeyspace CouchbaseKeyspace `json:"targetCouchbaseKeyspace"`

	// UnstructuredDataProcessingConfig Configuration for unstructured data processing.
	UnstructuredDataProcessingConfig struct {
		// ChunkingStrategy The strategy to use for chunking the file.
		ChunkingStrategy struct {
			// ChunkOverlap The overlap between the chunks.
			ChunkOverlap *int `json:"chunkOverlap,omitempty"`

			// ChunkSize The size of the chunks to be created.
			ChunkSize    *int                                                                                         `json:"chunkSize,omitempty"`
			StrategyType *GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigChunkingStrategyStrategyType `json:"strategyType,omitempty"`
		} `json:"chunkingStrategy"`

		// EnableOCR Whether to enable OCR scanning for the file.
		// If not provided, OCR will be disabled.
		EnableOCR *bool `json:"enableOCR,omitempty"`

		// Exclusions The sections of the file which have to be excluded from the unstructured data processing workflow.
		// Should be an array of strings, each representing a section of the file to be excluded.
		// The possible values are:
		//   - Header
		//   - Footer
		//   - Table
		//
		// If not provided, all sections will be processed.
		Exclusions *[]GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigExclusions `json:"exclusions,omitempty"`

		// PageNumbers The page range of the file which has to be processed.
		// If not provided, all pages will be processed.
		// Should be an array of size 2, with the first element being the start page and the second element being the end page.
		PageNumbers *[]int `json:"pageNumbers,omitempty"`
	} `json:"unstructuredDataProcessingConfig"`

	// VectorizationConfig Configuration for vectorization in a workflow.
	VectorizationConfig VectorizationConfig `json:"vectorizationConfig"`
}

// GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigChunkingStrategyStrategyType defines model for GetUnstructuredWorkflowResponse.UnstructuredDataProcessingConfig.ChunkingStrategy.StrategyType.
type GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigChunkingStrategyStrategyType string

// GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigExclusions defines model for GetUnstructuredWorkflowResponse.UnstructuredDataProcessingConfig.Exclusions.
type GetUnstructuredWorkflowResponseUnstructuredDataProcessingConfigExclusions string

// GetUserResponse defines model for GetUserResponse.
type GetUserResponse struct {
	Audit CouchbaseAuditData `json:"audit"`

	// Email Email of the user.
	Email Email `json:"email"`

	// EnableNotifications After enabling email notifications for your account, you will start receiving email notification alerts from all databases in projects you are a part of.
	EnableNotifications *bool `json:"enableNotifications,omitempty"`

	// ExpiresAt Time at which user expires.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Id The UUID of the user created.
	Id string `json:"id"`

	// Inactive Depicts whether the user has accepted the invite for the organization.
	Inactive bool `json:"inactive"`

	// LastLogin Time(UTC) at which user last logged in.
	LastLogin *time.Time `json:"lastLogin,omitempty"`

	// Name The name of the user.
	Name string `json:"name"`

	// OrganizationId A GUID4 identifier of the tenant.
	OrganizationId    string              `json:"organizationId"`
	OrganizationRoles []OrganizationRoles `json:"organizationRoles"`

	// Region Region of the user.
	Region    *string     `json:"region,omitempty"`
	Resources *[]Resource `json:"resources,omitempty"`

	// Status Depicts user status whether they are verified or not.
	// - verified: It reflects a verified state for an email address where the user has proven that they have access to the email account.
	// - not-verified: It reflects an unverified or pending verification state.
	// - pending-primary: It reflects an unverified primary email address
	Status GetUserResponseStatus `json:"status"`

	// TimeZone Time zone of the user.
	TimeZone *string `json:"timeZone,omitempty"`
}

// GetUserResponseStatus Depicts user status whether they are verified or not.
// - verified: It reflects a verified state for an email address where the user has proven that they have access to the email account.
// - not-verified: It reflects an unverified or pending verification state.
// - pending-primary: It reflects an unverified primary email address
type GetUserResponseStatus string

// GetUsersResponse defines model for GetUsersResponse.
type GetUsersResponse struct {
	Cursor Cursor            `json:"cursor"`
	Data   []GetUserResponse `json:"data"`
}

// GetVectorizationWorkflowResponse defines model for GetVectorizationWorkflowResponse.
type GetVectorizationWorkflowResponse struct {
	TargetCouchbaseKeyspace CouchbaseKeyspace `json:"targetCouchbaseKeyspace"`

	// VectorizationConfig Configuration for vectorization in a workflow.
	VectorizationConfig VectorizationConfig `json:"vectorizationConfig"`
}

// GetWorkflowResponse defines model for GetWorkflowResponse.
type GetWorkflowResponse struct {
	Audit         CouchbaseAuditData                `json:"audit"`
	Configuration GetWorkflowResponse_Configuration `json:"configuration"`

	// Id The unique identifier for the workflow.
	Id string `json:"id"`

	// Name The name of the workflow.
	Name string `json:"name"`

	// Type The type of workflow.
	Type GetWorkflowResponseType `json:"type"`
}

// GetWorkflowResponse_Configuration defines model for GetWorkflowResponse.Configuration.
type GetWorkflowResponse_Configuration struct {
	union json.RawMessage
}

// GetWorkflowResponseType The type of workflow.
type GetWorkflowResponseType string

// GetWorkflowRunProcessedFilesResponse defines model for GetWorkflowRunProcessedFilesResponse.
type GetWorkflowRunProcessedFilesResponse struct {
	Cursor Cursor `json:"cursor"`
	Data   []struct {
		// FileName Name of the file that failed.
		FileName *string `json:"fileName,omitempty"`

		// FilePath Path of the file that failed.
		FilePath *string `json:"filePath,omitempty"`

		// FileStatus Status of the file in the workflow run.
		FileStatus *GetWorkflowRunProcessedFilesResponseDataFileStatus `json:"fileStatus,omitempty"`
	} `json:"data"`
}

// GetWorkflowRunProcessedFilesResponseDataFileStatus Status of the file in the workflow run.
type GetWorkflowRunProcessedFilesResponseDataFileStatus string

// GetWorkflowRunResponse defines model for GetWorkflowRunResponse.
type GetWorkflowRunResponse struct {
	// CreatedAt The date and time when the workflow run was created.
	CreatedAt string `json:"createdAt"`

	// CreatedByUserID The unique identifier for the user who created the workflow run.
	CreatedByUserID string `json:"createdByUserID"`

	// ErroredFiles Number of files that errored out while processing in the workflow run.
	ErroredFiles *int `json:"erroredFiles,omitempty"`

	// Id The unique identifier for the workflow run.
	Id string `json:"id"`

	// ProcessedFiles Number of files that have been processed in the workflow run.
	ProcessedFiles *int `json:"processedFiles,omitempty"`

	// Status The current state of the workflow run:
	//   * `deploying`: The workflow run is being deployed
	//   * `running`: The workflow run is executing
	//   * `completed`: The workflow run finished successfully
	//   * `partiallyCompleted`: The workflow run finished with some errors
	//   * `failed`: The workflow run failed
	//   * `stopping`: The workflow run is being stopped
	//
	// **Actions:**
	//   * To retry a failed workflow run, send a POST request to `/aiServices/workflows/{workflowId}`
	//   * To retrieve all processed files (including both successful and failed), send a GET request to `/aiServices/workflows/{workflowId}/runs/{runId}/processedFiles`
	Status GetWorkflowRunResponseStatus `json:"status"`

	// TotalFiles Total number of files that are picked up by the workflow run.
	TotalFiles *int `json:"totalFiles,omitempty"`
}

// GetWorkflowRunResponseStatus The current state of the workflow run:
//   - `deploying`: The workflow run is being deployed
//   - `running`: The workflow run is executing
//   - `completed`: The workflow run finished successfully
//   - `partiallyCompleted`: The workflow run finished with some errors
//   - `failed`: The workflow run failed
//   - `stopping`: The workflow run is being stopped
//
// **Actions:**
//   - To retry a failed workflow run, send a POST request to `/aiServices/workflows/{workflowId}`
//   - To retrieve all processed files (including both successful and failed), send a GET request to `/aiServices/workflows/{workflowId}/runs/{runId}/processedFiles`
type GetWorkflowRunResponseStatus string

// GetWorkflowRunsResponse defines model for GetWorkflowRunsResponse.
type GetWorkflowRunsResponse struct {
	Cursor Cursor                   `json:"cursor"`
	Data   []GetWorkflowRunResponse `json:"data"`
}

// Hrefs defines model for Hrefs.
type Hrefs struct {
	// First The base URL, endpoint, and path parameters required to fetch the first page of results.
	First string `json:"first"`

	// Last The base URL, endpoint, and path parameters required to fetch the last page of results.
	Last string `json:"last"`

	// Next The base URL, endpoint, and path parameters required to fetch the next page of results.
	// Empty if there is no next page.
	Next string `json:"next"`

	// Previous The base URL, endpoint, and path parameters required to fetch the previous page of results.
	// Empty if there is no previous page.
	Previous string `json:"previous"`
}

// ImportFilter The Javascript function used to specify the documents in this collection that are to be imported by the App Endpoint. By default, all documents in corresponding collection are imported.
type ImportFilter = string

// IndexBuildStatusResponse defines model for IndexBuildStatusResponse.
type IndexBuildStatusResponse struct {
	// Status The possible values for index build status are:
	//
	// Created:  index is created and ready to start the build
	//
	// Ready:    build completed and index is active
	//
	// Building: index has started building
	Status IndexBuildStatusResponseStatus `json:"status"`
}

// IndexBuildStatusResponseStatus The possible values for index build status are:
//
// Created:  index is created and ready to start the build
//
// Ready:    build completed and index is active
//
// Building: index has started building
type IndexBuildStatusResponseStatus string

// IndexDDLRequest defines model for IndexDDLRequest.
type IndexDDLRequest struct {
	// Definition The index DDL statement.  This can be a CREATE/DROP/ALTER/BUILD statement.
	//
	// Multiple delimited queries are not allowed.
	//
	// It is recommended to use deferred index builds, especially for larger indexes. When creating indexes in bulk, we do not recommend sending requests to create all of them at once.
	// Instead, we strongly recommend creating indexes in batches of 100 or less.
	Definition string `json:"definition"`
}

// IndexDDLResponse defines model for IndexDDLResponse.
type IndexDDLResponse struct {
	Errors *[]struct {
		// Msg The error message
		Msg string `json:"msg"`
	} `json:"errors,omitempty"`
}

// IndexDefinitionsResponse defines model for IndexDefinitionsResponse.
type IndexDefinitionsResponse struct {
	Definition string `json:"definition"`
	IndexName  string `json:"indexName"`
}

// IndexPropertiesResponse defines model for IndexPropertiesResponse.
type IndexPropertiesResponse struct {
	Bucket     string   `json:"bucket"`
	Collection string   `json:"collection"`
	DefnId     int      `json:"defnId"`
	IndexName  string   `json:"indexName"`
	IsPrimary  bool     `json:"isPrimary"`
	NumReplica int      `json:"numReplica"`
	Scope      string   `json:"scope"`
	SecExprs   []string `json:"secExprs"`
	Status     string   `json:"status"`
	Where      string   `json:"where"`
}

// IntegrationConfig defines model for IntegrationConfig.
type IntegrationConfig struct {
	// Name The name of the Capella integration used for the workflow.
	Name string `json:"name"`

	// ProviderId The unique identifier for the provider of the integration. This is used to identify the integration in the Capella platform.
	ProviderId string `json:"providerId"`
}

// ListAdminUsersResponse defines model for ListAdminUsersResponse.
type ListAdminUsersResponse struct {
	Cursor Cursor                `json:"cursor"`
	Data   []AppServiceAdminUser `json:"data"`
}

// ListAppEndpointsResponse defines model for ListAppEndpointsResponse.
type ListAppEndpointsResponse struct {
	Cursor Cursor                   `json:"cursor"`
	Data   []GetAppEndpointResponse `json:"data"`
}

// ListAuditExportDocs defines model for ListAuditExportDocs.
type ListAuditExportDocs struct {
	Cursor *Cursor                      `json:"cursor,omitempty"`
	Data   *[]GetAuditExportDocResponse `json:"data,omitempty"`
}

// ListBackupsResponse defines model for ListBackupsResponse.
type ListBackupsResponse struct {
	Data []GetBackupByIDResponse `json:"data"`
}

// ListCloudSnapshotBackupsResponse defines model for ListCloudSnapshotBackupsResponse.
type ListCloudSnapshotBackupsResponse struct {
	Cursor Cursor                           `json:"cursor"`
	Data   []GetCloudSnapshotBackupResponse `json:"data"`
}

// ListCloudSnapshotRestoresResponse defines model for ListCloudSnapshotRestoresResponse.
type ListCloudSnapshotRestoresResponse struct {
	Cursor Cursor                            `json:"cursor"`
	Data   []GetCloudSnapshotRestoreResponse `json:"data"`
}

// ListClusterReplicationsResponse defines model for ListClusterReplicationsResponse.
type ListClusterReplicationsResponse struct {
	Cursor Cursor               `json:"cursor"`
	Data   []ReplicationSummary `json:"data"`
}

// ListColumnarAnalyticsBackupsResponse defines model for ListColumnarAnalyticsBackupsResponse.
type ListColumnarAnalyticsBackupsResponse struct {
	Cursor Cursor                               `json:"cursor"`
	Data   []GetColumnarAnalyticsBackupResponse `json:"data"`
}

// ListColumnarAnalyticsRestoresResponse defines model for ListColumnarAnalyticsRestoresResponse.
type ListColumnarAnalyticsRestoresResponse struct {
	Cursor Cursor                                `json:"cursor"`
	Data   []GetColumnarAnalyticsRestoreResponse `json:"data"`
}

// ListIndexDefinitionsResponse defines model for ListIndexDefinitionsResponse.
type ListIndexDefinitionsResponse struct {
	Definitions []IndexDefinitionsResponse `json:"definitions"`
}

// ListLanguageModelAPIKeysResponse defines model for ListLanguageModelAPIKeysResponse.
type ListLanguageModelAPIKeysResponse struct {
	Cursor Cursor                           `json:"cursor"`
	Data   []GetLanguageModelAPIKeyResponse `json:"data"`
}

// ListNetworkPeeringRecordsResponse defines model for ListNetworkPeeringRecordsResponse.
type ListNetworkPeeringRecordsResponse struct {
	Cursor Cursor                           `json:"cursor"`
	Data   []ListSingleNetworkPeeringRecord `json:"data"`
}

// ListOIDCProvidersResponse defines model for ListOIDCProvidersResponse.
type ListOIDCProvidersResponse struct {
	Cursor Cursor         `json:"cursor"`
	Data   []OIDCProvider `json:"data"`
}

// ListPrivateEndpointServiceConnectionsResponse defines model for ListPrivateEndpointServiceConnectionsResponse.
type ListPrivateEndpointServiceConnectionsResponse struct {
	Endpoints []GetPrivateEndpointServiceConnectionResponse `json:"endpoints"`
}

// ListProjectLevelCloudSnapshotResponse defines model for ListProjectLevelCloudSnapshotResponse.
type ListProjectLevelCloudSnapshotResponse struct {
	Cursor Cursor                                       `json:"cursor"`
	Data   []GetProjectLevelCloudSnapshotBackupResponse `json:"data"`
}

// ListProjectReplicationsResponse defines model for ListProjectReplicationsResponse.
type ListProjectReplicationsResponse struct {
	Cursor Cursor               `json:"cursor"`
	Data   []ReplicationSummary `json:"data"`
}

// ListProvidersResponse defines model for ListProvidersResponse.
type ListProvidersResponse struct {
	Cursor *Cursor `json:"cursor,omitempty"`
	Data   *[]struct {
		Audit *CouchbaseAuditData `json:"audit,omitempty"`

		// Configuration The credentials for the provider.
		Configuration *ListProvidersResponse_Data_Configuration `json:"configuration,omitempty"`

		// Id The ID of the provider.
		Id *string `json:"id,omitempty"`

		// Name The name of the provider.
		Name *string `json:"name,omitempty"`

		// Type The type of the provider.
		Type *string `json:"type,omitempty"`
	} `json:"data,omitempty"`
}

// ListProvidersResponse_Data_Configuration The credentials for the provider.
type ListProvidersResponse_Data_Configuration struct {
	union json.RawMessage
}

// ListSingleNetworkPeeringRecord defines model for ListSingleNetworkPeeringRecord.
type ListSingleNetworkPeeringRecord struct {
	Audit CouchbaseAuditData `json:"audit"`

	// Id The ID is the unique UUID generated when a VPC record is created.
	Id string `json:"id"`

	// Name Name of the peering relationship.
	Name string `json:"name"`

	// ProviderConfig This provides details about the configuration and the ID of the VPC peer on AWS, GCP, or Azure.
	ProviderConfig ListSingleNetworkPeeringRecord_ProviderConfig `json:"providerConfig"`
	Status         PeeringStatus                                 `json:"status"`
}

// ListSingleNetworkPeeringRecord_ProviderConfig This provides details about the configuration and the ID of the VPC peer on AWS, GCP, or Azure.
type ListSingleNetworkPeeringRecord_ProviderConfig struct {
	union json.RawMessage
}

// ListWorkflowsResponse defines model for ListWorkflowsResponse.
type ListWorkflowsResponse struct {
	Cursor Cursor                `json:"cursor"`
	Data   []GetWorkflowResponse `json:"data"`
}

// Method The mechanism of the backup.
// 1. Incremental backups include the data that has changed since the last scheduled backup.
// 2. Full backup includes all bucket data from the time the backup was created.
type Method string

// MtlsCertificate defines model for MtlsCertificate.
type MtlsCertificate struct {
	Audit           CouchbaseAuditData  `json:"audit"`
	CertificateData MtlsCertificateData `json:"certificateData"`

	// Id The UUID of the certificate.
	Id            string               `json:"id"`
	IntendedState *MtlsCertificateData `json:"intendedState,omitempty"`

	// Status The status of the certificate.
	Status MtlsCertificateStatus `json:"status"`
}

// MtlsCertificateStatus The status of the certificate.
type MtlsCertificateStatus string

// MtlsCertificateData defines model for MtlsCertificateData.
type MtlsCertificateData struct {
	// Certificate The base encoded string of the Certificate.
	Certificate string `json:"certificate"`

	// Intermediates The base encoded string of the intermediates.
	Intermediates *string `json:"intermediates,omitempty"`

	// Name The name of the certificate.
	Name string `json:"name"`
}

// MtlsCertificateRequest defines model for MtlsCertificateRequest.
type MtlsCertificateRequest struct {
	// Certificate The base encoded string of the Certificate.
	Certificate string `json:"certificate"`

	// Intermediates The base encoded string of the intermediates.
	Intermediates *string `json:"intermediates,omitempty"`

	// Name Name of the certificate.
	Name string `json:"name"`
}

// MtlsCertificates defines model for MtlsCertificates.
type MtlsCertificates struct {
	Cursor Cursor            `json:"cursor"`
	Data   []MtlsCertificate `json:"data"`
}

// MtlsPrefix defines model for MtlsPrefix.
type MtlsPrefix struct {
	// Delimiter A single character that Couchbase Server should use to split the value extracted from the certificate. If it finds the delimiter in the value, Couchbase Server uses the portion of the value before the delimiter as the username. If Couchbase Server does not find the delimiter in the value, it uses the entire value as the username. For example, suppose you specify san.email as a path in the certificate, and set the delimeter to @. If Couchbase Server extracts the value john.smit@example.com as the value of san.email, it splits the value at the @, leaving it with john.smith to match to a username.
	Delimiter *string `json:"delimiter,omitempty"`

	// Path The path in the certificate to use.
	Path MtlsPrefixPath `json:"path"`

	// Prefix A prefix which is a string of text Couchbase Server attempts to match of the start of the value extracted from the certificate. If the prefix matches the start of the value, Couchbase Server removes the matching prefix from the value. It then tries to match the remaining string to a Couchbase Server username. If the prefix does not match the start of the value, Couchbase Server tries to match the entire value to a username. For example, suppose you specify san.uri as a path in the certificate to use, and set the prefix to www.. If Couchbase Server extracts the value www.example.com from the san.uri element in the certificate, the prefix matches leading www., leaving Couchbase Server with example.com as the username. If instead the san.uri is example.com, the prefix does not match. In this case, Couchbase Server attempts to match example.com to a username.
	Prefix *string `json:"prefix,omitempty"`
}

// MtlsPrefixPath The path in the certificate to use.
type MtlsPrefixPath string

// Node defines model for Node.
type Node struct {
	// Compute Following are the supported compute combinations for CPU and RAM for different cloud providers.
	// To learn more, see [Amazon Web Services](https://docs.couchbase.com/cloud/reference/aws.html).
	Compute Compute   `json:"compute"`
	Disk    Node_Disk `json:"disk"`
}

// Node_Disk defines model for Node.Disk.
type Node_Disk struct {
	union json.RawMessage
}

// OIDCProvider defines model for OIDCProvider.
type OIDCProvider struct {
	// ClientId The OpenID Connect provider client ID.
	ClientId string `json:"clientId"`

	// DiscoveryUrl The URL for the non-standard discovery endpoint.
	DiscoveryUrl *string `json:"discoveryUrl,omitempty"`

	// IsDefault Indicates whether this is the default OpenID Connect provider.
	IsDefault *bool `json:"isDefault,omitempty"`

	// Issuer The URL for the OpenID Connect issuer.
	Issuer string `json:"issuer"`

	// ProviderId UUID of the provider.
	ProviderId *string `json:"providerId,omitempty"`

	// Register Indicates whether to register a new App Service user account when a user logs in using OpenID Connect.
	Register *bool `json:"register,omitempty"`

	// RolesClaim If set, the value(s) of the given OpenID Connect authentication token claim will be added to the user's roles.
	// The value of this claim in the OIDC token must be either a string or an array of strings, any other type will result in an error.
	RolesClaim *string `json:"rolesClaim,omitempty"`

	// UserPrefix Username prefix for all users created for this provider
	UserPrefix *string `json:"userPrefix,omitempty"`

	// UsernameClaim Allows a different OpenID Connect field to be specified instead of the Subject (sub).
	UsernameClaim *string `json:"usernameClaim,omitempty"`
}

// OIDCProviderID The UUID of the OpenID Connect provider.
type OIDCProviderID struct {
	ProviderId string `json:"providerId"`
}

// OnTimeBoundary OnTimeBoundary corresponds to "from" and "to" time boundaries for when the cluster needs to be in the turned on (healthy) state on a day with "custom" scheduling timings.
// The time boundary should be according to the following rules:
//   - If the schedule is a non-custom day - with state `on` or `off`, it cannot contain a time boundary.
//   - If the schedule is a `custom` day -
//   - It should contain the `from` time boundary. If the `to` time boundary is not specified then the default value of 0 hour 0 minute is set and the cluster will be turned on for the entire day from the time set in `from` time boundary.
//   - Time boundary should have a valid `hour` value. The valid hour values are from 0 to 23 inclusive.
//   - Time boundary should have a valid `minute` value. The valid minute values are 0 and 30.
//   - The `from` time boundary should not be later than the `to` time boundary.
//   - If the `hour` and `minute` values are not provided for the time boundaries, it is set to a default value of 0 for both. (0 hour 0 minute)
type OnTimeBoundary struct {
	// Hour Hour of the time boundary.
	Hour *int `json:"hour,omitempty"`

	// Minute Minute of the time boundary.
	Minute *int `json:"minute,omitempty"`
}

// OrganizationRoles Organization roles assigned to the User.
//
// To learn more, see [Organization Roles](https://docs.couchbase.com/cloud/organizations/organization-user-roles.html).
type OrganizationRoles string

// Pages defines model for Pages.
type Pages struct {
	// Last Number of the last page of results.
	Last int `json:"last"`

	// Next Number of the next page of results. Not set on the last page.
	Next *int `json:"next,omitempty"`

	// Page Current page of results, starting from page 1.
	Page int `json:"page"`

	// PerPage Number of items displayed in each page.
	PerPage int `json:"perPage"`

	// Previous Number of the previous page of results. Not set on the first page.
	Previous *int `json:"previous,omitempty"`

	// TotalItems Total items found by the given query.
	TotalItems int `json:"totalItems"`
}

// PatchAuditLogStreamingRequest defines model for PatchAuditLogStreamingRequest.
type PatchAuditLogStreamingRequest struct {
	// Op Type of operation.
	Op PatchAuditLogStreamingRequestOp `json:"op"`

	// Path Path of resource that needs to be updated.
	Path string `json:"path"`

	// Value Determines whether audit log streaming is enabled or not.
	Value bool `json:"value"`
}

// PatchAuditLogStreamingRequestOp Type of operation.
type PatchAuditLogStreamingRequestOp string

// PatchEntry defines model for PatchEntry.
type PatchEntry struct {
	// Op Type of operation.
	Op PatchEntryOp `json:"op"`

	// Path Path of resource that needs to be updated.
	//
	// Organization Roles: `/organizationRoles`
	//
	// Resources: `/resources/{resourceId}`
	//
	// Resource Roles: `/resources/{resourceId}/roles`
	Path  string            `json:"path"`
	Value *PatchEntry_Value `json:"value,omitempty"`
}

// PatchEntryOp Type of operation.
type PatchEntryOp string

// PatchEntryValue0 defines model for .
type PatchEntryValue0 = []OrganizationRoles

// PatchEntryValue1 defines model for .
type PatchEntryValue1 = []ProjectRoles

// PatchEntry_Value defines model for PatchEntry.Value.
type PatchEntry_Value struct {
	union json.RawMessage
}

// PatchUserRequest defines model for PatchUserRequest.
type PatchUserRequest = []PatchEntry

// PeeringStatus defines model for PeeringStatus.
type PeeringStatus struct {
	Reasoning *string `json:"reasoning,omitempty"`
	State     *string `json:"state,omitempty"`
}

// PostSampleBucket defines model for PostSampleBucket.
type PostSampleBucket struct {
	// Name The name of the sample dataset to be loaded. The name has to be one of the following sample datasets.
	//
	//  - travel-sample
	//  - gamesim-sample
	//  - beer-sample
	//
	Name PostSampleBucketName `json:"name"`
}

// PostSampleBucketName The name of the sample dataset to be loaded. The name has to be one of the following sample datasets.
//
//   - travel-sample
//   - gamesim-sample
//   - beer-sample
type PostSampleBucketName string

// PostSampleBucketResponse defines model for PostSampleBucketResponse.
type PostSampleBucketResponse struct {
	// BucketId The ID of the sample data import job. This field will be present for clusters running on server versions above 7.5.
	BucketId string `json:"bucketId"`

	// Name Name of the bucket in which the sample data will be loaded.
	Name string `json:"name"`
}

// Preferences Preferences stores preferences for the organization.
type Preferences struct {
	// SessionDuration Maximum allowed time in seconds inside the organization for a user.
	SessionDuration *uint32 `json:"sessionDuration,omitempty"`
}

// PrivateEndpoint defines model for PrivateEndpoint.
type PrivateEndpoint struct {
	// Id endpoint id
	Id     string                `json:"id"`
	Status PrivateEndpointStatus `json:"status"`
}

// PrivateEndpointStatus defines model for PrivateEndpoint.Status.
type PrivateEndpointStatus string

// ProjectRoles Project Roles associated with the User.
//
// To learn more about Project Roles, see [Project Roles](https://docs.couchbase.com/cloud/projects/project-roles.html).
type ProjectRoles string

// PutAuditLogStreamingRequest defines model for PutAuditLogStreamingRequest.
type PutAuditLogStreamingRequest struct {
	// Credentials Secrets for audit log streaming configuration. Required when starting, resuming or pausing log streaming.
	Credentials *PutAuditLogStreamingRequest_Credentials `json:"credentials,omitempty"`

	// DisabledAppEndpoints List of App Endpoints to be excluded from audit log streaming.
	DisabledAppEndpoints *[]string `json:"disabledAppEndpoints,omitempty"`

	// OutputType The type of output for the audit log streaming. Required when starting, resuming or pausing log streaming.
	OutputType *string `json:"outputType,omitempty"`

	// StreamingEnabled Determines whether audit log streaming is enabled or not. To start or resume streaming, set this to true. To disable or pause log streaming, set this to false.
	StreamingEnabled *bool `json:"streamingEnabled,omitempty"`
}

// PutAuditLogStreamingRequest_Credentials Secrets for audit log streaming configuration. Required when starting, resuming or pausing log streaming.
type PutAuditLogStreamingRequest_Credentials struct {
	union json.RawMessage
}

// Replicas The number of replicas for the bucket.
// To learn more, see [Create a Bucket](https://docs.couchbase.com/cloud/clusters/data-service/manage-buckets.html#add-bucket).
type Replicas int

// ReplicationAuditData defines model for ReplicationAuditData.
type ReplicationAuditData struct {
	// CreatedAt The RFC3339 timestamp associated with when the replication was initially
	// created.
	CreatedAt time.Time `json:"createdAt"`

	// CreatedBy The user who created the replication; this will be a UUID4 ID for standard
	// users and will be a string such as "internal-support" for internal
	// Couchbase support users.
	CreatedBy string `json:"createdBy"`
}

// RequestConfig defines model for RequestConfig.
type RequestConfig struct {
	Webhook RequestWebhook `json:"webhook"`
}

// RequestWebhook defines model for RequestWebhook.
type RequestWebhook struct {
	BasicAuth *BasicAuth         `json:"basicAuth,omitempty"`
	Exclude   *Exclude           `json:"exclude,omitempty"`
	Headers   *map[string]string `json:"headers,omitempty"`

	// Method Type of API method to be sent when alert is triggered, either 'POST' or 'PUT'.
	Method RequestWebhookMethod `json:"method"`

	// Token The bearer authentication token is a third-party token that you set for the alert notifications sent through the webhook integration.
	Token *ExternalToken `json:"token,omitempty"`

	// Url The base URL of the webhook integration.
	Url string `json:"url"`
}

// RequestWebhookMethod Type of API method to be sent when alert is triggered, either 'POST' or 'PUT'.
type RequestWebhookMethod string

// Resource defines model for Resource.
type Resource struct {
	// Id Id of the project.
	Id    openapi_types.UUID `json:"id"`
	Roles []ProjectRoles     `json:"roles"`

	// Type Type of the resource.
	Type *ResourceType `json:"type,omitempty"`
}

// ResourceBucket defines model for ResourceBucket.
type ResourceBucket struct {
	// Name The name of the bucket.
	Name string `json:"name"`

	// Scopes The scopes under a bucket.
	Scopes *[]ResourceScope `json:"scopes,omitempty"`
}

// ResourceScope defines model for ResourceScope.
type ResourceScope struct {
	// Collections The collections under a scope.
	Collections *[]string `json:"collections,omitempty"`

	// Name The name of the scope.
	Name string `json:"name"`
}

// ResourceType Type of the resource.
type ResourceType string

// ResponseConfig defines model for ResponseConfig.
type ResponseConfig struct {
	Webhook ResponseWebhook `json:"webhook"`
}

// ResponseWebhook defines model for ResponseWebhook.
type ResponseWebhook struct {
	Exclude *Exclude           `json:"exclude,omitempty"`
	Headers *map[string]string `json:"headers,omitempty"`

	// Method The API method to use when sending alert notifications to the integrated service. Either 'POST' or 'PUT'.
	Method ResponseWebhookMethod `json:"method"`

	// Url The base URL of the webhook integration.
	Url string `json:"url"`
}

// ResponseWebhookMethod The API method to use when sending alert notifications to the integrated service. Either 'POST' or 'PUT'.
type ResponseWebhookMethod string

// RestoreId The id is a unique identifier for a restore.
type RestoreId = string

// ResyncRequest defines model for ResyncRequest.
type ResyncRequest struct {
	Scopes *map[string]ResyncScopes `json:"scopes,omitempty"`
}

// ResyncScopes Scope name with one or more collection names for which resync is triggered.
type ResyncScopes = []string

// ResyncStatus defines model for ResyncStatus.
type ResyncStatus struct {
	CollectionsProcessing *map[string]ResyncScopes `json:"collections_processing,omitempty"`

	// DocsChanged Number of documents that were changed during the resync operation.
	DocsChanged int32 `json:"docsChanged"`

	// DocsProcessed The amount of docs that have been processed so far in the resync operation.
	DocsProcessed int32 `json:"docsProcessed"`

	// LastError The last error that occurred in the resync operation (if any).
	LastError string `json:"lastError"`

	// StartTime The ISO-8601 date and time the resync operation was started.
	StartTime time.Time `json:"startTime"`

	// State The status of the current operation.
	State ResyncStatusState `json:"state"`
}

// ResyncStatusState The status of the current operation.
type ResyncStatusState string

// RotateAPIKeyRequest defines model for RotateAPIKeyRequest.
type RotateAPIKeyRequest struct {
	// Secret A secret associated with API key. One has to follow the secret key policy, such as allowed characters and a length of 64 characters.
	// If this field is left empty, a secret will be auto-generated.
	Secret *string `json:"secret,omitempty"`
}

// RotateAPIKeyResponse defines model for RotateAPIKeyResponse.
type RotateAPIKeyResponse struct {
	// SecretKey The Secret key is a confidential piece of information that is paired with the Access key.
	// The API key is made of an Access key and a Secret key.
	SecretKey string `json:"secretKey"`

	// Token The Token is a confidential piece of information that is used to authorize requests made to v4 endpoints.
	Token Token `json:"token"`
}

// RotateCMEKKey defines model for RotateCMEKKey.
type RotateCMEKKey struct {
	Config RotateCMEKKey_Config `json:"config"`
}

// RotateCMEKKey_Config defines model for RotateCMEKKey.Config.
type RotateCMEKKey_Config struct {
	union json.RawMessage
}

// ScheduleInfo Represents the schedule information of the backup.
type ScheduleInfo struct {
	// BackupTime The timestamp indicating the backup created time.
	BackupTime string `json:"backupTime"`

	// BackupType Represents whether the backup is a Weekly or Daily backup.
	BackupType string `json:"backupType"`

	// Increment Represents interval in hours for incremental backup.
	Increment int `json:"increment"`

	// Retention Represents retention time in days.
	Retention string `json:"retention"`
}

// Scope defines model for Scope.
type Scope struct {
	Collections []Collection `json:"collections"`

	// Name Name of the scope.
	Name *string `json:"name,omitempty"`
}

// ScopeConfig The scope config, defining Access control and validation functions, and import filters for each collection. The key to the scope config object is the name of the scope. Only one scope is allowed per App Endpoint.
type ScopeConfig struct {
	// Collections The collection config, defining Access control and validation functions and import filters for this collection. The key to the collection config object is the name of the collection.
	Collections CollectionsConfig `json:"collections"`
}

// ScopesConfig defines model for ScopesConfig.
type ScopesConfig map[string]ScopeConfig

// Service defines model for Service.
type Service string

// ServiceGroup defines model for ServiceGroup.
type ServiceGroup struct {
	Node *Node `json:"node,omitempty"`

	// NumOfNodes Number of nodes. The minimum number of nodes for the cluster can be 3 and maximum can be 27 nodes. - Additional service groups can have 2 nodes minimum and 24 nodes maximum. - SingleNode cluster can have only 1 node.
	NumOfNodes *int `json:"numOfNodes,omitempty"`

	// Services The couchbase service to run on the node. The allowed services for singleNode cluster are one or all of - data, index, query and search.
	Services *[]Service `json:"services,omitempty"`
}

// Services defines model for Services.
type Services = []string

// Source The way a backup job was initiated.
// 1. Manual represents a manually triggered backup job or on-demand.
// 2. Scheduled represents a backup job created from a schedule.
type Source string

// Stats defines model for Stats.
type Stats struct {
	// DiskUsedInMib The amount of disk used (in MiB).
	DiskUsedInMib int `json:"diskUsedInMib"`

	// ItemCount Number of documents in the bucket.
	ItemCount int `json:"itemCount"`

	// MemoryUsedInMib The amount of memory used (in MiB).
	MemoryUsedInMib int `json:"memoryUsedInMib"`

	// OpsPerSecond Number of operations per second.
	OpsPerSecond int `json:"opsPerSecond"`
}

// Status The status of the backup.
type Status string

// StorageBackend The storage engine to be assigned to and used by the bucket.
//
// - Ephemeral buckets do not support StorageBackend, hence not applicable for Ephemeral buckets and throws an error if this field is added.
//
//   - This field is only applicable for a Couchbase bucket. The default value before Couchbase Server 8.0 is `couchstore`.
//     The default value for Couchbase Server 8.0 and above is `magma` with 128 vbuckets.
//
// - This field cannot be changed later.
//
//	To learn more, see [Storage Engines](https://docs.couchbase.com/cloud/clusters/data-service/storage-engines.html).
type StorageBackend string

// Support defines model for Support.
type Support struct {
	// Plan Plan type, either 'Basic', 'Developer Pro', or 'Enterprise'.
	// Plan type allowed for singleNode cluster is either 'Basic', or 'Developer Pro'.
	// In case of 'Basic' plan timezone field value is ignored.
	Plan SupportPlan `json:"plan"`

	// Timezone The standard timezone for the cluster. Should be the TZ identifier.
	Timezone *SupportTimezone `json:"timezone,omitempty"`
}

// SupportPlan Plan type, either 'Basic', 'Developer Pro', or 'Enterprise'.
// Plan type allowed for singleNode cluster is either 'Basic', or 'Developer Pro'.
// In case of 'Basic' plan timezone field value is ignored.
type SupportPlan string

// SupportTimezone The standard timezone for the cluster. Should be the TZ identifier.
type SupportTimezone string

// Token The Token is a confidential piece of information that is used to authorize requests made to v4 endpoints.
type Token = string

// Type Type of the bucket.
//
// - If selected Ephemeral, it is not eligible for imports or App Endpoints creation. This field cannot be changed later.
//
// - The options may also be referred to as Memory and Disk (Couchbase), Memory Only (Ephemeral) in the Couchbase documentation.
//
// To learn more, see [Create a Bucket](https://docs.couchbase.com/cloud/clusters/data-service/manage-buckets.html#add-bucket).
type Type string

// UpdateAlertRequest defines model for UpdateAlertRequest.
type UpdateAlertRequest struct {
	Config RequestConfig `json:"config"`

	// Name Name of the alert integration (up to 1024 characters).
	Name *string `json:"name,omitempty"`
}

// UpdateAppEndpointRequest defines model for UpdateAppEndpointRequest.
type UpdateAppEndpointRequest struct {
	// Bucket The Capella Cluster backing bucket for the App Endpoint. Cannot be changed.
	Bucket string     `json:"bucket"`
	Cors   CORSConfig `json:"cors"`

	// DeltaSyncEnabled Enable or disable delta sync
	DeltaSyncEnabled bool `json:"deltaSyncEnabled"`

	// Name App Endpoint name. Cannot be changed.
	Name string `json:"name"`

	// Oidc OpenID Connect provider configuration.
	Oidc   []OIDCProvider `json:"oidc"`
	Scopes ScopesConfig   `json:"scopes"`

	// UserXattrKey Key of user xattr that will be accessible from the Access control and validation function. If empty, the feature will be disabled.
	UserXattrKey string `json:"userXattrKey"`
}

// UpdateAppServiceAdminUserAllEndpointsRequest defines model for UpdateAppServiceAdminUserAllEndpointsRequest.
type UpdateAppServiceAdminUserAllEndpointsRequest struct {
	// AccessAllEndpoints Give user access to all App Endpoints.
	AccessAllEndpoints bool `json:"accessAllEndpoints"`
}

// UpdateAppServiceAdminUserEndpointList defines model for UpdateAppServiceAdminUserEndpointList.
type UpdateAppServiceAdminUserEndpointList struct {
	// Endpoints The list of App Endpoints that the user has access to.
	Endpoints []string `json:"endpoints"`
}

// UpdateAppServiceRequest defines model for UpdateAppServiceRequest.
type UpdateAppServiceRequest struct {
	// Compute The CPU and RAM configuration of the App Service. The supported combinations are:
	// | CPU (cores)| RAM  (GB)   |
	// | --------   |   -------   |
	// | 2          | 4           |
	// | 4          | 8           |
	// | 8          | 16          |
	// | 16         | 32          |
	// | 36         | 72          |
	Compute AppServiceCompute `json:"compute"`

	// Nodes Number of nodes configured for the App Service. The number of nodes can range from 2 to 12.
	Nodes int `json:"nodes"`
}

// UpdateBucketRequest defines model for UpdateBucketRequest.
type UpdateBucketRequest struct {
	// DurabilityLevel This is the minimum level at which all writes to the bucket must occur.
	//
	// The options for Durability level are as follows, according to the bucket type.
	//
	// - For a Couchbase bucket:
	//
	//   1. None
	//
	//   2. Replicate to Majority
	//
	//   3. Majority and Persist to Active
	//
	//   4. Persist to Majority
	//
	// - For an Ephemeral bucket:
	//
	//   1. None
	//
	//   2. Replicate to Majority
	//
	//   To learn more, see [Create a Bucket](https://docs.couchbase.com/cloud/clusters/data-service/manage-buckets.html#add-bucket).
	DurabilityLevel UpdateBucketRequestDurabilityLevel `json:"durabilityLevel"`

	// Flush Replaced by flushEnabled. This property is deprecated and will be removed in a future release.
	//
	// The new value of flush property. This determines whether bucket flush is enabled. Enable Flush to be able to delete all items in this bucket at the earliest opportunity using /flush endpoint. Disable Flush to avoid inadvertent data loss by calling the /flush endpoint
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Flush *bool `json:"flush,omitempty"`

	// FlushEnabled This determines whether bucket flush is enabled. Enable flushEnabled to delete all items in this bucket at the earliest opportunity by calling the /flush endpoint. Disable flushEnabled to avoid inadvertent data loss by calling the /flush endpoint.
	FlushEnabled *bool `json:"flushEnabled,omitempty"`

	// MemoryAllocationInMb The new amount of memory to allocate for the bucket memory in MiB.
	// The maximum limit is dependent on the allocation of the KV service; for example, 80% of the allocation.
	//
	// - For Couchbase buckets, the default and minimum memory allocation changes according to the Storage Backend type, as follows:
	//
	//   1. For Couchstore, the default and minimum memory allocation is 100 MiB.
	//
	//   2. For Magma, the default and minimum memory allocation is 1024 MiB.
	//
	// - For Ephemeral buckets, the default and minimum memory allocation is 100 MiB.
	MemoryAllocationInMb int `json:"memoryAllocationInMb"`

	// Priority Priority of the bucket.
	//
	// - Specify relative bucket priority so that buckets will be recovered in the order specified during failover.
	//
	// - Bucket ranking/priority is only available in Couchbase Server 7.6 and above
	//
	// - Default bucket priority is 0 and can be set to a value between 0 and 1000. 1000 is the highest priority and 0 is the lowest.
	Priority *BucketPriority `json:"priority,omitempty"`

	// Replicas The number of replicas for the bucket.
	// To learn more, see [Create a Bucket](https://docs.couchbase.com/cloud/clusters/data-service/manage-buckets.html#add-bucket).
	Replicas UpdateBucketRequestReplicas `json:"replicas"`

	// TimeToLiveInSeconds Specify the new time to live (TTL) value in seconds. This is the maximum time to live for items in the bucket. If specified as 0, TTL is disabled. This is a non-negative value.
	TimeToLiveInSeconds int `json:"timeToLiveInSeconds"`
}

// UpdateBucketRequestDurabilityLevel This is the minimum level at which all writes to the bucket must occur.
//
// The options for Durability level are as follows, according to the bucket type.
//
// - For a Couchbase bucket:
//
//  1. None
//
//  2. Replicate to Majority
//
//  3. Majority and Persist to Active
//
//  4. Persist to Majority
//
// - For an Ephemeral bucket:
//
//  1. None
//
//  2. Replicate to Majority
//
//     To learn more, see [Create a Bucket](https://docs.couchbase.com/cloud/clusters/data-service/manage-buckets.html#add-bucket).
type UpdateBucketRequestDurabilityLevel string

// UpdateBucketRequestReplicas The number of replicas for the bucket.
// To learn more, see [Create a Bucket](https://docs.couchbase.com/cloud/clusters/data-service/manage-buckets.html#add-bucket).
type UpdateBucketRequestReplicas int

// UpdateBucketStorageBackendRequest defines model for UpdateBucketStorageBackendRequest.
type UpdateBucketStorageBackendRequest struct {
	// Buckets Names of the buckets which need to be migrated from Couchstore to Magma.
	Buckets []string `json:"buckets"`
}

// UpdateClusterRequest defines model for UpdateClusterRequest.
type UpdateClusterRequest struct {
	// Description The new cluster description (up to 1024 characters).
	Description string `json:"description"`

	// Name The new name of the cluster (up to 256 characters).
	Name          string         `json:"name"`
	ServiceGroups []ServiceGroup `json:"serviceGroups"`
	Support       Support        `json:"support"`
}

// UpdateCollectionRequest defines model for UpdateCollectionRequest.
type UpdateCollectionRequest struct {
	// MaxTTL Specify the new time to live (TTL) value in seconds.
	//  -  This value should be >= -1. Set to -1 to disable expiry for that collection.
	//  -  Set to 0 to use the bucket's maxTTL value.
	//  -  The maximum value that can be set for maxTTL is 2147483647.
	MaxTTL int `json:"maxTTL"`
}

// UpdateColumnarAnalyticsClusterRequest Update an analytics cluster
type UpdateColumnarAnalyticsClusterRequest struct {
	// Description The new cluster description (up to 1024 characters).
	Description string `json:"description"`

	// Name Name of the analytics cluster.
	Name string `json:"name"`

	// Nodes The number of nodes you want for the cluster
	Nodes   int             `json:"nodes"`
	Support ColumnarSupport `json:"support"`
}

// UpdateDatabaseCredentialRequest defines model for UpdateDatabaseCredentialRequest.
type UpdateDatabaseCredentialRequest struct {
	// Access Describes the access information of the database credential.
	Access *[]Access `json:"access,omitempty"`

	// Password The updated password of the database credential.
	Password *string `json:"password,omitempty"`
}

// UpdateFreeTierAppServiceRequest defines model for UpdateFreeTierAppServiceRequest.
type UpdateFreeTierAppServiceRequest struct {
	// Description A short description of the App Service.
	Description *string `json:"description,omitempty"`

	// Name Name of the App Service (up to 256 characters).
	Name *string `json:"name,omitempty"`
}

// UpdateFreeTierBucketRequest defines model for UpdateFreeTierBucketRequest.
type UpdateFreeTierBucketRequest struct {
	// MemoryAllocationInMb The new amount of memory to allocate for the bucket memory in MiB.
	MemoryAllocationInMb int `json:"memoryAllocationInMb"`
}

// UpdateFreeTierClusterRequest defines model for UpdateFreeTierClusterRequest.
type UpdateFreeTierClusterRequest struct {
	// Description The new cluster description (up to 1024 characters).
	Description string `json:"description"`

	// Name The new name of the cluster (up to 256 characters).
	Name string `json:"name"`
}

// UpdateMtlsConfigRequest defines model for UpdateMtlsConfigRequest.
type UpdateMtlsConfigRequest struct {
	Prefixes *[]MtlsPrefix `json:"prefixes,omitempty"`

	// State The state of the mTLS configuration.
	State UpdateMtlsConfigRequestState `json:"state"`
}

// UpdateMtlsConfigRequestState The state of the mTLS configuration.
type UpdateMtlsConfigRequestState string

// UpdateOpenAIConfigurationRequest defines model for UpdateOpenAIConfigurationRequest.
type UpdateOpenAIConfigurationRequest struct {
	// ApiKey The API key to access the OpenAI API.
	ApiKey *string `json:"apiKey,omitempty"`
}

// UpdateOrganizationConfigurationRequest defines model for UpdateOrganizationConfigurationRequest.
type UpdateOrganizationConfigurationRequest struct {
	// Subdomain The new name of the subdomain for the organization.
	Subdomain string `json:"subdomain"`
}

// UpdateProjectRequest defines model for UpdateProjectRequest.
type UpdateProjectRequest struct {
	// Description The new project description (up to 256 characters).
	Description *string `json:"description,omitempty"`

	// Name The new project name (up to 128 characters).
	Name string `json:"name"`
}

// UpdateProviderRequest defines model for UpdateProviderRequest.
type UpdateProviderRequest struct {
	// Configuration The configuration for the provider to update.
	Configuration UpdateProviderRequest_Configuration `json:"configuration"`
}

// UpdateProviderRequest_Configuration The configuration for the provider to update.
type UpdateProviderRequest_Configuration struct {
	union json.RawMessage
}

// UpdateReplicationRequest defines model for UpdateReplicationRequest.
type UpdateReplicationRequest struct {
	// AllScopes If true, all scopes will be replicated.
	// If false, the scopes specified in the mappings field will be replicated.
	AllScopes *bool `json:"allScopes,omitempty"`

	// Filter Filter contains the replication settings which are passed to the Couchbase server API while creating a replication.
	Filter *Filter `json:"filter,omitempty"`

	// Mappings Defines mappings from source to target scopes and collections.
	// This field is only required if you are replicating specific scopes and collections.
	//
	// Note: If the collections array is empty or omitted, it implies all collections under that scope would be replicated.
	Mappings *Mappings `json:"mappings,omitempty"`

	// NetworkUsageLimit Network usage limit in MiB per second. Default is 0 meaning it is unlimited.
	NetworkUsageLimit *int `json:"networkUsageLimit,omitempty"`

	// Priority Priority represents the resource allocation to the replication.
	//
	// - low: Resource constraints are applied when competing with high priority replications
	// - medium: Resource constraints are applied during initial processing when competing with high priority replications, then operates as high priority
	// - high: No resource constraints are applied (default priority)
	Priority *UpdateReplicationRequestPriority `json:"priority,omitempty"`
}

// UpdateReplicationRequestPriority Priority represents the resource allocation to the replication.
//
// - low: Resource constraints are applied when competing with high priority replications
// - medium: Resource constraints are applied during initial processing when competing with high priority replications, then operates as high priority
// - high: No resource constraints are applied (default priority)
type UpdateReplicationRequestPriority string

// UpdateS3ConfigurationRequest defines model for UpdateS3ConfigurationRequest.
type UpdateS3ConfigurationRequest struct {
	// AccessKeyId The access key ID to access the S3 bucket.
	AccessKeyId *string `json:"accessKeyId,omitempty"`

	// AwsRegion The AWS region the S3 bucket is located in.
	AwsRegion *string `json:"awsRegion,omitempty"`

	// Bucket The name of the S3 bucket.
	Bucket *string `json:"bucket,omitempty"`

	// FolderPath The path to the folder in the S3 bucket where the files are stored. Leave empty for root folder.
	FolderPath *string `json:"folderPath,omitempty"`

	// SecretAccessKey The secret access key to access the S3 bucket.
	SecretAccessKey *string `json:"secretAccessKey,omitempty"`

	// SessionToken The session token to access the S3 bucket in case of temporary credentials.
	SessionToken *string `json:"sessionToken,omitempty"`
}

// UpsertCloudSnapshotBackupScheduleRequest defines model for UpsertCloudSnapshotBackupScheduleRequest.
type UpsertCloudSnapshotBackupScheduleRequest struct {
	// CopyToRegions Represents the list of geographical regions where snapshot copies to be stored in addition to the primary region. Currently, this feature is supported for AWS and Azure clusters.
	CopyToRegions *[]string `json:"copyToRegions,omitempty"`

	// Interval Represents the time interval.
	Interval *int `json:"interval,omitempty"`

	// Retention Represents interval in hours to retain the backup.
	Retention *int `json:"retention,omitempty"`

	// StartTime Represents the start time in ISO 8601 format.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// UpsertColumnarAnalyticsBackupScheduleRequest defines model for UpsertColumnarAnalyticsBackupScheduleRequest.
type UpsertColumnarAnalyticsBackupScheduleRequest struct {
	// Interval Represents the time interval in hours.
	Interval int `json:"interval"`

	// Retention Represents the retention time of the backup in hours.
	Retention int `json:"retention"`

	// StartTime Represents the start time in ISO 8601 format.
	StartTime time.Time `json:"startTime"`
}

// UsageMetrics Token and request information.
type UsageMetrics struct {
	// Requests The requests consumed by the model.
	Requests *struct {
		// Trend The trend of request consumption.
		Trend *UsageMetricsRequestsTrend `json:"trend,omitempty"`

		// Value The number of requests consumed by the model.
		Value *int `json:"value,omitempty"`
	} `json:"requests,omitempty"`

	// Tokens Details about the tokens consumed by the model.
	Tokens *struct {
		// Trend The trend of token consumption.
		Trend *UsageMetricsTokensTrend `json:"trend,omitempty"`

		// Value The number of tokens consumed by the model.
		Value *int `json:"value,omitempty"`
	} `json:"tokens,omitempty"`
}

// UsageMetricsRequestsTrend The trend of request consumption.
type UsageMetricsRequestsTrend string

// UsageMetricsTokensTrend The trend of token consumption.
type UsageMetricsTokensTrend string

// VectorizationConfig Configuration for vectorization in a workflow.
type VectorizationConfig struct {
	// CreateIndexes When set to true, the workflow will create an index for every vector embedding field. When set to false, the workflow will not create an index for any vector embedding fields. Note that only the vector embedding fields specified in the `embeddingFieldMappings` object will be used for creating the indexes. Pre-existing embedding fields will not be used for creating the indexes. Every index created by the workflow will follow the convention of `Vector_<embedding-field-name>`.
	CreateIndexes *bool `json:"createIndexes,omitempty"`

	// EmbeddingFieldMappings A mapping of vector embedding field names to the object with their corresponding source field names and encoding format.
	EmbeddingFieldMappings map[string]struct {
		// EncodingFormat The encoding format of the vector embedding field.
		EncodingFormat *VectorizationConfigEmbeddingFieldMappingsEncodingFormat `json:"encodingFormat,omitempty"`

		// SourceFields A list of source fields for the corresponding vector embedding field.
		SourceFields *[]string `json:"sourceFields,omitempty"`
	} `json:"embeddingFieldMappings"`
	EmbeddingModel VectorizationConfig_EmbeddingModel `json:"embeddingModel"`
}

// VectorizationConfigEmbeddingFieldMappingsEncodingFormat The encoding format of the vector embedding field.
type VectorizationConfigEmbeddingFieldMappingsEncodingFormat string

// VectorizationConfig_EmbeddingModel defines model for VectorizationConfig.EmbeddingModel.
type VectorizationConfig_EmbeddingModel struct {
	union json.RawMessage
}

// VectorizationConfigCreation Configuration for vectorization in a workflow.
type VectorizationConfigCreation struct {
	// CreateIndexes When set to true, the workflow will create an index for every vector embedding field. When set to false, the workflow will not create an index for any vector embedding fields. Only the vector embedding fields specified in the `embeddingFieldMappings` object will be used for creating the indexes. Pre-existing embedding fields will not be used for creating the indexes. Every index created by the workflow will follow the convention of `Vector_<embedding-field-name>`.
	CreateIndexes *bool `json:"createIndexes,omitempty"`

	// EmbeddingFieldMappings A mapping of vector embedding field names to the object with their corresponding source field names and encoding format.
	EmbeddingFieldMappings *map[string]struct {
		// EncodingFormat The encoding format of the vector embedding field.
		EncodingFormat *VectorizationConfigCreationEmbeddingFieldMappingsEncodingFormat `json:"encodingFormat,omitempty"`

		// SourceFields A list of source fields for the corresponding vector embedding field.
		SourceFields *[]string `json:"sourceFields,omitempty"`
	} `json:"embeddingFieldMappings,omitempty"`
	EmbeddingModel VectorizationConfigCreation_EmbeddingModel `json:"embeddingModel"`
}

// VectorizationConfigCreationEmbeddingFieldMappingsEncodingFormat The encoding format of the vector embedding field.
type VectorizationConfigCreationEmbeddingFieldMappingsEncodingFormat string

// VectorizationConfigCreationEmbeddingModel0 defines model for .
type VectorizationConfigCreationEmbeddingModel0 struct {
	External struct {
		// ModelName The name of the external embedding model.
		ModelName         string `json:"modelName"`
		OpenAiIntegration struct {
			// ProviderId The unique identifier of the OpenAI integration provider. This is used to identify the integration in the Capella platform.
			ProviderId string `json:"providerId"`
		} `json:"openAiIntegration"`
	} `json:"external"`
}

// VectorizationConfigCreationEmbeddingModel1 defines model for .
type VectorizationConfigCreationEmbeddingModel1 struct {
	CapellaHostedModel struct {
		// ApiKeyId Specifies the id of the api key.
		ApiKeyId string `json:"apiKeyId"`

		// ApiKeyToken Specifies the token of the api key.
		ApiKeyToken string `json:"apiKeyToken"`

		// Id The ID of the model hosted with Capella.
		Id string `json:"id"`

		// ModelName The name of the model hosted with Capella.
		ModelName string `json:"modelName"`

		// PrivateEndpointEnabled Specifies whether the private endpoint is enabled for the capella hosted model.
		PrivateEndpointEnabled bool `json:"privateEndpointEnabled"`
	} `json:"capellaHostedModel"`
}

// VectorizationConfigCreation_EmbeddingModel defines model for VectorizationConfigCreation.EmbeddingModel.
type VectorizationConfigCreation_EmbeddingModel struct {
	union json.RawMessage
}

// WeeklySchedule Schedule a full backup once a week with regular incrementals.
type WeeklySchedule struct {
	// CostOptimizedRetention Optimize backup retention to reduce total cost of ownership (TCO). This gives the option to keep all but the last backup cycle of the month for thirty days; the last cycle will be kept for the defined retention period. To learn more, see [Cost Optimized Retention Policy](https://docs.couchbase.com/cloud/clusters/backup-restore.html#cost-optimized-retention-policy).
	CostOptimizedRetention bool `json:"costOptimizedRetention"`

	// DayOfWeek Day of the week for the backup.
	DayOfWeek string `json:"dayOfWeek"`

	// IncrementalEvery Interval in hours for incremental backup.
	IncrementalEvery int `json:"incrementalEvery"`

	// RetentionTime Retention time in days.
	RetentionTime string `json:"retentionTime"`

	// StartAt Start at hour (in 24-Hour format).
	StartAt int `json:"startAt"`
}

// Collections Optional list of collections under the scope.
type Collections = []string

// Datadog defines model for datadog.
type Datadog struct {
	// ApiKey The API key for authentication
	ApiKey string `json:"apiKey"`

	// Url The DataDog log ingestion URL
	Url string `json:"url"`
}

// Elastic defines model for elastic.
type Elastic struct {
	// Password The password for the Elasticsearch log collector
	Password string `json:"password"`

	// Url The URL for the Elasticsearch log collector
	Url string `json:"url"`

	// User The username for the Elasticsearch log collector
	User string `json:"user"`
}

// Exclude defines model for exclude.
type Exclude struct {
	// AppServices The list of app service IDs of the app services to be excluded from the alert integration.
	AppServices *[]string `json:"appServices,omitempty"`

	// Clusters The list of cluster IDs of the clusters to be excluded from the alert integration.
	Clusters *[]string `json:"clusters,omitempty"`
}

// Filter Filter contains the replication settings which are passed to the Couchbase server API while creating a replication.
type Filter struct {
	DocumentExcludeOptions *struct {
		// Binary When true, binary documents are filtered.
		Binary *bool `json:"binary,omitempty"`

		// Deletion When true, deletions are filtered out.
		Deletion *bool `json:"deletion,omitempty"`

		// Expiration When true, expirations are filtered out.
		Expiration *bool `json:"expiration,omitempty"`

		// Ttl When true, TTL value is removed from the replicated documents.
		Ttl *bool `json:"ttl,omitempty"`
	} `json:"documentExcludeOptions,omitempty"`
	Expressions *struct {
		// RegEx Filter expression to match documents.
		RegEx *string `json:"regEx,omitempty"`

		// SkipRestream If true, updated filter applies only to new mutations.
		// If false, replication restarts with updated filter.
		SkipRestream *bool `json:"skipRestream,omitempty"`
	} `json:"expressions,omitempty"`
}

// GenericHttp defines model for generic_http.
type GenericHttp struct {
	// Password The password for HTTP authentication, if required
	Password *string `json:"password,omitempty"`

	// Url The URL for a generic HTTP log collector
	Url string `json:"url"`

	// User The username for HTTP authentication, if required
	User *string `json:"user,omitempty"`
}

// GetFilter Filter contains the replication settings which are passed to the Couchbase server API while creating a replication.
type GetFilter struct {
	DocumentExcludeOptions *struct {
		// Binary When true, binary documents are filtered.
		Binary *bool `json:"binary,omitempty"`

		// Deletion When true, deletions are filtered out.
		Deletion *bool `json:"deletion,omitempty"`

		// Expiration When true, expirations are filtered out.
		Expiration *bool `json:"expiration,omitempty"`

		// Ttl When true, TTL value is removed from the replicated documents.
		Ttl *bool `json:"ttl,omitempty"`
	} `json:"documentExcludeOptions,omitempty"`
	Expressions *struct {
		// RegEx Filter expression to match documents.
		RegEx *string `json:"regEx,omitempty"`
	} `json:"expressions,omitempty"`
}

// Loki defines model for loki.
type Loki struct {
	// Password The password for the Grafana Loki log collector
	Password string `json:"password"`

	// Url The URL for the Grafana Loki log collector
	Url string `json:"url"`

	// User The username for the Grafana Loki log collector
	User string `json:"user"`
}

// Mappings Defines mappings from source to target scopes and collections.
// This field is only required if you are replicating specific scopes and collections.
//
// Note: If the collections array is empty or omitted, it implies all collections under that scope would be replicated.
type Mappings = []struct {
	Collections *[]struct {
		SourceCollection string `json:"sourceCollection"`
		TargetCollection string `json:"targetCollection"`
	} `json:"collections,omitempty"`
	SourceScope string `json:"sourceScope"`
	TargetScope string `json:"targetScope"`
}

// ReplicationSource Source contains all the metadata about a replication source.
type ReplicationSource struct {
	// Bucket Bucket contains the metadata for the source from which the replication is established.
	Bucket struct {
		ConflictResolutionType string `json:"conflictResolutionType"`
		Id                     string `json:"id"`
		Name                   string `json:"name"`
	} `json:"bucket"`

	// Cluster Cluster contains the metadata for the source from which the replication is established.
	Cluster struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	} `json:"cluster"`

	// Project Project contains the metadata for the source from which the replication is established.
	Project struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	} `json:"project"`

	// Scopes Scopes and collections details for the cluster. Empty for full bucket replication.
	Scopes *Scopes `json:"scopes,omitempty"`

	// Type Type tells us if the source cluster is capella or external.
	Type *ReplicationSourceType `json:"type,omitempty"`
}

// ReplicationSourceType Type tells us if the source cluster is capella or external.
type ReplicationSourceType string

// ReplicationSummary defines model for replicationSummary.
type ReplicationSummary struct {
	Audit ReplicationAuditData `json:"audit"`

	// Direction Direction specifies the replication flow — whether it's oneWay (source to target only) or twoWay (also from target back to source).
	Direction *ReplicationSummaryDirection `json:"direction,omitempty"`

	// Id The ID of the specified replication.
	Id string `json:"id"`

	// SourceCluster The name of the source cluster.
	SourceCluster string `json:"sourceCluster"`

	// Status The status of the replication.
	Status ReplicationSummaryStatus `json:"status"`

	// TargetCluster The name of the target cluster.
	TargetCluster string `json:"targetCluster"`
}

// ReplicationSummaryDirection Direction specifies the replication flow — whether it's oneWay (source to target only) or twoWay (also from target back to source).
type ReplicationSummaryDirection string

// ReplicationSummaryStatus The status of the replication.
type ReplicationSummaryStatus string

// ReplicationTarget Target contains all the metadata about a replication target.
type ReplicationTarget struct {
	// Bucket Bucket contains the metadata for the destination to which the replication is established.
	Bucket struct {
		ConflictResolutionType *string `json:"conflictResolutionType,omitempty"`
		Id                     string  `json:"id"`
		Name                   string  `json:"name"`
	} `json:"bucket"`

	// Cluster Cluster contains the metadata for the destination to which the replication is established.
	Cluster struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	} `json:"cluster"`

	// Project Project contains the metadata for the destination to which the replication is established.
	Project *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"project,omitempty"`

	// Scopes Scopes and collections details for the cluster. Empty for full bucket replication.
	Scopes *Scopes `json:"scopes,omitempty"`

	// Type Type tells us if the target cluster is capella or external.
	Type ReplicationTargetType `json:"type"`
}

// ReplicationTargetType Type tells us if the target cluster is capella or external.
type ReplicationTargetType string

// Scopes Scopes and collections details for the cluster. Empty for full bucket replication.
type Scopes = []struct {
	// Collections Optional list of collections under the scope.
	Collections *Collections `json:"collections,omitempty"`
	Name        *string      `json:"name,omitempty"`
}

// Sumologic defines model for sumologic.
type Sumologic struct {
	// Url The SumoLogic signed URL for the log ingestion
	Url string `json:"url"`
}

// APIKeysSortBy defines model for APIKeysSortBy.
type APIKeysSortBy = []string

// AccessKey defines model for AccessKey.
type AccessKey = string

// AlertIntegrationId defines model for AlertIntegrationId.
type AlertIntegrationId = openapi_types.UUID

// AllowedCidrId defines model for AllowedCidrId.
type AllowedCidrId = openapi_types.UUID

// AllowedCidrsSortBy defines model for AllowedCidrsSortBy.
type AllowedCidrsSortBy = []string

// AnalyticsClusterId defines model for AnalyticsClusterId.
type AnalyticsClusterId = openapi_types.UUID

// AnalyticsClustersSortBy defines model for AnalyticsClustersSortBy.
type AnalyticsClustersSortBy = []string

// AppServiceId defines model for AppServiceId.
type AppServiceId = openapi_types.UUID

// AppServicesSortBy defines model for AppServicesSortBy.
type AppServicesSortBy = []string

// AuditLogExportId defines model for AuditLogExportId.
type AuditLogExportId = string

// BackupId defines model for BackupId.
type BackupId = openapi_types.UUID

// BucketId defines model for BucketId.
type BucketId = string

// BucketQueryParameter defines model for BucketQueryParameter.
type BucketQueryParameter = string

// CMEKId defines model for CMEKId.
type CMEKId = openapi_types.UUID

// CPUserId defines model for CPUserId.
type CPUserId = openapi_types.UUID

// CertificateId defines model for CertificateId.
type CertificateId = openapi_types.UUID

// CloudSnapshotBackupsSortBy defines model for CloudSnapshotBackupsSortBy.
type CloudSnapshotBackupsSortBy = []string

// ClusterId defines model for ClusterId.
type ClusterId = openapi_types.UUID

// ClusterIds defines model for ClusterIds.
type ClusterIds = []openapi_types.UUID

// ClustersSortBy defines model for ClustersSortBy.
type ClustersSortBy = []string

// CollectionName defines model for CollectionName.
type CollectionName = string

// CollectionQueryParameter defines model for CollectionQueryParameter.
type CollectionQueryParameter = string

// ColumnarAnalyticsBackupsSortBy defines model for ColumnarAnalyticsBackupsSortBy.
type ColumnarAnalyticsBackupsSortBy = []string

// ColumnarAnalyticsRestoresSortBy defines model for ColumnarAnalyticsRestoresSortBy.
type ColumnarAnalyticsRestoresSortBy = []string

// CycleId defines model for CycleId.
type CycleId = openapi_types.UUID

// DatabaseCredentialsSortBy defines model for DatabaseCredentialsSortBy.
type DatabaseCredentialsSortBy = []string

// EndDate Filter to fetch bucket backups.
type EndDate = openapi_types.Date

// EndpointID defines model for EndpointID.
type EndpointID = string

// EventId defines model for EventId.
type EventId = openapi_types.UUID

// EventsSortBy defines model for EventsSortBy.
type EventsSortBy = []string

// FileStatus defines model for FileStatus.
type FileStatus string

// From defines model for From.
type From = time.Time

// IfMatch defines model for If-Match.
type IfMatch = string

// IndexName defines model for IndexName.
type IndexName = string

// ModelAPIKeyId defines model for ModelAPIKeyId.
type ModelAPIKeyId = openapi_types.UUID

// ModelId defines model for ModelId.
type ModelId = openapi_types.UUID

// OIDCProviderId defines model for OIDCProviderId.
type OIDCProviderId = openapi_types.UUID

// OrganizationId defines model for OrganizationId.
type OrganizationId = openapi_types.UUID

// Page defines model for Page.
type Page = int

// PeerId defines model for PeerId.
type PeerId = openapi_types.UUID

// PerPage defines model for PerPage.
type PerPage = int

// ProjectId defines model for ProjectId.
type ProjectId = openapi_types.UUID

// ProjectIdQuery defines model for ProjectIdQuery.
type ProjectIdQuery = openapi_types.UUID

// ProjectIds defines model for ProjectIds.
type ProjectIds = []openapi_types.UUID

// ProjectLevelCloudSnapshotBackupsSortBy defines model for ProjectLevelCloudSnapshotBackupsSortBy.
type ProjectLevelCloudSnapshotBackupsSortBy = []string

// ProjectsSortBy defines model for ProjectsSortBy.
type ProjectsSortBy = []string

// ProviderId defines model for ProviderId.
type ProviderId = string

// ProviderType defines model for ProviderType.
type ProviderType string

// ReplicationId defines model for ReplicationId.
type ReplicationId = string

// ReplicationsSortBy defines model for ReplicationsSortBy.
type ReplicationsSortBy = []string

// ScopeName defines model for ScopeName.
type ScopeName = string

// ScopeQueryParameter defines model for ScopeQueryParameter.
type ScopeQueryParameter = string

// SeverityLevels defines model for SeverityLevels.
type SeverityLevels = []string

// SortDirection defines model for SortDirection.
type SortDirection string

// StartDate Filter to fetch bucket backups.
type StartDate = openapi_types.Date

// Tags defines model for Tags.
type Tags = []string

// To defines model for To.
type To = time.Time

// UserId defines model for UserId.
type UserId = openapi_types.UUID

// UserIds defines model for UserIds.
type UserIds = []openapi_types.UUID

// UsersSortBy defines model for UsersSortBy.
type UsersSortBy = []string

// WorkflowId defines model for WorkflowId.
type WorkflowId = openapi_types.UUID

// WorkflowRunId defines model for WorkflowRunId.
type WorkflowRunId = openapi_types.UUID

// AppEndpointId defines model for appEndpointId.
type AppEndpointId = string

// AppEndpointKeyspace defines model for appEndpointKeyspace.
type AppEndpointKeyspace = string

// AccessForbidden defines model for AccessForbidden.
type AccessForbidden = Error

// AppEndpointAccessForbidden defines model for AppEndpointAccessForbidden.
type AppEndpointAccessForbidden = Error

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Conflict defines model for Conflict.
type Conflict = Error

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = Error

// IndexNotFound defines model for IndexNotFound.
type IndexNotFound = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotImplemented defines model for NotImplemented.
type NotImplemented = Error

// PreconditionFailed defines model for PreconditionFailed.
type PreconditionFailed = Error

// RateLimitExceeded defines model for RateLimitExceeded.
type RateLimitExceeded = Error

// ResourceNotFound defines model for ResourceNotFound.
type ResourceNotFound = Error

// ServiceUnavailable defines model for ServiceUnavailable.
type ServiceUnavailable = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// UnprocessableContent defines model for UnprocessableContent.
type UnprocessableContent = Error

// ListModelsParams defines parameters for ListModels.
type ListModelsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// ModelStatus Filter by model status. All models are returned when set empty.
	ModelStatus *ListModelsParamsModelStatus `form:"modelStatus,omitempty" json:"modelStatus,omitempty"`

	// ModelKind Filter by model kind. All models are returned when this is set empty.
	ModelKind *ListModelsParamsModelKind `form:"modelKind,omitempty" json:"modelKind,omitempty"`
}

// ListModelsParamsModelStatus defines parameters for ListModels.
type ListModelsParamsModelStatus string

// ListModelsParamsModelKind defines parameters for ListModels.
type ListModelsParamsModelKind string

// CreateModelJSONBody defines parameters for CreateModel.
type CreateModelJSONBody struct {
	// Caching Caching configuration for the model. Caching improves system efficiency by caching frequently accessed data, both at the conversational level (storing request-specific conversation history) and at the semantic level (saving the embeddings for queries and results), ensuring optimal performance while managing memory costs effectively. Supports multiple caching strategies for improved response times and reduced strain on backend LLM services.
	Caching *Caching `json:"caching,omitempty"`

	// CatalogModelName Name of the model deployed from the model catalog.
	CatalogModelName string `json:"catalogModelName"`

	// CloudConfig The cloud configuration for the model.
	CloudConfig CloudConfig `json:"cloudConfig"`

	// Dimensions Dimensions specify the vector dimensions for the underlying embedding model.
	Dimensions *int `json:"dimensions,omitempty"`

	// Guardrails Guardrails as a base-64 encoded string.
	Guardrails *[]string `json:"guardrails,omitempty"`

	// IsBatchingEnabled Option to enable batching.
	IsBatchingEnabled *bool `json:"isBatchingEnabled,omitempty"`

	// Jailbreak Jailbreak model information.
	Jailbreak *struct {
		// ScoreThreshold The score threshold for the jailbreak model. The value should be > 0.
		ScoreThreshold *float64 `json:"scoreThreshold,omitempty"`
	} `json:"jailbreak,omitempty"`

	// KeywordFiltering Keywords in a comma-separated string to filter the input.
	KeywordFiltering *[]string `json:"keywordFiltering,omitempty"`

	// Name Name of the model.
	Name string `json:"name"`

	// Optimization Optimization profile option for the model.
	Optimization *CreateModelJSONBodyOptimization `json:"optimization,omitempty"`

	// Quantization Quantization options for the model. Options include 8-bit, 16bit, and full-precision.
	Quantization *CreateModelJSONBodyQuantization `json:"quantization,omitempty"`
}

// CreateModelJSONBodyOptimization defines parameters for CreateModel.
type CreateModelJSONBodyOptimization string

// CreateModelJSONBodyQuantization defines parameters for CreateModel.
type CreateModelJSONBodyQuantization string

// ListModelAPIKeysParams defines parameters for ListModelAPIKeys.
type ListModelAPIKeysParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`
}

// ListProvidersParams defines parameters for ListProviders.
type ListProvidersParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// ProviderType Type of provider to filter on. By default all providers are returned.
	ProviderType *ListProvidersParamsProviderType `form:"providerType,omitempty" json:"providerType,omitempty"`
}

// ListProvidersParamsProviderType defines parameters for ListProviders.
type ListProvidersParamsProviderType string

// UpdateProviderParams defines parameters for UpdateProvider.
type UpdateProviderParams struct {
	// IfMatch A precondition header that specifies the entity tag of a resource.
	IfMatch *IfMatch `json:"If-Match,omitempty"`
}

// ListOrganizationLevelAnalyticsClustersParams defines parameters for ListOrganizationLevelAnalyticsClusters.
type ListOrganizationLevelAnalyticsClustersParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **cloudProvider**, **name**.
	SortBy *AnalyticsClustersSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListOrganizationLevelAnalyticsClustersParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListOrganizationLevelAnalyticsClustersParamsSortDirection defines parameters for ListOrganizationLevelAnalyticsClusters.
type ListOrganizationLevelAnalyticsClustersParamsSortDirection string

// ListOrganizationAPIKeysParams defines parameters for ListOrganizationAPIKeys.
type ListOrganizationAPIKeysParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy  Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **name**, **expiry**, **description**.
	SortBy *APIKeysSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListOrganizationAPIKeysParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListOrganizationAPIKeysParamsSortDirection defines parameters for ListOrganizationAPIKeys.
type ListOrganizationAPIKeysParamsSortDirection string

// ListAppServicesParams defines parameters for ListAppServices.
type ListAppServicesParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy  Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **name**, **id**, **description**.
	SortBy *AppServicesSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListAppServicesParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`

	// ProjectId The GUID4 ID of the project.
	ProjectId *ProjectIdQuery `form:"projectId,omitempty" json:"projectId,omitempty"`
}

// ListAppServicesParamsSortDirection defines parameters for ListAppServices.
type ListAppServicesParamsSortDirection string

// GetKeyMetadataListParams defines parameters for GetKeyMetadataList.
type GetKeyMetadataListParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order of how you would like to sort the results and the key you would like to order by.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *GetKeyMetadataListParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// GetKeyMetadataListParamsSortDirection defines parameters for GetKeyMetadataList.
type GetKeyMetadataListParamsSortDirection string

// ListCMEKHistoryParams defines parameters for ListCMEKHistory.
type ListCMEKHistoryParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **active**, **associatedAt**, **associatedBy**, **key**
	SortBy *ListCMEKHistoryParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListCMEKHistoryParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListCMEKHistoryParamsSortBy defines parameters for ListCMEKHistory.
type ListCMEKHistoryParamsSortBy string

// ListCMEKHistoryParamsSortDirection defines parameters for ListCMEKHistory.
type ListCMEKHistoryParamsSortDirection string

// PutOrganizationConfigurationParams defines parameters for PutOrganizationConfiguration.
type PutOrganizationConfigurationParams struct {
	// IfMatch A precondition header that specifies the entity tag of a resource.
	IfMatch *IfMatch `json:"If-Match,omitempty"`
}

// ListEventsParams defines parameters for ListEvents.
type ListEventsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy  Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **severity**, **timestamp**.
	SortBy *EventsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListEventsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`

	// UserIds Filter by user UUID. Default is to return events corresponding to all users.
	UserIds *UserIds `form:"userIds,omitempty" json:"userIds,omitempty"`

	// ClusterIds List of clusterIds to filter on. By default events corresponding to all clusters are returned.
	ClusterIds *ClusterIds `form:"clusterIds,omitempty" json:"clusterIds,omitempty"`

	// ProjectIds The GUID4 ID of projects to filter on. By default, events corresponding to all projects are returned
	ProjectIds *ProjectIds `form:"projectIds,omitempty" json:"projectIds,omitempty"`

	// SeverityLevels Filter by severity levels. Default is to return events corresponding to all supported severity levels.
	SeverityLevels *SeverityLevels `form:"severityLevels,omitempty" json:"severityLevels,omitempty"`

	// Tags Filter by tags. Default is to return events corresponding to all supported tag. Tags are **availability**, **billing**, **maintenance**, **performance**, **security**, **alert**.
	Tags *Tags `form:"tags,omitempty" json:"tags,omitempty"`

	// From Start date in  RFC3339 format. If not provided, events starting from last 24 hours are returned.
	From *From `form:"from,omitempty" json:"from,omitempty"`

	// To End datetime in the last 24 hours, RFC3339 format. Defaults to Now.
	To *To `form:"to,omitempty" json:"to,omitempty"`
}

// ListEventsParamsSortBy defines parameters for ListEvents.
type ListEventsParamsSortBy string

// ListEventsParamsSortDirection defines parameters for ListEvents.
type ListEventsParamsSortDirection string

// ListEventsParamsSeverityLevels defines parameters for ListEvents.
type ListEventsParamsSeverityLevels string

// ListEventsParamsTags defines parameters for ListEvents.
type ListEventsParamsTags string

// ListProjectsParams defines parameters for ListProjects.
type ListProjectsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **name**.
	SortBy *ProjectsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListProjectsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListProjectsParamsSortDirection defines parameters for ListProjects.
type ListProjectsParamsSortDirection string

// PutProjectParams defines parameters for PutProject.
type PutProjectParams struct {
	// IfMatch A precondition header that specifies the entity tag of a resource.
	IfMatch *IfMatch `json:"If-Match,omitempty"`
}

// PostTestAlertIntegrationJSONBody defines parameters for PostTestAlertIntegration.
type PostTestAlertIntegrationJSONBody struct {
	Config RequestConfig `json:"config"`

	// Kind Type of alert integration, currently supports only 'webhook'.
	Kind PostTestAlertIntegrationJSONBodyKind `json:"kind"`
}

// PostTestAlertIntegrationJSONBodyKind defines parameters for PostTestAlertIntegration.
type PostTestAlertIntegrationJSONBodyKind string

// ListAlertIntegrationsParams defines parameters for ListAlertIntegrations.
type ListAlertIntegrationsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **name**.
	SortBy *ProjectsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListAlertIntegrationsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListAlertIntegrationsParamsSortDirection defines parameters for ListAlertIntegrations.
type ListAlertIntegrationsParamsSortDirection string

// ListProjectLevelAnalyticsClustersParams defines parameters for ListProjectLevelAnalyticsClusters.
type ListProjectLevelAnalyticsClustersParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **cloudProvider**, **name**.
	SortBy *AnalyticsClustersSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListProjectLevelAnalyticsClustersParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListProjectLevelAnalyticsClustersParamsSortDirection defines parameters for ListProjectLevelAnalyticsClusters.
type ListProjectLevelAnalyticsClustersParamsSortDirection string

// PutAnalyticsClusterParams defines parameters for PutAnalyticsCluster.
type PutAnalyticsClusterParams struct {
	// IfMatch A precondition header that specifies the entity tag of a resource.
	IfMatch *IfMatch `json:"If-Match,omitempty"`
}

// ListAnalyticsAllowedCidrsParams defines parameters for ListAnalyticsAllowedCidrs.
type ListAnalyticsAllowedCidrsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy  Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **type**, **status**.
	SortBy *AllowedCidrsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListAnalyticsAllowedCidrsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListAnalyticsAllowedCidrsParamsSortDirection defines parameters for ListAnalyticsAllowedCidrs.
type ListAnalyticsAllowedCidrsParamsSortDirection string

// ListColumnarAnalyticsBackupsParams defines parameters for ListColumnarAnalyticsBackups.
type ListColumnarAnalyticsBackupsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order in which you would like to sort the results and the key you would like to sort by. Valid fields to sort the results are: **id**, **createdAt**, **expiration**, **retention**, **size**, **type**.
	SortBy *ColumnarAnalyticsBackupsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListColumnarAnalyticsBackupsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListColumnarAnalyticsBackupsParamsSortDirection defines parameters for ListColumnarAnalyticsBackups.
type ListColumnarAnalyticsBackupsParamsSortDirection string

// ListColumnarAnalyticsRestoresParams defines parameters for ListColumnarAnalyticsRestores.
type ListColumnarAnalyticsRestoresParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order in which you would like to sort the results and the key you would like to sort by. Valid fields to sort the results are: **id**, **createdAt**
	SortBy *ColumnarAnalyticsRestoresSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListColumnarAnalyticsRestoresParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListColumnarAnalyticsRestoresParamsSortDirection defines parameters for ListColumnarAnalyticsRestores.
type ListColumnarAnalyticsRestoresParamsSortDirection string

// ListProjectLevelCloudSnapshotBackupsParams defines parameters for ListProjectLevelCloudSnapshotBackups.
type ListProjectLevelCloudSnapshotBackupsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Specifies the sorting criteria for the results, including the key by which the results should be ordered. Valid fields to sort the results include the following. - **creationDateTime** - **createdBy** - **currentStatus** - **cloudProvider** - **region**
	// Provide the desired fields in the order of sorting preference.
	SortBy *ProjectLevelCloudSnapshotBackupsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListProjectLevelCloudSnapshotBackupsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListProjectLevelCloudSnapshotBackupsParamsSortBy defines parameters for ListProjectLevelCloudSnapshotBackups.
type ListProjectLevelCloudSnapshotBackupsParamsSortBy string

// ListProjectLevelCloudSnapshotBackupsParamsSortDirection defines parameters for ListProjectLevelCloudSnapshotBackups.
type ListProjectLevelCloudSnapshotBackupsParamsSortDirection string

// ListClustersParams defines parameters for ListClusters.
type ListClustersParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **availability**, **cloudProvider**, **couchbaseServer**, **currentState**, **name**.
	SortBy *ClustersSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListClustersParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListClustersParamsSortDirection defines parameters for ListClusters.
type ListClustersParamsSortDirection string

// UpdateFreeTierClusterParams defines parameters for UpdateFreeTierCluster.
type UpdateFreeTierClusterParams struct {
	// IfMatch A precondition header that specifies the entity tag of a resource.
	IfMatch *IfMatch `json:"If-Match,omitempty"`
}

// DeleteClusterParams defines parameters for DeleteCluster.
type DeleteClusterParams struct {
	// Retainsnapshotbackups Retain snapshot backups parameter specifies whether to retain snapshot backups after cluster deletion.
	Retainsnapshotbackups *bool `form:"retainsnapshotbackups,omitempty" json:"retainsnapshotbackups,omitempty"`
}

// PutClusterParams defines parameters for PutCluster.
type PutClusterParams struct {
	// IfMatch A precondition header that specifies the entity tag of a resource.
	IfMatch *IfMatch `json:"If-Match,omitempty"`
}

// ListAiWorkflowsParams defines parameters for ListAiWorkflows.
type ListAiWorkflowsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`
}

// ListAiWorkflowRunsParams defines parameters for ListAiWorkflowRuns.
type ListAiWorkflowRunsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`
}

// GetAiWorkflowRunProcessedFilesParams defines parameters for GetAiWorkflowRunProcessedFiles.
type GetAiWorkflowRunProcessedFilesParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// FileStatus The type of file status used for filtering. By default, all files are returned.
	FileStatus *GetAiWorkflowRunProcessedFilesParamsFileStatus `form:"fileStatus,omitempty" json:"fileStatus,omitempty"`
}

// GetAiWorkflowRunProcessedFilesParamsFileStatus defines parameters for GetAiWorkflowRunProcessedFiles.
type GetAiWorkflowRunProcessedFilesParamsFileStatus string

// ListAllowedCidrsParams defines parameters for ListAllowedCidrs.
type ListAllowedCidrsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy  Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **type**, **status**.
	SortBy *AllowedCidrsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListAllowedCidrsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListAllowedCidrsParamsSortDirection defines parameters for ListAllowedCidrs.
type ListAllowedCidrsParamsSortDirection string

// UpdateFreeTierAppServiceParams defines parameters for UpdateFreeTierAppService.
type UpdateFreeTierAppServiceParams struct {
	// IfMatch A precondition header that specifies the entity tag of a resource.
	IfMatch *IfMatch `json:"If-Match,omitempty"`
}

// PutAppServiceParams defines parameters for PutAppService.
type PutAppServiceParams struct {
	// IfMatch A precondition header that specifies the entity tag of a resource.
	IfMatch *IfMatch `json:"If-Match,omitempty"`
}

// ListAppServiceAdminUsersParams defines parameters for ListAppServiceAdminUsers.
type ListAppServiceAdminUsersParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListAppServiceAdminUsersParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListAppServiceAdminUsersParamsSortDirection defines parameters for ListAppServiceAdminUsers.
type ListAppServiceAdminUsersParamsSortDirection string

// UpdateAppServiceAdminUserJSONBody defines parameters for UpdateAppServiceAdminUser.
type UpdateAppServiceAdminUserJSONBody struct {
	union json.RawMessage
}

// ListAppServiceAllowedCidrsParams defines parameters for ListAppServiceAllowedCidrs.
type ListAppServiceAllowedCidrsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy  Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **type**, **status**.
	SortBy *AllowedCidrsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListAppServiceAllowedCidrsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListAppServiceAllowedCidrsParamsSortDirection defines parameters for ListAppServiceAllowedCidrs.
type ListAppServiceAllowedCidrsParamsSortDirection string

// PostAppServiceAllowedCidrJSONBody defines parameters for PostAppServiceAllowedCidr.
type PostAppServiceAllowedCidrJSONBody struct {
	// Cidr The trusted CIDR to allow network connections from. The example
	// represents a single IP address (i.e. a subnet mask of 32).
	Cidr string `json:"cidr"`

	// Comment A short description of the allowed CIDR.
	Comment *string `json:"comment,omitempty"`

	// ExpiresAt An RFC3339 timestamp determining when the allowed CIDR should expire.
	// If this field is empty/omitted then the allowed CIDR is permanent and will never automatically expire.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
}

// ListAppEndpointsParams defines parameters for ListAppEndpoints.
type ListAppEndpointsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListAppEndpointsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`

	// SortBy  Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **name**, **offline**, **bucket**.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`
}

// ListAppEndpointsParamsSortDirection defines parameters for ListAppEndpoints.
type ListAppEndpointsParamsSortDirection string

// ListAppEndpointAdminUsersParams defines parameters for ListAppEndpointAdminUsers.
type ListAppEndpointAdminUsersParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListAppEndpointAdminUsersParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListAppEndpointAdminUsersParamsSortDirection defines parameters for ListAppEndpointAdminUsers.
type ListAppEndpointAdminUsersParamsSortDirection string

// ListAppEndpointCollectionsParams defines parameters for ListAppEndpointCollections.
type ListAppEndpointCollectionsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListAppEndpointCollectionsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListAppEndpointCollectionsParamsSortDirection defines parameters for ListAppEndpointCollections.
type ListAppEndpointCollectionsParamsSortDirection string

// ListAppEndpointOIDCProvidersParams defines parameters for ListAppEndpointOIDCProviders.
type ListAppEndpointOIDCProvidersParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListAppEndpointOIDCProvidersParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListAppEndpointOIDCProvidersParamsSortDirection defines parameters for ListAppEndpointOIDCProviders.
type ListAppEndpointOIDCProvidersParamsSortDirection string

// ListAppServiceAuditLogExportsParams defines parameters for ListAppServiceAuditLogExports.
type ListAppServiceAuditLogExportsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListAppServiceAuditLogExportsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListAppServiceAuditLogExportsParamsSortDirection defines parameters for ListAppServiceAuditLogExports.
type ListAppServiceAuditLogExportsParamsSortDirection string

// GetAppServicePrivateEndpointsCommandJSONBody defines parameters for GetAppServicePrivateEndpointsCommand.
type GetAppServicePrivateEndpointsCommandJSONBody struct {
	union json.RawMessage
}

// ListAuditLogExportsParams defines parameters for ListAuditLogExports.
type ListAuditLogExportsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`
}

// ListCyclesParams defines parameters for ListCycles.
type ListCyclesParams struct {
	// StartDate Filters bucket backups beginning from the start date.
	// Specify the start date to retrieve relevant bucket backups from start date.
	StartDate *StartDate `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate Filters bucket backups till the end date.
	// Specify the end date to retrieve relevant bucket backups till end date.
	EndDate *EndDate `form:"endDate,omitempty" json:"endDate,omitempty"`
}

// ListCloudSnapshotBackupsParams defines parameters for ListCloudSnapshotBackups.
type ListCloudSnapshotBackupsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **createdAt**, **expiration**, **retention**, **sizee**, **type**.
	SortBy *CloudSnapshotBackupsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListCloudSnapshotBackupsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListCloudSnapshotBackupsParamsSortDirection defines parameters for ListCloudSnapshotBackups.
type ListCloudSnapshotBackupsParamsSortDirection string

// ListCloudSnapshotRestoresParams defines parameters for ListCloudSnapshotRestores.
type ListCloudSnapshotRestoresParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **createdAt**, **expiration**, **retention**, **sizee**, **type**.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListCloudSnapshotRestoresParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListCloudSnapshotRestoresParamsSortDirection defines parameters for ListCloudSnapshotRestores.
type ListCloudSnapshotRestoresParamsSortDirection string

// UpdateDataApiAndPeeringJSONBody defines parameters for UpdateDataApiAndPeering.
type UpdateDataApiAndPeeringJSONBody struct {
	// EnableDataApi enable or disable Data API for the cluster.
	EnableDataApi bool `json:"enableDataApi"`

	// EnableNetworkPeering enable or disable network peering when Data API is enabled.
	EnableNetworkPeering bool `json:"enableNetworkPeering"`
}

// GetDataAPIPrivateEndpointCommandJSONBody defines parameters for GetDataAPIPrivateEndpointCommand.
type GetDataAPIPrivateEndpointCommandJSONBody struct {
	union json.RawMessage
}

// ListMtlsCertificatesParams defines parameters for ListMtlsCertificates.
type ListMtlsCertificatesParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **availability**, **cloudProvider**, **couchbaseServer**, **currentState**, **name**.
	SortBy *ClustersSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListMtlsCertificatesParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListMtlsCertificatesParamsSortDirection defines parameters for ListMtlsCertificates.
type ListMtlsCertificatesParamsSortDirection string

// ListNetworkPeeringRecordsParams defines parameters for ListNetworkPeeringRecords.
type ListNetworkPeeringRecordsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **name**, **status**.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListNetworkPeeringRecordsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListNetworkPeeringRecordsParamsSortDirection defines parameters for ListNetworkPeeringRecords.
type ListNetworkPeeringRecordsParamsSortDirection string

// GetPrivateEndpointCommandJSONBody defines parameters for GetPrivateEndpointCommand.
type GetPrivateEndpointCommandJSONBody struct {
	union json.RawMessage
}

// IndexBuildStatusParams defines parameters for IndexBuildStatus.
type IndexBuildStatusParams struct {
	// Bucket Specifies the bucket part of the key space.
	// To learn more about scopes and collections, see [Buckets, Scopes, and Collections](https://docs.couchbase.com/cloud/clusters/data-service/about-buckets-scopes-collections.html).
	Bucket BucketQueryParameter `form:"bucket" json:"bucket"`

	// Scope Specifies the scope part of the key space. If unspecified, this will be the default scope.
	// To learn more about scopes and collections, see [Buckets, Scopes, and Collections](https://docs.couchbase.com/cloud/clusters/data-service/about-buckets-scopes-collections.html).
	Scope *ScopeQueryParameter `form:"scope,omitempty" json:"scope,omitempty"`

	// Collection Specifies the collection part of the key space. If unspecified, this will be the default collection.
	// To learn more about scopes and collections, see [Buckets, Scopes, and Collections](https://docs.couchbase.com/cloud/clusters/data-service/about-buckets-scopes-collections.html).
	Collection *CollectionQueryParameter `form:"collection,omitempty" json:"collection,omitempty"`
}

// ListIndexDefinitionsParams defines parameters for ListIndexDefinitions.
type ListIndexDefinitionsParams struct {
	// Bucket Specifies the bucket part of the key space.
	// To learn more about scopes and collections, see [Buckets, Scopes, and Collections](https://docs.couchbase.com/cloud/clusters/data-service/about-buckets-scopes-collections.html).
	Bucket BucketQueryParameter `form:"bucket" json:"bucket"`

	// Scope Specifies the scope part of the key space. If unspecified, this will be the default scope.
	// To learn more about scopes and collections, see [Buckets, Scopes, and Collections](https://docs.couchbase.com/cloud/clusters/data-service/about-buckets-scopes-collections.html).
	Scope *ScopeQueryParameter `form:"scope,omitempty" json:"scope,omitempty"`

	// Collection Specifies the collection part of the key space. If unspecified, this will be the default collection.
	// To learn more about scopes and collections, see [Buckets, Scopes, and Collections](https://docs.couchbase.com/cloud/clusters/data-service/about-buckets-scopes-collections.html).
	Collection *CollectionQueryParameter `form:"collection,omitempty" json:"collection,omitempty"`
}

// IndexDefinitionParams defines parameters for IndexDefinition.
type IndexDefinitionParams struct {
	// Bucket Specifies the bucket part of the key space.
	// To learn more about scopes and collections, see [Buckets, Scopes, and Collections](https://docs.couchbase.com/cloud/clusters/data-service/about-buckets-scopes-collections.html).
	Bucket BucketQueryParameter `form:"bucket" json:"bucket"`

	// Scope Specifies the scope part of the key space. If unspecified, this will be the default scope.
	// To learn more about scopes and collections, see [Buckets, Scopes, and Collections](https://docs.couchbase.com/cloud/clusters/data-service/about-buckets-scopes-collections.html).
	Scope *ScopeQueryParameter `form:"scope,omitempty" json:"scope,omitempty"`

	// Collection Specifies the collection part of the key space. If unspecified, this will be the default collection.
	// To learn more about scopes and collections, see [Buckets, Scopes, and Collections](https://docs.couchbase.com/cloud/clusters/data-service/about-buckets-scopes-collections.html).
	Collection *CollectionQueryParameter `form:"collection,omitempty" json:"collection,omitempty"`
}

// ListClusterReplicationsParams defines parameters for ListClusterReplications.
type ListClusterReplicationsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **sourceCluster**, **targetCluster**, **status**, **direction**, **priority**.
	SortBy *ReplicationsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListClusterReplicationsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListClusterReplicationsParamsSortDirection defines parameters for ListClusterReplications.
type ListClusterReplicationsParamsSortDirection string

// ListDatabaseCredentialsParams defines parameters for ListDatabaseCredentials.
type ListDatabaseCredentialsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy  Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **name**, **id**.
	SortBy *DatabaseCredentialsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListDatabaseCredentialsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListDatabaseCredentialsParamsSortDirection defines parameters for ListDatabaseCredentials.
type ListDatabaseCredentialsParamsSortDirection string

// PutDatabaseCredentialParams defines parameters for PutDatabaseCredential.
type PutDatabaseCredentialParams struct {
	// IfMatch A precondition header that specifies the entity tag of a resource.
	IfMatch *IfMatch `json:"If-Match,omitempty"`
}

// ListProjectEventsParams defines parameters for ListProjectEvents.
type ListProjectEventsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy  Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **severity**, **timestamp**.
	SortBy *EventsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListProjectEventsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`

	// UserIds Filter by user UUID. Default is to return events corresponding to all users.
	UserIds *UserIds `form:"userIds,omitempty" json:"userIds,omitempty"`

	// ClusterIds List of clusterIds to filter on. By default events corresponding to all clusters are returned.
	ClusterIds *ClusterIds `form:"clusterIds,omitempty" json:"clusterIds,omitempty"`

	// SeverityLevels Filter by severity levels. Default is to return events corresponding to all supported severity levels.
	SeverityLevels *SeverityLevels `form:"severityLevels,omitempty" json:"severityLevels,omitempty"`

	// Tags Filter by tags. Default is to return events corresponding to all supported tag. Tags are **availability**, **billing**, **maintenance**, **performance**, **security**, **alert**.
	Tags *Tags `form:"tags,omitempty" json:"tags,omitempty"`

	// From Start date in  RFC3339 format. If not provided, events starting from last 24 hours are returned.
	From *From `form:"from,omitempty" json:"from,omitempty"`

	// To End datetime in the last 24 hours, RFC3339 format. Defaults to Now.
	To *To `form:"to,omitempty" json:"to,omitempty"`
}

// ListProjectEventsParamsSortBy defines parameters for ListProjectEvents.
type ListProjectEventsParamsSortBy string

// ListProjectEventsParamsSortDirection defines parameters for ListProjectEvents.
type ListProjectEventsParamsSortDirection string

// ListProjectEventsParamsSeverityLevels defines parameters for ListProjectEvents.
type ListProjectEventsParamsSeverityLevels string

// ListProjectEventsParamsTags defines parameters for ListProjectEvents.
type ListProjectEventsParamsTags string

// ListProjectReplicationsParams defines parameters for ListProjectReplications.
type ListProjectReplicationsParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **sourceCluster**, **targetCluster**, **status**, **direction**, **priority**.
	SortBy *ReplicationsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListProjectReplicationsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`
}

// ListProjectReplicationsParamsSortDirection defines parameters for ListProjectReplications.
type ListProjectReplicationsParamsSortDirection string

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Page Sets the page you would like to view.
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Sets the number of results you would like to have on each page.
	PerPage *PerPage `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sets the order of how you would like to sort the results and the key you would like to order by. Valid fields to sort the results are: **id**, **name**, **email**, **status**, **inactive**.
	SortBy *UsersSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection The order in which the items will be sorted.
	SortDirection *ListUsersParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`

	// ProjectId The GUID4 ID of the project.
	ProjectId *ProjectIdQuery `form:"projectId,omitempty" json:"projectId,omitempty"`
}

// ListUsersParamsSortDirection defines parameters for ListUsers.
type ListUsersParamsSortDirection string

// CreateModelJSONRequestBody defines body for CreateModel for application/json ContentType.
type CreateModelJSONRequestBody CreateModelJSONBody

// CreateModelAPIKeyJSONRequestBody defines body for CreateModelAPIKey for application/json ContentType.
type CreateModelAPIKeyJSONRequestBody = CreateLanguageModelAPIKeyRequest

// CreateProviderJSONRequestBody defines body for CreateProvider for application/json ContentType.
type CreateProviderJSONRequestBody = CreateProviderRequest

// UpdateProviderJSONRequestBody defines body for UpdateProvider for application/json ContentType.
type UpdateProviderJSONRequestBody = UpdateProviderRequest

// PostOrganizationAPIKeysJSONRequestBody defines body for PostOrganizationAPIKeys for application/json ContentType.
type PostOrganizationAPIKeysJSONRequestBody = CreateAPIKeyRequest

// PostOrganizationAPIKeyRotateJSONRequestBody defines body for PostOrganizationAPIKeyRotate for application/json ContentType.
type PostOrganizationAPIKeyRotateJSONRequestBody = RotateAPIKeyRequest

// PostCMEKMetadataJSONRequestBody defines body for PostCMEKMetadata for application/json ContentType.
type PostCMEKMetadataJSONRequestBody = CreateCMEKMetadata

// RotateCMEKKeyJSONRequestBody defines body for RotateCMEKKey for application/json ContentType.
type RotateCMEKKeyJSONRequestBody = RotateCMEKKey

// PutOrganizationConfigurationJSONRequestBody defines body for PutOrganizationConfiguration for application/json ContentType.
type PutOrganizationConfigurationJSONRequestBody = UpdateOrganizationConfigurationRequest

// PostProjectJSONRequestBody defines body for PostProject for application/json ContentType.
type PostProjectJSONRequestBody = CreateProjectRequest

// PutProjectJSONRequestBody defines body for PutProject for application/json ContentType.
type PutProjectJSONRequestBody = UpdateProjectRequest

// PostTestAlertIntegrationJSONRequestBody defines body for PostTestAlertIntegration for application/json ContentType.
type PostTestAlertIntegrationJSONRequestBody PostTestAlertIntegrationJSONBody

// PostAlertIntegrationJSONRequestBody defines body for PostAlertIntegration for application/json ContentType.
type PostAlertIntegrationJSONRequestBody = CreateAlertRequest

// PutAlertIntegrationJSONRequestBody defines body for PutAlertIntegration for application/json ContentType.
type PutAlertIntegrationJSONRequestBody = UpdateAlertRequest

// CreateAnalyticsClusterJSONRequestBody defines body for CreateAnalyticsCluster for application/json ContentType.
type CreateAnalyticsClusterJSONRequestBody = CreateColumnarAnalyticsClusterRequest

// PutAnalyticsClusterJSONRequestBody defines body for PutAnalyticsCluster for application/json ContentType.
type PutAnalyticsClusterJSONRequestBody = UpdateColumnarAnalyticsClusterRequest

// PostAnalyticsAllowedCidrJSONRequestBody defines body for PostAnalyticsAllowedCidr for application/json ContentType.
type PostAnalyticsAllowedCidrJSONRequestBody = CreateAllowedCidrRequest

// UpsertColumnarAnalyticsBackupScheduleJSONRequestBody defines body for UpsertColumnarAnalyticsBackupSchedule for application/json ContentType.
type UpsertColumnarAnalyticsBackupScheduleJSONRequestBody = UpsertColumnarAnalyticsBackupScheduleRequest

// CreateColumnarAnalyticsBackupJSONRequestBody defines body for CreateColumnarAnalyticsBackup for application/json ContentType.
type CreateColumnarAnalyticsBackupJSONRequestBody = CreateColumnarAnalyticsBackupRequest

// UpdateColumnarAnalyticsBackupRetentionJSONRequestBody defines body for UpdateColumnarAnalyticsBackupRetention for application/json ContentType.
type UpdateColumnarAnalyticsBackupRetentionJSONRequestBody = EditColumnarAnalyticsBackupRetentionRequest

// PostAnalyticsOnOffScheduleJSONRequestBody defines body for PostAnalyticsOnOffSchedule for application/json ContentType.
type PostAnalyticsOnOffScheduleJSONRequestBody = ColumnarAnalyticsOnOffSchedule

// PutAnalyticsOnOffScheduleJSONRequestBody defines body for PutAnalyticsOnOffSchedule for application/json ContentType.
type PutAnalyticsOnOffScheduleJSONRequestBody = ColumnarAnalyticsOnOffSchedule

// GetColumnarPrivateEndpointServiceCommandJSONRequestBody defines body for GetColumnarPrivateEndpointServiceCommand for application/json ContentType.
type GetColumnarPrivateEndpointServiceCommandJSONRequestBody = CreatePrivateEndpointServiceCommandRequest

// CloneJSONRequestBody defines body for Clone for application/json ContentType.
type CloneJSONRequestBody = CreateCloudSnapshotCloneRequest

// PostClusterJSONRequestBody defines body for PostCluster for application/json ContentType.
type PostClusterJSONRequestBody = CreateClusterRequest

// CreateFreeTierClusterJSONRequestBody defines body for CreateFreeTierCluster for application/json ContentType.
type CreateFreeTierClusterJSONRequestBody = CreateFreeTierClusterRequest

// UpdateFreeTierClusterJSONRequestBody defines body for UpdateFreeTierCluster for application/json ContentType.
type UpdateFreeTierClusterJSONRequestBody = UpdateFreeTierClusterRequest

// PutClusterJSONRequestBody defines body for PutCluster for application/json ContentType.
type PutClusterJSONRequestBody = UpdateClusterRequest

// ClusterOnJSONRequestBody defines body for ClusterOn for application/json ContentType.
type ClusterOnJSONRequestBody = CreateClusterOnRequest

// CreateAiWorkflowJSONRequestBody defines body for CreateAiWorkflow for application/json ContentType.
type CreateAiWorkflowJSONRequestBody = CreateWorkflowRequest

// PostAllowedCidrsJSONRequestBody defines body for PostAllowedCidrs for application/json ContentType.
type PostAllowedCidrsJSONRequestBody = CreateAllowedCidrRequest

// PostAppServiceJSONRequestBody defines body for PostAppService for application/json ContentType.
type PostAppServiceJSONRequestBody = CreateAppServicerRequest

// CreateFreeTierAppServiceJSONRequestBody defines body for CreateFreeTierAppService for application/json ContentType.
type CreateFreeTierAppServiceJSONRequestBody = CreateFreeTierAppServiceRequest

// UpdateFreeTierAppServiceJSONRequestBody defines body for UpdateFreeTierAppService for application/json ContentType.
type UpdateFreeTierAppServiceJSONRequestBody = UpdateFreeTierAppServiceRequest

// PutAppServiceJSONRequestBody defines body for PutAppService for application/json ContentType.
type PutAppServiceJSONRequestBody = UpdateAppServiceRequest

// AddAppServiceAdminUserJSONRequestBody defines body for AddAppServiceAdminUser for application/json ContentType.
type AddAppServiceAdminUserJSONRequestBody = CreateAppServiceAdminUserRequest

// UpdateAppServiceAdminUserJSONRequestBody defines body for UpdateAppServiceAdminUser for application/json ContentType.
type UpdateAppServiceAdminUserJSONRequestBody UpdateAppServiceAdminUserJSONBody

// PostAppServiceAllowedCidrJSONRequestBody defines body for PostAppServiceAllowedCidr for application/json ContentType.
type PostAppServiceAllowedCidrJSONRequestBody PostAppServiceAllowedCidrJSONBody

// PostAppEndpointJSONRequestBody defines body for PostAppEndpoint for application/json ContentType.
type PostAppEndpointJSONRequestBody = CreateAppEndpointRequest

// PutAppEndpointJSONRequestBody defines body for PutAppEndpoint for application/json ContentType.
type PutAppEndpointJSONRequestBody = UpdateAppEndpointRequest

// PutAppEndpointAuditLogConfigJSONRequestBody defines body for PutAppEndpointAuditLogConfig for application/json ContentType.
type PutAppEndpointAuditLogConfigJSONRequestBody = GetAppEndpointAuditLogResponse

// PutAppEndpointCORSJSONRequestBody defines body for PutAppEndpointCORS for application/json ContentType.
type PutAppEndpointCORSJSONRequestBody = CORSConfig

// CreateAppEndpointOIDCProviderJSONRequestBody defines body for CreateAppEndpointOIDCProvider for application/json ContentType.
type CreateAppEndpointOIDCProviderJSONRequestBody = CreateOIDCProviderRequest

// UpdateAppEndpointOIDCDefaultProviderJSONRequestBody defines body for UpdateAppEndpointOIDCDefaultProvider for application/json ContentType.
type UpdateAppEndpointOIDCDefaultProviderJSONRequestBody = OIDCProviderID

// UpdateAppEndpointOIDCProviderJSONRequestBody defines body for UpdateAppEndpointOIDCProvider for application/json ContentType.
type UpdateAppEndpointOIDCProviderJSONRequestBody = CreateOIDCProviderRequest

// PostAppEndpointResyncJSONRequestBody defines body for PostAppEndpointResync for application/json ContentType.
type PostAppEndpointResyncJSONRequestBody = ResyncRequest

// PutAppServiceAuditLogStateJSONRequestBody defines body for PutAppServiceAuditLogState for application/json ContentType.
type PutAppServiceAuditLogStateJSONRequestBody = CreateAppServiceAuditLogRequest

// PostAppServiceAuditLogExportJSONRequestBody defines body for PostAppServiceAuditLogExport for application/json ContentType.
type PostAppServiceAuditLogExportJSONRequestBody = CreateClusterAuditLogExportRequest

// PatchAppServiceAuditLogStreamingJSONRequestBody defines body for PatchAppServiceAuditLogStreaming for application/json ContentType.
type PatchAppServiceAuditLogStreamingJSONRequestBody = PatchAuditLogStreamingRequest

// PutAppServiceAuditLogStreamingJSONRequestBody defines body for PutAppServiceAuditLogStreaming for application/json ContentType.
type PutAppServiceAuditLogStreamingJSONRequestBody = PutAuditLogStreamingRequest

// GetAppServicePrivateEndpointsCommandJSONRequestBody defines body for GetAppServicePrivateEndpointsCommand for application/json ContentType.
type GetAppServicePrivateEndpointsCommandJSONRequestBody GetAppServicePrivateEndpointsCommandJSONBody

// PutClusterAuditSettingsJSONRequestBody defines body for PutClusterAuditSettings for application/json ContentType.
type PutClusterAuditSettingsJSONRequestBody = CreateClusterAuditSettingsRequest

// PostAuditLogExportJSONRequestBody defines body for PostAuditLogExport for application/json ContentType.
type PostAuditLogExportJSONRequestBody = CreateClusterAuditLogExportRequest

// PostRestoreJSONRequestBody defines body for PostRestore for application/json ContentType.
type PostRestoreJSONRequestBody = CreateOnDemandRestoreRequest

// PutBucketStorageBackendJSONRequestBody defines body for PutBucketStorageBackend for application/json ContentType.
type PutBucketStorageBackendJSONRequestBody = UpdateBucketStorageBackendRequest

// PostBucketJSONRequestBody defines body for PostBucket for application/json ContentType.
type PostBucketJSONRequestBody = CreateBucketRequest

// CreateFreeTierBucketJSONRequestBody defines body for CreateFreeTierBucket for application/json ContentType.
type CreateFreeTierBucketJSONRequestBody = CreateFreeTierBucketRequest

// UpdateFreeTierBucketJSONRequestBody defines body for UpdateFreeTierBucket for application/json ContentType.
type UpdateFreeTierBucketJSONRequestBody = UpdateFreeTierBucketRequest

// PutBucketJSONRequestBody defines body for PutBucket for application/json ContentType.
type PutBucketJSONRequestBody = UpdateBucketRequest

// PostBackupScheduleJSONRequestBody defines body for PostBackupSchedule for application/json ContentType.
type PostBackupScheduleJSONRequestBody = CreateScheduledBackupRequest

// PutBackupScheduleJSONRequestBody defines body for PutBackupSchedule for application/json ContentType.
type PutBackupScheduleJSONRequestBody = CreateScheduledBackupRequest

// PostScopeJSONRequestBody defines body for PostScope for application/json ContentType.
type PostScopeJSONRequestBody = CreateScopeRequest

// PostCollectionJSONRequestBody defines body for PostCollection for application/json ContentType.
type PostCollectionJSONRequestBody = CreateCollectionRequest

// PutCollectionJSONRequestBody defines body for PutCollection for application/json ContentType.
type PutCollectionJSONRequestBody = UpdateCollectionRequest

// CreateCloudSnapshotBackupJSONRequestBody defines body for CreateCloudSnapshotBackup for application/json ContentType.
type CreateCloudSnapshotBackupJSONRequestBody = CreateCloudSnapshotBackupRequest

// EditCloudSnapshotBackupRetentionJSONRequestBody defines body for EditCloudSnapshotBackupRetention for application/json ContentType.
type EditCloudSnapshotBackupRetentionJSONRequestBody = EditCloudSnapshotBackupRetentionRequest

// RestoreJSONRequestBody defines body for Restore for application/json ContentType.
type RestoreJSONRequestBody = CreateCloudSnapshotRestoreRequest

// UpsertCloudSnapshotBackupScheduleJSONRequestBody defines body for UpsertCloudSnapshotBackupSchedule for application/json ContentType.
type UpsertCloudSnapshotBackupScheduleJSONRequestBody = UpsertCloudSnapshotBackupScheduleRequest

// UpdateDataApiAndPeeringJSONRequestBody defines body for UpdateDataApiAndPeering for application/json ContentType.
type UpdateDataApiAndPeeringJSONRequestBody UpdateDataApiAndPeeringJSONBody

// GetDataAPIPrivateEndpointCommandJSONRequestBody defines body for GetDataAPIPrivateEndpointCommand for application/json ContentType.
type GetDataAPIPrivateEndpointCommandJSONRequestBody GetDataAPIPrivateEndpointCommandJSONBody

// AddMtlsCertificateJSONRequestBody defines body for AddMtlsCertificate for application/json ContentType.
type AddMtlsCertificateJSONRequestBody = MtlsCertificateRequest

// PutMtlsCertificateJSONRequestBody defines body for PutMtlsCertificate for application/json ContentType.
type PutMtlsCertificateJSONRequestBody = MtlsCertificateRequest

// UpdateMtlsConfigurationJSONRequestBody defines body for UpdateMtlsConfiguration for application/json ContentType.
type UpdateMtlsConfigurationJSONRequestBody = UpdateMtlsConfigRequest

// PostNetworkPeeringJSONRequestBody defines body for PostNetworkPeering for application/json ContentType.
type PostNetworkPeeringJSONRequestBody = CreateNetworkPeeringRequest

// GetAzureVnetPeeringCommandJSONRequestBody defines body for GetAzureVnetPeeringCommand for application/json ContentType.
type GetAzureVnetPeeringCommandJSONRequestBody = GetAzureVNetPeeringCommandRequest

// PostOnOffScheduleJSONRequestBody defines body for PostOnOffSchedule for application/json ContentType.
type PostOnOffScheduleJSONRequestBody = ClusterOnOffSchedule

// PutOnOffScheduleJSONRequestBody defines body for PutOnOffSchedule for application/json ContentType.
type PutOnOffScheduleJSONRequestBody = ClusterOnOffSchedule

// GetPrivateEndpointCommandJSONRequestBody defines body for GetPrivateEndpointCommand for application/json ContentType.
type GetPrivateEndpointCommandJSONRequestBody GetPrivateEndpointCommandJSONBody

// ManageQueryIndexesJSONRequestBody defines body for ManageQueryIndexes for application/json ContentType.
type ManageQueryIndexesJSONRequestBody = IndexDDLRequest

// CreateReplicationJSONRequestBody defines body for CreateReplication for application/json ContentType.
type CreateReplicationJSONRequestBody = CreateReplicationRequest

// UpdateReplicationJSONRequestBody defines body for UpdateReplication for application/json ContentType.
type UpdateReplicationJSONRequestBody = UpdateReplicationRequest

// PostSampleBucketJSONRequestBody defines body for PostSampleBucket for application/json ContentType.
type PostSampleBucketJSONRequestBody = PostSampleBucket

// PostDatabaseCredentialJSONRequestBody defines body for PostDatabaseCredential for application/json ContentType.
type PostDatabaseCredentialJSONRequestBody = CreateDatabaseCredentialRequest

// PutDatabaseCredentialJSONRequestBody defines body for PutDatabaseCredential for application/json ContentType.
type PutDatabaseCredentialJSONRequestBody = UpdateDatabaseCredentialRequest

// PostUserJSONRequestBody defines body for PostUser for application/json ContentType.
type PostUserJSONRequestBody = CreateUserRequest

// PatchUserJSONRequestBody defines body for PatchUser for application/json ContentType.
type PatchUserJSONRequestBody = PatchUserRequest

// AsUpdateAppServiceAdminUserAllEndpointsRequest returns the union data inside the CreateAppServiceAdminUserRequest_Access as a UpdateAppServiceAdminUserAllEndpointsRequest
func (t CreateAppServiceAdminUserRequest_Access) AsUpdateAppServiceAdminUserAllEndpointsRequest() (UpdateAppServiceAdminUserAllEndpointsRequest, error) {
	var body UpdateAppServiceAdminUserAllEndpointsRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateAppServiceAdminUserAllEndpointsRequest overwrites any union data inside the CreateAppServiceAdminUserRequest_Access as the provided UpdateAppServiceAdminUserAllEndpointsRequest
func (t *CreateAppServiceAdminUserRequest_Access) FromUpdateAppServiceAdminUserAllEndpointsRequest(v UpdateAppServiceAdminUserAllEndpointsRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateAppServiceAdminUserAllEndpointsRequest performs a merge with any union data inside the CreateAppServiceAdminUserRequest_Access, using the provided UpdateAppServiceAdminUserAllEndpointsRequest
func (t *CreateAppServiceAdminUserRequest_Access) MergeUpdateAppServiceAdminUserAllEndpointsRequest(v UpdateAppServiceAdminUserAllEndpointsRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateAppServiceAdminUserEndpointList returns the union data inside the CreateAppServiceAdminUserRequest_Access as a UpdateAppServiceAdminUserEndpointList
func (t CreateAppServiceAdminUserRequest_Access) AsUpdateAppServiceAdminUserEndpointList() (UpdateAppServiceAdminUserEndpointList, error) {
	var body UpdateAppServiceAdminUserEndpointList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateAppServiceAdminUserEndpointList overwrites any union data inside the CreateAppServiceAdminUserRequest_Access as the provided UpdateAppServiceAdminUserEndpointList
func (t *CreateAppServiceAdminUserRequest_Access) FromUpdateAppServiceAdminUserEndpointList(v UpdateAppServiceAdminUserEndpointList) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateAppServiceAdminUserEndpointList performs a merge with any union data inside the CreateAppServiceAdminUserRequest_Access, using the provided UpdateAppServiceAdminUserEndpointList
func (t *CreateAppServiceAdminUserRequest_Access) MergeUpdateAppServiceAdminUserEndpointList(v UpdateAppServiceAdminUserEndpointList) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateAppServiceAdminUserRequest_Access) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateAppServiceAdminUserRequest_Access) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWSConfig returns the union data inside the CreateCMEKMetadata_Config as a AWSConfig
func (t CreateCMEKMetadata_Config) AsAWSConfig() (AWSConfig, error) {
	var body AWSConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSConfig overwrites any union data inside the CreateCMEKMetadata_Config as the provided AWSConfig
func (t *CreateCMEKMetadata_Config) FromAWSConfig(v AWSConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSConfig performs a merge with any union data inside the CreateCMEKMetadata_Config, using the provided AWSConfig
func (t *CreateCMEKMetadata_Config) MergeAWSConfig(v AWSConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGCPConfig returns the union data inside the CreateCMEKMetadata_Config as a GCPConfig
func (t CreateCMEKMetadata_Config) AsGCPConfig() (GCPConfig, error) {
	var body GCPConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPConfig overwrites any union data inside the CreateCMEKMetadata_Config as the provided GCPConfig
func (t *CreateCMEKMetadata_Config) FromGCPConfig(v GCPConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPConfig performs a merge with any union data inside the CreateCMEKMetadata_Config, using the provided GCPConfig
func (t *CreateCMEKMetadata_Config) MergeGCPConfig(v GCPConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateCMEKMetadata_Config) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateCMEKMetadata_Config) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWSConfigData returns the union data inside the CreateNetworkPeeringRequest_ProviderConfig as a AWSConfigData
func (t CreateNetworkPeeringRequest_ProviderConfig) AsAWSConfigData() (AWSConfigData, error) {
	var body AWSConfigData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSConfigData overwrites any union data inside the CreateNetworkPeeringRequest_ProviderConfig as the provided AWSConfigData
func (t *CreateNetworkPeeringRequest_ProviderConfig) FromAWSConfigData(v AWSConfigData) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSConfigData performs a merge with any union data inside the CreateNetworkPeeringRequest_ProviderConfig, using the provided AWSConfigData
func (t *CreateNetworkPeeringRequest_ProviderConfig) MergeAWSConfigData(v AWSConfigData) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGCPConfigData returns the union data inside the CreateNetworkPeeringRequest_ProviderConfig as a GCPConfigData
func (t CreateNetworkPeeringRequest_ProviderConfig) AsGCPConfigData() (GCPConfigData, error) {
	var body GCPConfigData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPConfigData overwrites any union data inside the CreateNetworkPeeringRequest_ProviderConfig as the provided GCPConfigData
func (t *CreateNetworkPeeringRequest_ProviderConfig) FromGCPConfigData(v GCPConfigData) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPConfigData performs a merge with any union data inside the CreateNetworkPeeringRequest_ProviderConfig, using the provided GCPConfigData
func (t *CreateNetworkPeeringRequest_ProviderConfig) MergeGCPConfigData(v GCPConfigData) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAzureConfigData returns the union data inside the CreateNetworkPeeringRequest_ProviderConfig as a AzureConfigData
func (t CreateNetworkPeeringRequest_ProviderConfig) AsAzureConfigData() (AzureConfigData, error) {
	var body AzureConfigData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureConfigData overwrites any union data inside the CreateNetworkPeeringRequest_ProviderConfig as the provided AzureConfigData
func (t *CreateNetworkPeeringRequest_ProviderConfig) FromAzureConfigData(v AzureConfigData) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureConfigData performs a merge with any union data inside the CreateNetworkPeeringRequest_ProviderConfig, using the provided AzureConfigData
func (t *CreateNetworkPeeringRequest_ProviderConfig) MergeAzureConfigData(v AzureConfigData) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateNetworkPeeringRequest_ProviderConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateNetworkPeeringRequest_ProviderConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateS3ConfigurationRequest returns the union data inside the CreateProviderRequest_Configuration as a CreateS3ConfigurationRequest
func (t CreateProviderRequest_Configuration) AsCreateS3ConfigurationRequest() (CreateS3ConfigurationRequest, error) {
	var body CreateS3ConfigurationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateS3ConfigurationRequest overwrites any union data inside the CreateProviderRequest_Configuration as the provided CreateS3ConfigurationRequest
func (t *CreateProviderRequest_Configuration) FromCreateS3ConfigurationRequest(v CreateS3ConfigurationRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateS3ConfigurationRequest performs a merge with any union data inside the CreateProviderRequest_Configuration, using the provided CreateS3ConfigurationRequest
func (t *CreateProviderRequest_Configuration) MergeCreateS3ConfigurationRequest(v CreateS3ConfigurationRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateOpenAIConfigurationRequest returns the union data inside the CreateProviderRequest_Configuration as a CreateOpenAIConfigurationRequest
func (t CreateProviderRequest_Configuration) AsCreateOpenAIConfigurationRequest() (CreateOpenAIConfigurationRequest, error) {
	var body CreateOpenAIConfigurationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateOpenAIConfigurationRequest overwrites any union data inside the CreateProviderRequest_Configuration as the provided CreateOpenAIConfigurationRequest
func (t *CreateProviderRequest_Configuration) FromCreateOpenAIConfigurationRequest(v CreateOpenAIConfigurationRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateOpenAIConfigurationRequest performs a merge with any union data inside the CreateProviderRequest_Configuration, using the provided CreateOpenAIConfigurationRequest
func (t *CreateProviderRequest_Configuration) MergeCreateOpenAIConfigurationRequest(v CreateOpenAIConfigurationRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateProviderRequest_Configuration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateProviderRequest_Configuration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateStructuredWorkflowRequest returns the union data inside the CreateWorkflowRequest_Configuration as a CreateStructuredWorkflowRequest
func (t CreateWorkflowRequest_Configuration) AsCreateStructuredWorkflowRequest() (CreateStructuredWorkflowRequest, error) {
	var body CreateStructuredWorkflowRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateStructuredWorkflowRequest overwrites any union data inside the CreateWorkflowRequest_Configuration as the provided CreateStructuredWorkflowRequest
func (t *CreateWorkflowRequest_Configuration) FromCreateStructuredWorkflowRequest(v CreateStructuredWorkflowRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateStructuredWorkflowRequest performs a merge with any union data inside the CreateWorkflowRequest_Configuration, using the provided CreateStructuredWorkflowRequest
func (t *CreateWorkflowRequest_Configuration) MergeCreateStructuredWorkflowRequest(v CreateStructuredWorkflowRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateUnstructuredWorkflowRequest returns the union data inside the CreateWorkflowRequest_Configuration as a CreateUnstructuredWorkflowRequest
func (t CreateWorkflowRequest_Configuration) AsCreateUnstructuredWorkflowRequest() (CreateUnstructuredWorkflowRequest, error) {
	var body CreateUnstructuredWorkflowRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateUnstructuredWorkflowRequest overwrites any union data inside the CreateWorkflowRequest_Configuration as the provided CreateUnstructuredWorkflowRequest
func (t *CreateWorkflowRequest_Configuration) FromCreateUnstructuredWorkflowRequest(v CreateUnstructuredWorkflowRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateUnstructuredWorkflowRequest performs a merge with any union data inside the CreateWorkflowRequest_Configuration, using the provided CreateUnstructuredWorkflowRequest
func (t *CreateWorkflowRequest_Configuration) MergeCreateUnstructuredWorkflowRequest(v CreateUnstructuredWorkflowRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateVectorizationWorkflowRequest returns the union data inside the CreateWorkflowRequest_Configuration as a CreateVectorizationWorkflowRequest
func (t CreateWorkflowRequest_Configuration) AsCreateVectorizationWorkflowRequest() (CreateVectorizationWorkflowRequest, error) {
	var body CreateVectorizationWorkflowRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateVectorizationWorkflowRequest overwrites any union data inside the CreateWorkflowRequest_Configuration as the provided CreateVectorizationWorkflowRequest
func (t *CreateWorkflowRequest_Configuration) FromCreateVectorizationWorkflowRequest(v CreateVectorizationWorkflowRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateVectorizationWorkflowRequest performs a merge with any union data inside the CreateWorkflowRequest_Configuration, using the provided CreateVectorizationWorkflowRequest
func (t *CreateWorkflowRequest_Configuration) MergeCreateVectorizationWorkflowRequest(v CreateVectorizationWorkflowRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateWorkflowRequest_Configuration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateWorkflowRequest_Configuration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWSConfig returns the union data inside the GetCMEKHistoryMetadataResponse_Config as a AWSConfig
func (t GetCMEKHistoryMetadataResponse_Config) AsAWSConfig() (AWSConfig, error) {
	var body AWSConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSConfig overwrites any union data inside the GetCMEKHistoryMetadataResponse_Config as the provided AWSConfig
func (t *GetCMEKHistoryMetadataResponse_Config) FromAWSConfig(v AWSConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSConfig performs a merge with any union data inside the GetCMEKHistoryMetadataResponse_Config, using the provided AWSConfig
func (t *GetCMEKHistoryMetadataResponse_Config) MergeAWSConfig(v AWSConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGCPConfig returns the union data inside the GetCMEKHistoryMetadataResponse_Config as a GCPConfig
func (t GetCMEKHistoryMetadataResponse_Config) AsGCPConfig() (GCPConfig, error) {
	var body GCPConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPConfig overwrites any union data inside the GetCMEKHistoryMetadataResponse_Config as the provided GCPConfig
func (t *GetCMEKHistoryMetadataResponse_Config) FromGCPConfig(v GCPConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPConfig performs a merge with any union data inside the GetCMEKHistoryMetadataResponse_Config, using the provided GCPConfig
func (t *GetCMEKHistoryMetadataResponse_Config) MergeGCPConfig(v GCPConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetCMEKHistoryMetadataResponse_Config) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetCMEKHistoryMetadataResponse_Config) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWSConfig returns the union data inside the GetCMEKMetadata_Config as a AWSConfig
func (t GetCMEKMetadata_Config) AsAWSConfig() (AWSConfig, error) {
	var body AWSConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSConfig overwrites any union data inside the GetCMEKMetadata_Config as the provided AWSConfig
func (t *GetCMEKMetadata_Config) FromAWSConfig(v AWSConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSConfig performs a merge with any union data inside the GetCMEKMetadata_Config, using the provided AWSConfig
func (t *GetCMEKMetadata_Config) MergeAWSConfig(v AWSConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGCPConfig returns the union data inside the GetCMEKMetadata_Config as a GCPConfig
func (t GetCMEKMetadata_Config) AsGCPConfig() (GCPConfig, error) {
	var body GCPConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPConfig overwrites any union data inside the GetCMEKMetadata_Config as the provided GCPConfig
func (t *GetCMEKMetadata_Config) FromGCPConfig(v GCPConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPConfig performs a merge with any union data inside the GetCMEKMetadata_Config, using the provided GCPConfig
func (t *GetCMEKMetadata_Config) MergeGCPConfig(v GCPConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetCMEKMetadata_Config) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetCMEKMetadata_Config) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWS returns the union data inside the GetNetworkPeeringRecordResponse_ProviderConfig as a AWS
func (t GetNetworkPeeringRecordResponse_ProviderConfig) AsAWS() (AWS, error) {
	var body AWS
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWS overwrites any union data inside the GetNetworkPeeringRecordResponse_ProviderConfig as the provided AWS
func (t *GetNetworkPeeringRecordResponse_ProviderConfig) FromAWS(v AWS) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWS performs a merge with any union data inside the GetNetworkPeeringRecordResponse_ProviderConfig, using the provided AWS
func (t *GetNetworkPeeringRecordResponse_ProviderConfig) MergeAWS(v AWS) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGCP returns the union data inside the GetNetworkPeeringRecordResponse_ProviderConfig as a GCP
func (t GetNetworkPeeringRecordResponse_ProviderConfig) AsGCP() (GCP, error) {
	var body GCP
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCP overwrites any union data inside the GetNetworkPeeringRecordResponse_ProviderConfig as the provided GCP
func (t *GetNetworkPeeringRecordResponse_ProviderConfig) FromGCP(v GCP) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCP performs a merge with any union data inside the GetNetworkPeeringRecordResponse_ProviderConfig, using the provided GCP
func (t *GetNetworkPeeringRecordResponse_ProviderConfig) MergeGCP(v GCP) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAZURE returns the union data inside the GetNetworkPeeringRecordResponse_ProviderConfig as a AZURE
func (t GetNetworkPeeringRecordResponse_ProviderConfig) AsAZURE() (AZURE, error) {
	var body AZURE
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAZURE overwrites any union data inside the GetNetworkPeeringRecordResponse_ProviderConfig as the provided AZURE
func (t *GetNetworkPeeringRecordResponse_ProviderConfig) FromAZURE(v AZURE) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAZURE performs a merge with any union data inside the GetNetworkPeeringRecordResponse_ProviderConfig, using the provided AZURE
func (t *GetNetworkPeeringRecordResponse_ProviderConfig) MergeAZURE(v AZURE) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetNetworkPeeringRecordResponse_ProviderConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetNetworkPeeringRecordResponse_ProviderConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetS3ConfigurationResponse returns the union data inside the GetProviderResponse_Configuration as a GetS3ConfigurationResponse
func (t GetProviderResponse_Configuration) AsGetS3ConfigurationResponse() (GetS3ConfigurationResponse, error) {
	var body GetS3ConfigurationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetS3ConfigurationResponse overwrites any union data inside the GetProviderResponse_Configuration as the provided GetS3ConfigurationResponse
func (t *GetProviderResponse_Configuration) FromGetS3ConfigurationResponse(v GetS3ConfigurationResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetS3ConfigurationResponse performs a merge with any union data inside the GetProviderResponse_Configuration, using the provided GetS3ConfigurationResponse
func (t *GetProviderResponse_Configuration) MergeGetS3ConfigurationResponse(v GetS3ConfigurationResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetOpenAIConfigurationResponse returns the union data inside the GetProviderResponse_Configuration as a GetOpenAIConfigurationResponse
func (t GetProviderResponse_Configuration) AsGetOpenAIConfigurationResponse() (GetOpenAIConfigurationResponse, error) {
	var body GetOpenAIConfigurationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetOpenAIConfigurationResponse overwrites any union data inside the GetProviderResponse_Configuration as the provided GetOpenAIConfigurationResponse
func (t *GetProviderResponse_Configuration) FromGetOpenAIConfigurationResponse(v GetOpenAIConfigurationResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetOpenAIConfigurationResponse performs a merge with any union data inside the GetProviderResponse_Configuration, using the provided GetOpenAIConfigurationResponse
func (t *GetProviderResponse_Configuration) MergeGetOpenAIConfigurationResponse(v GetOpenAIConfigurationResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetProviderResponse_Configuration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetProviderResponse_Configuration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetStructuredWorkflowResponse returns the union data inside the GetWorkflowResponse_Configuration as a GetStructuredWorkflowResponse
func (t GetWorkflowResponse_Configuration) AsGetStructuredWorkflowResponse() (GetStructuredWorkflowResponse, error) {
	var body GetStructuredWorkflowResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetStructuredWorkflowResponse overwrites any union data inside the GetWorkflowResponse_Configuration as the provided GetStructuredWorkflowResponse
func (t *GetWorkflowResponse_Configuration) FromGetStructuredWorkflowResponse(v GetStructuredWorkflowResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetStructuredWorkflowResponse performs a merge with any union data inside the GetWorkflowResponse_Configuration, using the provided GetStructuredWorkflowResponse
func (t *GetWorkflowResponse_Configuration) MergeGetStructuredWorkflowResponse(v GetStructuredWorkflowResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetUnstructuredWorkflowResponse returns the union data inside the GetWorkflowResponse_Configuration as a GetUnstructuredWorkflowResponse
func (t GetWorkflowResponse_Configuration) AsGetUnstructuredWorkflowResponse() (GetUnstructuredWorkflowResponse, error) {
	var body GetUnstructuredWorkflowResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetUnstructuredWorkflowResponse overwrites any union data inside the GetWorkflowResponse_Configuration as the provided GetUnstructuredWorkflowResponse
func (t *GetWorkflowResponse_Configuration) FromGetUnstructuredWorkflowResponse(v GetUnstructuredWorkflowResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetUnstructuredWorkflowResponse performs a merge with any union data inside the GetWorkflowResponse_Configuration, using the provided GetUnstructuredWorkflowResponse
func (t *GetWorkflowResponse_Configuration) MergeGetUnstructuredWorkflowResponse(v GetUnstructuredWorkflowResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetVectorizationWorkflowResponse returns the union data inside the GetWorkflowResponse_Configuration as a GetVectorizationWorkflowResponse
func (t GetWorkflowResponse_Configuration) AsGetVectorizationWorkflowResponse() (GetVectorizationWorkflowResponse, error) {
	var body GetVectorizationWorkflowResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetVectorizationWorkflowResponse overwrites any union data inside the GetWorkflowResponse_Configuration as the provided GetVectorizationWorkflowResponse
func (t *GetWorkflowResponse_Configuration) FromGetVectorizationWorkflowResponse(v GetVectorizationWorkflowResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetVectorizationWorkflowResponse performs a merge with any union data inside the GetWorkflowResponse_Configuration, using the provided GetVectorizationWorkflowResponse
func (t *GetWorkflowResponse_Configuration) MergeGetVectorizationWorkflowResponse(v GetVectorizationWorkflowResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetWorkflowResponse_Configuration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetWorkflowResponse_Configuration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetS3ConfigurationResponse returns the union data inside the ListProvidersResponse_Data_Configuration as a GetS3ConfigurationResponse
func (t ListProvidersResponse_Data_Configuration) AsGetS3ConfigurationResponse() (GetS3ConfigurationResponse, error) {
	var body GetS3ConfigurationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetS3ConfigurationResponse overwrites any union data inside the ListProvidersResponse_Data_Configuration as the provided GetS3ConfigurationResponse
func (t *ListProvidersResponse_Data_Configuration) FromGetS3ConfigurationResponse(v GetS3ConfigurationResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetS3ConfigurationResponse performs a merge with any union data inside the ListProvidersResponse_Data_Configuration, using the provided GetS3ConfigurationResponse
func (t *ListProvidersResponse_Data_Configuration) MergeGetS3ConfigurationResponse(v GetS3ConfigurationResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetOpenAIConfigurationResponse returns the union data inside the ListProvidersResponse_Data_Configuration as a GetOpenAIConfigurationResponse
func (t ListProvidersResponse_Data_Configuration) AsGetOpenAIConfigurationResponse() (GetOpenAIConfigurationResponse, error) {
	var body GetOpenAIConfigurationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetOpenAIConfigurationResponse overwrites any union data inside the ListProvidersResponse_Data_Configuration as the provided GetOpenAIConfigurationResponse
func (t *ListProvidersResponse_Data_Configuration) FromGetOpenAIConfigurationResponse(v GetOpenAIConfigurationResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetOpenAIConfigurationResponse performs a merge with any union data inside the ListProvidersResponse_Data_Configuration, using the provided GetOpenAIConfigurationResponse
func (t *ListProvidersResponse_Data_Configuration) MergeGetOpenAIConfigurationResponse(v GetOpenAIConfigurationResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ListProvidersResponse_Data_Configuration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ListProvidersResponse_Data_Configuration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWS returns the union data inside the ListSingleNetworkPeeringRecord_ProviderConfig as a AWS
func (t ListSingleNetworkPeeringRecord_ProviderConfig) AsAWS() (AWS, error) {
	var body AWS
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWS overwrites any union data inside the ListSingleNetworkPeeringRecord_ProviderConfig as the provided AWS
func (t *ListSingleNetworkPeeringRecord_ProviderConfig) FromAWS(v AWS) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWS performs a merge with any union data inside the ListSingleNetworkPeeringRecord_ProviderConfig, using the provided AWS
func (t *ListSingleNetworkPeeringRecord_ProviderConfig) MergeAWS(v AWS) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGCP returns the union data inside the ListSingleNetworkPeeringRecord_ProviderConfig as a GCP
func (t ListSingleNetworkPeeringRecord_ProviderConfig) AsGCP() (GCP, error) {
	var body GCP
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCP overwrites any union data inside the ListSingleNetworkPeeringRecord_ProviderConfig as the provided GCP
func (t *ListSingleNetworkPeeringRecord_ProviderConfig) FromGCP(v GCP) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCP performs a merge with any union data inside the ListSingleNetworkPeeringRecord_ProviderConfig, using the provided GCP
func (t *ListSingleNetworkPeeringRecord_ProviderConfig) MergeGCP(v GCP) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAZURE returns the union data inside the ListSingleNetworkPeeringRecord_ProviderConfig as a AZURE
func (t ListSingleNetworkPeeringRecord_ProviderConfig) AsAZURE() (AZURE, error) {
	var body AZURE
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAZURE overwrites any union data inside the ListSingleNetworkPeeringRecord_ProviderConfig as the provided AZURE
func (t *ListSingleNetworkPeeringRecord_ProviderConfig) FromAZURE(v AZURE) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAZURE performs a merge with any union data inside the ListSingleNetworkPeeringRecord_ProviderConfig, using the provided AZURE
func (t *ListSingleNetworkPeeringRecord_ProviderConfig) MergeAZURE(v AZURE) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ListSingleNetworkPeeringRecord_ProviderConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ListSingleNetworkPeeringRecord_ProviderConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDiskAWS returns the union data inside the Node_Disk as a DiskAWS
func (t Node_Disk) AsDiskAWS() (DiskAWS, error) {
	var body DiskAWS
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiskAWS overwrites any union data inside the Node_Disk as the provided DiskAWS
func (t *Node_Disk) FromDiskAWS(v DiskAWS) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiskAWS performs a merge with any union data inside the Node_Disk, using the provided DiskAWS
func (t *Node_Disk) MergeDiskAWS(v DiskAWS) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDiskAzure returns the union data inside the Node_Disk as a DiskAzure
func (t Node_Disk) AsDiskAzure() (DiskAzure, error) {
	var body DiskAzure
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiskAzure overwrites any union data inside the Node_Disk as the provided DiskAzure
func (t *Node_Disk) FromDiskAzure(v DiskAzure) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiskAzure performs a merge with any union data inside the Node_Disk, using the provided DiskAzure
func (t *Node_Disk) MergeDiskAzure(v DiskAzure) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDiskGCP returns the union data inside the Node_Disk as a DiskGCP
func (t Node_Disk) AsDiskGCP() (DiskGCP, error) {
	var body DiskGCP
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiskGCP overwrites any union data inside the Node_Disk as the provided DiskGCP
func (t *Node_Disk) FromDiskGCP(v DiskGCP) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiskGCP performs a merge with any union data inside the Node_Disk, using the provided DiskGCP
func (t *Node_Disk) MergeDiskGCP(v DiskGCP) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Node_Disk) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Node_Disk) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPatchEntryValue0 returns the union data inside the PatchEntry_Value as a PatchEntryValue0
func (t PatchEntry_Value) AsPatchEntryValue0() (PatchEntryValue0, error) {
	var body PatchEntryValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPatchEntryValue0 overwrites any union data inside the PatchEntry_Value as the provided PatchEntryValue0
func (t *PatchEntry_Value) FromPatchEntryValue0(v PatchEntryValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePatchEntryValue0 performs a merge with any union data inside the PatchEntry_Value, using the provided PatchEntryValue0
func (t *PatchEntry_Value) MergePatchEntryValue0(v PatchEntryValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPatchEntryValue1 returns the union data inside the PatchEntry_Value as a PatchEntryValue1
func (t PatchEntry_Value) AsPatchEntryValue1() (PatchEntryValue1, error) {
	var body PatchEntryValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPatchEntryValue1 overwrites any union data inside the PatchEntry_Value as the provided PatchEntryValue1
func (t *PatchEntry_Value) FromPatchEntryValue1(v PatchEntryValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePatchEntryValue1 performs a merge with any union data inside the PatchEntry_Value, using the provided PatchEntryValue1
func (t *PatchEntry_Value) MergePatchEntryValue1(v PatchEntryValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResource returns the union data inside the PatchEntry_Value as a Resource
func (t PatchEntry_Value) AsResource() (Resource, error) {
	var body Resource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResource overwrites any union data inside the PatchEntry_Value as the provided Resource
func (t *PatchEntry_Value) FromResource(v Resource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResource performs a merge with any union data inside the PatchEntry_Value, using the provided Resource
func (t *PatchEntry_Value) MergeResource(v Resource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PatchEntry_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PatchEntry_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDatadog returns the union data inside the PutAuditLogStreamingRequest_Credentials as a Datadog
func (t PutAuditLogStreamingRequest_Credentials) AsDatadog() (Datadog, error) {
	var body Datadog
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDatadog overwrites any union data inside the PutAuditLogStreamingRequest_Credentials as the provided Datadog
func (t *PutAuditLogStreamingRequest_Credentials) FromDatadog(v Datadog) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDatadog performs a merge with any union data inside the PutAuditLogStreamingRequest_Credentials, using the provided Datadog
func (t *PutAuditLogStreamingRequest_Credentials) MergeDatadog(v Datadog) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSumologic returns the union data inside the PutAuditLogStreamingRequest_Credentials as a Sumologic
func (t PutAuditLogStreamingRequest_Credentials) AsSumologic() (Sumologic, error) {
	var body Sumologic
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSumologic overwrites any union data inside the PutAuditLogStreamingRequest_Credentials as the provided Sumologic
func (t *PutAuditLogStreamingRequest_Credentials) FromSumologic(v Sumologic) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSumologic performs a merge with any union data inside the PutAuditLogStreamingRequest_Credentials, using the provided Sumologic
func (t *PutAuditLogStreamingRequest_Credentials) MergeSumologic(v Sumologic) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGenericHttp returns the union data inside the PutAuditLogStreamingRequest_Credentials as a GenericHttp
func (t PutAuditLogStreamingRequest_Credentials) AsGenericHttp() (GenericHttp, error) {
	var body GenericHttp
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGenericHttp overwrites any union data inside the PutAuditLogStreamingRequest_Credentials as the provided GenericHttp
func (t *PutAuditLogStreamingRequest_Credentials) FromGenericHttp(v GenericHttp) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGenericHttp performs a merge with any union data inside the PutAuditLogStreamingRequest_Credentials, using the provided GenericHttp
func (t *PutAuditLogStreamingRequest_Credentials) MergeGenericHttp(v GenericHttp) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsElastic returns the union data inside the PutAuditLogStreamingRequest_Credentials as a Elastic
func (t PutAuditLogStreamingRequest_Credentials) AsElastic() (Elastic, error) {
	var body Elastic
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElastic overwrites any union data inside the PutAuditLogStreamingRequest_Credentials as the provided Elastic
func (t *PutAuditLogStreamingRequest_Credentials) FromElastic(v Elastic) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElastic performs a merge with any union data inside the PutAuditLogStreamingRequest_Credentials, using the provided Elastic
func (t *PutAuditLogStreamingRequest_Credentials) MergeElastic(v Elastic) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLoki returns the union data inside the PutAuditLogStreamingRequest_Credentials as a Loki
func (t PutAuditLogStreamingRequest_Credentials) AsLoki() (Loki, error) {
	var body Loki
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLoki overwrites any union data inside the PutAuditLogStreamingRequest_Credentials as the provided Loki
func (t *PutAuditLogStreamingRequest_Credentials) FromLoki(v Loki) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLoki performs a merge with any union data inside the PutAuditLogStreamingRequest_Credentials, using the provided Loki
func (t *PutAuditLogStreamingRequest_Credentials) MergeLoki(v Loki) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PutAuditLogStreamingRequest_Credentials) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PutAuditLogStreamingRequest_Credentials) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWSConfig returns the union data inside the RotateCMEKKey_Config as a AWSConfig
func (t RotateCMEKKey_Config) AsAWSConfig() (AWSConfig, error) {
	var body AWSConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSConfig overwrites any union data inside the RotateCMEKKey_Config as the provided AWSConfig
func (t *RotateCMEKKey_Config) FromAWSConfig(v AWSConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSConfig performs a merge with any union data inside the RotateCMEKKey_Config, using the provided AWSConfig
func (t *RotateCMEKKey_Config) MergeAWSConfig(v AWSConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGCPConfig returns the union data inside the RotateCMEKKey_Config as a GCPConfig
func (t RotateCMEKKey_Config) AsGCPConfig() (GCPConfig, error) {
	var body GCPConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPConfig overwrites any union data inside the RotateCMEKKey_Config as the provided GCPConfig
func (t *RotateCMEKKey_Config) FromGCPConfig(v GCPConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPConfig performs a merge with any union data inside the RotateCMEKKey_Config, using the provided GCPConfig
func (t *RotateCMEKKey_Config) MergeGCPConfig(v GCPConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RotateCMEKKey_Config) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RotateCMEKKey_Config) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateS3ConfigurationRequest returns the union data inside the UpdateProviderRequest_Configuration as a UpdateS3ConfigurationRequest
func (t UpdateProviderRequest_Configuration) AsUpdateS3ConfigurationRequest() (UpdateS3ConfigurationRequest, error) {
	var body UpdateS3ConfigurationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateS3ConfigurationRequest overwrites any union data inside the UpdateProviderRequest_Configuration as the provided UpdateS3ConfigurationRequest
func (t *UpdateProviderRequest_Configuration) FromUpdateS3ConfigurationRequest(v UpdateS3ConfigurationRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateS3ConfigurationRequest performs a merge with any union data inside the UpdateProviderRequest_Configuration, using the provided UpdateS3ConfigurationRequest
func (t *UpdateProviderRequest_Configuration) MergeUpdateS3ConfigurationRequest(v UpdateS3ConfigurationRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOpenAIConfigurationRequest returns the union data inside the UpdateProviderRequest_Configuration as a UpdateOpenAIConfigurationRequest
func (t UpdateProviderRequest_Configuration) AsUpdateOpenAIConfigurationRequest() (UpdateOpenAIConfigurationRequest, error) {
	var body UpdateOpenAIConfigurationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOpenAIConfigurationRequest overwrites any union data inside the UpdateProviderRequest_Configuration as the provided UpdateOpenAIConfigurationRequest
func (t *UpdateProviderRequest_Configuration) FromUpdateOpenAIConfigurationRequest(v UpdateOpenAIConfigurationRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOpenAIConfigurationRequest performs a merge with any union data inside the UpdateProviderRequest_Configuration, using the provided UpdateOpenAIConfigurationRequest
func (t *UpdateProviderRequest_Configuration) MergeUpdateOpenAIConfigurationRequest(v UpdateOpenAIConfigurationRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateProviderRequest_Configuration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateProviderRequest_Configuration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsExternalModel returns the union data inside the VectorizationConfig_EmbeddingModel as a ExternalModel
func (t VectorizationConfig_EmbeddingModel) AsExternalModel() (ExternalModel, error) {
	var body ExternalModel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalModel overwrites any union data inside the VectorizationConfig_EmbeddingModel as the provided ExternalModel
func (t *VectorizationConfig_EmbeddingModel) FromExternalModel(v ExternalModel) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExternalModel performs a merge with any union data inside the VectorizationConfig_EmbeddingModel, using the provided ExternalModel
func (t *VectorizationConfig_EmbeddingModel) MergeExternalModel(v ExternalModel) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapellaHostedModel returns the union data inside the VectorizationConfig_EmbeddingModel as a CapellaHostedModel
func (t VectorizationConfig_EmbeddingModel) AsCapellaHostedModel() (CapellaHostedModel, error) {
	var body CapellaHostedModel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapellaHostedModel overwrites any union data inside the VectorizationConfig_EmbeddingModel as the provided CapellaHostedModel
func (t *VectorizationConfig_EmbeddingModel) FromCapellaHostedModel(v CapellaHostedModel) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapellaHostedModel performs a merge with any union data inside the VectorizationConfig_EmbeddingModel, using the provided CapellaHostedModel
func (t *VectorizationConfig_EmbeddingModel) MergeCapellaHostedModel(v CapellaHostedModel) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VectorizationConfig_EmbeddingModel) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VectorizationConfig_EmbeddingModel) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVectorizationConfigCreationEmbeddingModel0 returns the union data inside the VectorizationConfigCreation_EmbeddingModel as a VectorizationConfigCreationEmbeddingModel0
func (t VectorizationConfigCreation_EmbeddingModel) AsVectorizationConfigCreationEmbeddingModel0() (VectorizationConfigCreationEmbeddingModel0, error) {
	var body VectorizationConfigCreationEmbeddingModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVectorizationConfigCreationEmbeddingModel0 overwrites any union data inside the VectorizationConfigCreation_EmbeddingModel as the provided VectorizationConfigCreationEmbeddingModel0
func (t *VectorizationConfigCreation_EmbeddingModel) FromVectorizationConfigCreationEmbeddingModel0(v VectorizationConfigCreationEmbeddingModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVectorizationConfigCreationEmbeddingModel0 performs a merge with any union data inside the VectorizationConfigCreation_EmbeddingModel, using the provided VectorizationConfigCreationEmbeddingModel0
func (t *VectorizationConfigCreation_EmbeddingModel) MergeVectorizationConfigCreationEmbeddingModel0(v VectorizationConfigCreationEmbeddingModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVectorizationConfigCreationEmbeddingModel1 returns the union data inside the VectorizationConfigCreation_EmbeddingModel as a VectorizationConfigCreationEmbeddingModel1
func (t VectorizationConfigCreation_EmbeddingModel) AsVectorizationConfigCreationEmbeddingModel1() (VectorizationConfigCreationEmbeddingModel1, error) {
	var body VectorizationConfigCreationEmbeddingModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVectorizationConfigCreationEmbeddingModel1 overwrites any union data inside the VectorizationConfigCreation_EmbeddingModel as the provided VectorizationConfigCreationEmbeddingModel1
func (t *VectorizationConfigCreation_EmbeddingModel) FromVectorizationConfigCreationEmbeddingModel1(v VectorizationConfigCreationEmbeddingModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVectorizationConfigCreationEmbeddingModel1 performs a merge with any union data inside the VectorizationConfigCreation_EmbeddingModel, using the provided VectorizationConfigCreationEmbeddingModel1
func (t *VectorizationConfigCreation_EmbeddingModel) MergeVectorizationConfigCreationEmbeddingModel1(v VectorizationConfigCreationEmbeddingModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VectorizationConfigCreation_EmbeddingModel) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VectorizationConfigCreation_EmbeddingModel) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListOrganizations request
	ListOrganizations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationByID request
	GetOrganizationByID(ctx context.Context, organizationId OrganizationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModels request
	ListModels(ctx context.Context, organizationId OrganizationId, params *ListModelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateModelWithBody request with any body
	CreateModelWithBody(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateModel(ctx context.Context, organizationId OrganizationId, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DestroyModel request
	DestroyModel(ctx context.Context, organizationId OrganizationId, modelId ModelId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModel request
	GetModel(ctx context.Context, organizationId OrganizationId, modelId ModelId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModelAPIKeys request
	ListModelAPIKeys(ctx context.Context, organizationId OrganizationId, modelId ModelId, params *ListModelAPIKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateModelAPIKeyWithBody request with any body
	CreateModelAPIKeyWithBody(ctx context.Context, organizationId OrganizationId, modelId ModelId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateModelAPIKey(ctx context.Context, organizationId OrganizationId, modelId ModelId, body CreateModelAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteModelAPIKey request
	DeleteModelAPIKey(ctx context.Context, organizationId OrganizationId, modelId ModelId, apiKeyId ModelAPIKeyId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModelAPIKey request
	GetModelAPIKey(ctx context.Context, organizationId OrganizationId, modelId ModelId, apiKeyId ModelAPIKeyId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnectionString request
	GetConnectionString(ctx context.Context, organizationId OrganizationId, modelId ModelId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProviders request
	ListProviders(ctx context.Context, organizationId OrganizationId, params *ListProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProviderWithBody request with any body
	CreateProviderWithBody(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProvider(ctx context.Context, organizationId OrganizationId, body CreateProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProvider request
	DeleteProvider(ctx context.Context, organizationId OrganizationId, providerId ProviderId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProvider request
	GetProvider(ctx context.Context, organizationId OrganizationId, providerId ProviderId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProviderWithBody request with any body
	UpdateProviderWithBody(ctx context.Context, organizationId OrganizationId, providerId ProviderId, params *UpdateProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProvider(ctx context.Context, organizationId OrganizationId, providerId ProviderId, params *UpdateProviderParams, body UpdateProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOrganizationLevelAnalyticsClusters request
	ListOrganizationLevelAnalyticsClusters(ctx context.Context, organizationId OrganizationId, params *ListOrganizationLevelAnalyticsClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOrganizationAPIKeys request
	ListOrganizationAPIKeys(ctx context.Context, organizationId OrganizationId, params *ListOrganizationAPIKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrganizationAPIKeysWithBody request with any body
	PostOrganizationAPIKeysWithBody(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrganizationAPIKeys(ctx context.Context, organizationId OrganizationId, body PostOrganizationAPIKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizationAPIKey request
	DeleteOrganizationAPIKey(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationAPIKeyByAccessKey request
	GetOrganizationAPIKeyByAccessKey(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrganizationAPIKeyRotateWithBody request with any body
	PostOrganizationAPIKeyRotateWithBody(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrganizationAPIKeyRotate(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, body PostOrganizationAPIKeyRotateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppServices request
	ListAppServices(ctx context.Context, organizationId OrganizationId, params *ListAppServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCloudAccounts request
	GetCloudAccounts(ctx context.Context, organizationId OrganizationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeyMetadataList request
	GetKeyMetadataList(ctx context.Context, organizationId OrganizationId, params *GetKeyMetadataListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCMEKMetadataWithBody request with any body
	PostCMEKMetadataWithBody(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCMEKMetadata(ctx context.Context, organizationId OrganizationId, body PostCMEKMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeyMetadata request
	DeleteKeyMetadata(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeyMetadata request
	GetKeyMetadata(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RotateCMEKKeyWithBody request with any body
	RotateCMEKKeyWithBody(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RotateCMEKKey(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, body RotateCMEKKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCMEKHistory request
	ListCMEKHistory(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, params *ListCMEKHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutOrganizationConfigurationWithBody request with any body
	PutOrganizationConfigurationWithBody(ctx context.Context, organizationId OrganizationId, params *PutOrganizationConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutOrganizationConfiguration(ctx context.Context, organizationId OrganizationId, params *PutOrganizationConfigurationParams, body PutOrganizationConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvents request
	ListEvents(ctx context.Context, organizationId OrganizationId, params *ListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventByID request
	GetEventByID(ctx context.Context, organizationId OrganizationId, eventId EventId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjects request
	ListProjects(ctx context.Context, organizationId OrganizationId, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProjectWithBody request with any body
	PostProjectWithBody(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProject(ctx context.Context, organizationId OrganizationId, body PostProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectByID request
	DeleteProjectByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectByID request
	GetProjectByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutProjectWithBody request with any body
	PutProjectWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *PutProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutProject(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *PutProjectParams, body PutProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTestAlertIntegrationWithBody request with any body
	PostTestAlertIntegrationWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTestAlertIntegration(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body PostTestAlertIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAlertIntegrations request
	ListAlertIntegrations(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListAlertIntegrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAlertIntegrationWithBody request with any body
	PostAlertIntegrationWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAlertIntegration(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body PostAlertIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAlertIntegrationByID request
	DeleteAlertIntegrationByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlertIntegrationByID request
	GetAlertIntegrationByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAlertIntegrationWithBody request with any body
	PutAlertIntegrationWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutAlertIntegration(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, body PutAlertIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectLevelAnalyticsClusters request
	ListProjectLevelAnalyticsClusters(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectLevelAnalyticsClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAnalyticsClusterWithBody request with any body
	CreateAnalyticsClusterWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAnalyticsCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body CreateAnalyticsClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAnalyticsCluster request
	DeleteAnalyticsCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnalyticsCluster request
	GetAnalyticsCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAnalyticsClusterWithBody request with any body
	PutAnalyticsClusterWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *PutAnalyticsClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutAnalyticsCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *PutAnalyticsClusterParams, body PutAnalyticsClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnalyticsClusterOff request
	AnalyticsClusterOff(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnalyticsClusterOn request
	AnalyticsClusterOn(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAnalyticsAllowedCidrs request
	ListAnalyticsAllowedCidrs(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListAnalyticsAllowedCidrsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAnalyticsAllowedCidrWithBody request with any body
	PostAnalyticsAllowedCidrWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAnalyticsAllowedCidr(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PostAnalyticsAllowedCidrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteColumnarAllowedCidrByID request
	DeleteColumnarAllowedCidrByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetColumnarAllowedCidrByID request
	GetColumnarAllowedCidrByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteColumnarAnalyticsBackupSchedule request
	DeleteColumnarAnalyticsBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetColumnarAnalyticsBackupSchedule request
	GetColumnarAnalyticsBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertColumnarAnalyticsBackupScheduleWithBody request with any body
	UpsertColumnarAnalyticsBackupScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertColumnarAnalyticsBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body UpsertColumnarAnalyticsBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListColumnarAnalyticsBackups request
	ListColumnarAnalyticsBackups(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListColumnarAnalyticsBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateColumnarAnalyticsBackupWithBody request with any body
	CreateColumnarAnalyticsBackupWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateColumnarAnalyticsBackup(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body CreateColumnarAnalyticsBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListColumnarAnalyticsRestores request
	ListColumnarAnalyticsRestores(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListColumnarAnalyticsRestoresParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteColumnarAnalyticsBackup request
	DeleteColumnarAnalyticsBackup(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateColumnarAnalyticsBackupRetentionWithBody request with any body
	UpdateColumnarAnalyticsBackupRetentionWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateColumnarAnalyticsBackupRetention(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, body UpdateColumnarAnalyticsBackupRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreColumnarAnalyticsCluster request
	RestoreColumnarAnalyticsCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAnalyticsOnOffSchedule request
	DeleteAnalyticsOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnalyticsOnOffSchedule request
	GetAnalyticsOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAnalyticsOnOffScheduleWithBody request with any body
	PostAnalyticsOnOffScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAnalyticsOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PostAnalyticsOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAnalyticsOnOffScheduleWithBody request with any body
	PutAnalyticsOnOffScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutAnalyticsOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PutAnalyticsOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableColumnarPrivateEndpointService request
	DisableColumnarPrivateEndpointService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetColumnarPrivateEndpointServiceStatus request
	GetColumnarPrivateEndpointServiceStatus(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableColumnarPrivateEndpointService request
	EnableColumnarPrivateEndpointService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetColumnarPrivateEndpointServiceCommandWithBody request with any body
	GetColumnarPrivateEndpointServiceCommandWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetColumnarPrivateEndpointServiceCommand(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body GetColumnarPrivateEndpointServiceCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListColumnarPrivateEndpointServiceConnection request
	ListColumnarPrivateEndpointServiceConnection(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptColumnarPrivateEndpointServiceConnection request
	AcceptColumnarPrivateEndpointServiceConnection(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RejectColumnarPrivateEndpointServiceConnection request
	RejectColumnarPrivateEndpointServiceConnection(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectLevelCloudSnapshotBackups request
	ListProjectLevelCloudSnapshotBackups(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectLevelCloudSnapshotBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloneWithBody request with any body
	CloneWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Clone(ctx context.Context, organizationId OrganizationId, projectId ProjectId, backupId BackupId, body CloneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClusters request
	ListClusters(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClusterWithBody request with any body
	PostClusterWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFreeTierClusterWithBody request with any body
	CreateFreeTierClusterWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFreeTierCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body CreateFreeTierClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFreeTierCluster request
	DeleteFreeTierCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFreeTierCluster request
	GetFreeTierCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFreeTierClusterWithBody request with any body
	UpdateFreeTierClusterWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *UpdateFreeTierClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFreeTierCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *UpdateFreeTierClusterParams, body UpdateFreeTierClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FreeTierClusterOff request
	FreeTierClusterOff(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FreeTierClusterOn request
	FreeTierClusterOn(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutClusterWithBody request with any body
	PutClusterWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *PutClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *PutClusterParams, body PutClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClusterOff request
	ClusterOff(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClusterOnWithBody request with any body
	ClusterOnWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ClusterOn(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body ClusterOnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAiWorkflows request
	ListAiWorkflows(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAiWorkflowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAiWorkflowWithBody request with any body
	CreateAiWorkflowWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAiWorkflow(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateAiWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAiWorkflow request
	DeleteAiWorkflow(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAiWorkflow request
	GetAiWorkflow(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopAiWorkflowRun request
	StopAiWorkflowRun(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAiWorkflowRuns request
	ListAiWorkflowRuns(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, params *ListAiWorkflowRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAiWorkflowRun request
	CreateAiWorkflowRun(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAiWorkflowRun request
	GetAiWorkflowRun(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, runId WorkflowRunId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAiWorkflowRunProcessedFiles request
	GetAiWorkflowRunProcessedFiles(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, runId WorkflowRunId, params *GetAiWorkflowRunProcessedFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllowedCidrs request
	ListAllowedCidrs(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAllowedCidrsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAllowedCidrsWithBody request with any body
	PostAllowedCidrsWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAllowedCidrs(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAllowedCidrsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAllowedCidrByID request
	DeleteAllowedCidrByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllowedCidrByID request
	GetAllowedCidrByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAppServiceWithBody request with any body
	PostAppServiceWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFreeTierAppServiceWithBody request with any body
	CreateFreeTierAppServiceWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFreeTierAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateFreeTierAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFreeTierAppService request
	DeleteFreeTierAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFreeTierAppService request
	GetFreeTierAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFreeTierAppServiceWithBody request with any body
	UpdateFreeTierAppServiceWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *UpdateFreeTierAppServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFreeTierAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *UpdateFreeTierAppServiceParams, body UpdateFreeTierAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAppService request
	DeleteAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppService request
	GetAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAppServiceWithBody request with any body
	PutAppServiceWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *PutAppServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *PutAppServiceParams, body PutAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppServiceOff request
	AppServiceOff(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppServiceOn request
	AppServiceOn(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppServiceAdminUsers request
	ListAppServiceAdminUsers(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAdminUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddAppServiceAdminUserWithBody request with any body
	AddAppServiceAdminUserWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddAppServiceAdminUser(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body AddAppServiceAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAppServiceAdminUser request
	DeleteAppServiceAdminUser(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppServiceAdminUser request
	GetAppServiceAdminUser(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppServiceAdminUserWithBody request with any body
	UpdateAppServiceAdminUserWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAppServiceAdminUser(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, body UpdateAppServiceAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppServiceAllowedCidrs request
	ListAppServiceAllowedCidrs(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAllowedCidrsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAppServiceAllowedCidrWithBody request with any body
	PostAppServiceAllowedCidrWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAppServiceAllowedCidr(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppServiceAllowedCidrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAppServiceAllowedCidr request
	DeleteAppServiceAllowedCidr(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppEndpoints request
	ListAppEndpoints(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAppEndpointWithBody request with any body
	PostAppEndpointWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAppEndpoint(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAccessFunction request
	DeleteAccessFunction(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessFunction request
	GetAccessFunction(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAccessFunctionWithBody request with any body
	PutAccessFunctionWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImportFilter request
	DeleteImportFilter(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImportFilter request
	GetImportFilter(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutImportFilterWithBody request with any body
	PutImportFilterWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAppEndpoint request
	DeleteAppEndpoint(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppEndpoint request
	GetAppEndpoint(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAppEndpointWithBody request with any body
	PutAppEndpointWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutAppEndpoint(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAppEndpointActivationStatus request
	DeleteAppEndpointActivationStatus(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAppEndpointActivationStatus request
	PostAppEndpointActivationStatus(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppEndpointAdminUsers request
	ListAppEndpointAdminUsers(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointAdminUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppEndpointAuditLogConfig request
	GetAppEndpointAuditLogConfig(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAppEndpointAuditLogConfigWithBody request with any body
	PutAppEndpointAuditLogConfigWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutAppEndpointAuditLogConfig(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointAuditLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppServiceAuditLogEvents request
	GetAppServiceAuditLogEvents(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppEndpointCollections request
	ListAppEndpointCollections(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppEndpointCORS request
	GetAppEndpointCORS(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAppEndpointCORSWithBody request with any body
	PutAppEndpointCORSWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutAppEndpointCORS(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointCORSJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppEndpointOIDCProviders request
	ListAppEndpointOIDCProviders(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointOIDCProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAppEndpointOIDCProviderWithBody request with any body
	CreateAppEndpointOIDCProviderWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAppEndpointOIDCProvider(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body CreateAppEndpointOIDCProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppEndpointOIDCDefaultProviderWithBody request with any body
	UpdateAppEndpointOIDCDefaultProviderWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAppEndpointOIDCDefaultProvider(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body UpdateAppEndpointOIDCDefaultProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAppEndpointOIDCProvider request
	DeleteAppEndpointOIDCProvider(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppEndpointOIDCProvider request
	GetAppEndpointOIDCProvider(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppEndpointOIDCProviderWithBody request with any body
	UpdateAppEndpointOIDCProviderWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAppEndpointOIDCProvider(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, body UpdateAppEndpointOIDCProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAppEndpointResync request
	DeleteAppEndpointResync(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppEndpointResync request
	GetAppEndpointResync(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAppEndpointResyncWithBody request with any body
	PostAppEndpointResyncWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAppEndpointResync(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PostAppEndpointResyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppServiceAuditLogState request
	GetAppServiceAuditLogState(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAppServiceAuditLogStateWithBody request with any body
	PutAppServiceAuditLogStateWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutAppServiceAuditLogState(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PutAppServiceAuditLogStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppServiceAuditLogExports request
	ListAppServiceAuditLogExports(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAuditLogExportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAppServiceAuditLogExportWithBody request with any body
	PostAppServiceAuditLogExportWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAppServiceAuditLogExport(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppServiceAuditLogExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppServiceAuditLogExportById request
	GetAppServiceAuditLogExportById(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, auditLogExportId AuditLogExportId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppServiceAuditLogStreaming request
	GetAppServiceAuditLogStreaming(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAppServiceAuditLogStreamingWithBody request with any body
	PatchAppServiceAuditLogStreamingWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchAppServiceAuditLogStreaming(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PatchAppServiceAuditLogStreamingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAppServiceAuditLogStreamingWithBody request with any body
	PutAppServiceAuditLogStreamingWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutAppServiceAuditLogStreaming(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PutAppServiceAuditLogStreamingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppServiceCertificate request
	GetAppServiceCertificate(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAppServicePrivateEndpoints request
	DeleteAppServicePrivateEndpoints(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppServicePrivateEndpoints request
	GetAppServicePrivateEndpoints(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAppServicePrivateEndpoints request
	PostAppServicePrivateEndpoints(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppServicePrivateEndpoints request
	ListAppServicePrivateEndpoints(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePrivateEndpointRequest request
	DeletePrivateEndpointRequest(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptPrivateEndpointRequest request
	AcceptPrivateEndpointRequest(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppServicePrivateEndpointsCommandWithBody request with any body
	GetAppServicePrivateEndpointsCommandWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetAppServicePrivateEndpointsCommand(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body GetAppServicePrivateEndpointsCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterAuditSettings request
	GetClusterAuditSettings(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutClusterAuditSettingsWithBody request with any body
	PutClusterAuditSettingsWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutClusterAuditSettings(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutClusterAuditSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuditLogEventIDs request
	GetAuditLogEventIDs(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuditLogExports request
	ListAuditLogExports(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAuditLogExportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuditLogExportWithBody request with any body
	PostAuditLogExportWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuditLogExport(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAuditLogExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuditLogExport request
	GetAuditLogExport(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, auditLogExportId AuditLogExportId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClusterBackups request
	ListClusterBackups(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBackupCycleByID request
	DeleteBackupCycleByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackupByID request
	GetBackupByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRestoreWithBody request with any body
	PostRestoreWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRestore(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body PostRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutBucketStorageBackendWithBody request with any body
	PutBucketStorageBackendWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutBucketStorageBackend(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutBucketStorageBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuckets request
	ListBuckets(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBucketWithBody request with any body
	PostBucketWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBucket(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFreeTierBuckets request
	ListFreeTierBuckets(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFreeTierBucketWithBody request with any body
	CreateFreeTierBucketWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFreeTierBucket(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateFreeTierBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFreeTierBucketByID request
	DeleteFreeTierBucketByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFreeTierBucketByID request
	GetFreeTierBucketByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFreeTierBucketWithBody request with any body
	UpdateFreeTierBucketWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFreeTierBucket(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body UpdateFreeTierBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBucketByID request
	DeleteBucketByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBucketByID request
	GetBucketByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutBucketWithBody request with any body
	PutBucketWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutBucket(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PutBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCycles request
	ListCycles(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, params *ListCyclesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBackups request
	ListBackups(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, cycleId CycleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBackupSchedule request
	DeleteBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackupSchedule request
	GetBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBackupScheduleWithBody request with any body
	PostBackupScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PostBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutBackupScheduleWithBody request with any body
	PutBackupScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PutBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBackup request
	PostBackup(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FlushBucket request
	FlushBucket(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScopes request
	GetScopes(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostScopeWithBody request with any body
	PostScopeWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostScope(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PostScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteScopeByName request
	DeleteScopeByName(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScopeByName request
	GetScopeByName(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollections request
	GetCollections(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCollectionWithBody request with any body
	PostCollectionWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCollection(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, body PostCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCollectionByName request
	DeleteCollectionByName(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectionByName request
	GetCollectionByName(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutCollectionWithBody request with any body
	PutCollectionWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutCollection(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, body PutCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertificate request
	GetCertificate(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCloudSnapshotBackups request
	ListCloudSnapshotBackups(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListCloudSnapshotBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCloudSnapshotBackupWithBody request with any body
	CreateCloudSnapshotBackupWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCloudSnapshotBackup(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateCloudSnapshotBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGeographicRegions request
	ListGeographicRegions(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCloudSnapshotRestores request
	ListCloudSnapshotRestores(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListCloudSnapshotRestoresParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCloudSnapshotBackup request
	DeleteCloudSnapshotBackup(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditCloudSnapshotBackupRetentionWithBody request with any body
	EditCloudSnapshotBackupRetentionWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditCloudSnapshotBackupRetention(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body EditCloudSnapshotBackupRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreWithBody request with any body
	RestoreWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Restore(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body RestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCloudSnapshotBackupSchedule request
	DeleteCloudSnapshotBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCloudSnapshotBackupSchedule request
	GetCloudSnapshotBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertCloudSnapshotBackupScheduleWithBody request with any body
	UpsertCloudSnapshotBackupScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertCloudSnapshotBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpsertCloudSnapshotBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssociateCMEK request
	AssociateCMEK(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassociateCMEK request
	UnassociateCMEK(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataAPIStatus request
	GetDataAPIStatus(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDataApiAndPeeringWithBody request with any body
	UpdateDataApiAndPeeringWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDataApiAndPeering(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpdateDataApiAndPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataAPIPrivateEndpointCommandWithBody request with any body
	GetDataAPIPrivateEndpointCommandWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetDataAPIPrivateEndpointCommand(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetDataAPIPrivateEndpointCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDataAPIPrivateEndpoints request
	ListDataAPIPrivateEndpoints(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssociateDataAPIPrivateEndpointRequest request
	AssociateDataAPIPrivateEndpointRequest(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisassociateDataAPIPrivateEndpoint request
	DisassociateDataAPIPrivateEndpoint(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMtlsCertificates request
	ListMtlsCertificates(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListMtlsCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMtlsCertificateWithBody request with any body
	AddMtlsCertificateWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddMtlsCertificate(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body AddMtlsCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMtlsCertificate request
	DeleteMtlsCertificate(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMtlsCertificate request
	GetMtlsCertificate(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutMtlsCertificateWithBody request with any body
	PutMtlsCertificateWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutMtlsCertificate(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, body PutMtlsCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMtlsConfiguration request
	GetMtlsConfiguration(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMtlsConfigurationWithBody request with any body
	UpdateMtlsConfigurationWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMtlsConfiguration(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpdateMtlsConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNetworkPeeringRecords request
	ListNetworkPeeringRecords(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListNetworkPeeringRecordsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNetworkPeeringWithBody request with any body
	PostNetworkPeeringWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNetworkPeering(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostNetworkPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAzureVnetPeeringCommandWithBody request with any body
	GetAzureVnetPeeringCommandWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetAzureVnetPeeringCommand(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetAzureVnetPeeringCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNetworkPeering request
	DeleteNetworkPeering(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, peerId PeerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworkPeeringRecord request
	GetNetworkPeeringRecord(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, peerId PeerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOnOffSchedule request
	DeleteOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOnOffSchedule request
	GetOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOnOffScheduleWithBody request with any body
	PostOnOffScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutOnOffScheduleWithBody request with any body
	PutOnOffScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisablePrivateEndpointService request
	DisablePrivateEndpointService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrivateEndpointServiceStatus request
	GetPrivateEndpointServiceStatus(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnablePrivateEndpointService request
	EnablePrivateEndpointService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrivateEndpointCommandWithBody request with any body
	GetPrivateEndpointCommandWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPrivateEndpointCommand(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetPrivateEndpointCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPrivateEndpoints request
	ListPrivateEndpoints(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptPrivateEndpoint request
	AcceptPrivateEndpoint(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePrivateEndpoint request
	DeletePrivateEndpoint(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IndexBuildStatus request
	IndexBuildStatus(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, indexName IndexName, params *IndexBuildStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIndexDefinitions request
	ListIndexDefinitions(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListIndexDefinitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManageQueryIndexesWithBody request with any body
	ManageQueryIndexesWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ManageQueryIndexes(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body ManageQueryIndexesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IndexDefinition request
	IndexDefinition(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, indexName IndexName, params *IndexDefinitionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClusterReplications request
	ListClusterReplications(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListClusterReplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateReplicationWithBody request with any body
	CreateReplicationWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateReplication(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateReplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReplication request
	DeleteReplication(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReplication request
	GetReplication(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateReplicationWithBody request with any body
	UpdateReplicationWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateReplication(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, body UpdateReplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PauseReplication request
	PauseReplication(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeReplication request
	ResumeReplication(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSampleBuckets request
	ListSampleBuckets(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSampleBucketWithBody request with any body
	PostSampleBucketWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSampleBucket(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostSampleBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSampleDataByBucketID request
	DeleteSampleDataByBucketID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSampleBucketById request
	GetSampleBucketById(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDatabaseCredentials request
	ListDatabaseCredentials(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListDatabaseCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDatabaseCredentialWithBody request with any body
	PostDatabaseCredentialWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDatabaseCredential(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostDatabaseCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDatabaseCredential request
	DeleteDatabaseCredential(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabaseCredential request
	GetDatabaseCredential(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutDatabaseCredentialWithBody request with any body
	PutDatabaseCredentialWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, params *PutDatabaseCredentialParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutDatabaseCredential(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, params *PutDatabaseCredentialParams, body PutDatabaseCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectEvents request
	ListProjectEvents(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectEventByID request
	GetProjectEventByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, eventId EventId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectReplications request
	ListProjectReplications(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectReplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, organizationId OrganizationId, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUserWithBody request with any body
	PostUserWithBody(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUser(ctx context.Context, organizationId OrganizationId, body PostUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, organizationId OrganizationId, userId CPUserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, organizationId OrganizationId, userId CPUserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUserWithBody request with any body
	PatchUserWithBody(ctx context.Context, organizationId OrganizationId, userId CPUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUser(ctx context.Context, organizationId OrganizationId, userId CPUserId, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListOrganizations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrganizationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationByID(ctx context.Context, organizationId OrganizationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationByIDRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModels(ctx context.Context, organizationId OrganizationId, params *ListModelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModelsRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModelWithBody(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModelRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModel(ctx context.Context, organizationId OrganizationId, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModelRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DestroyModel(ctx context.Context, organizationId OrganizationId, modelId ModelId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroyModelRequest(c.Server, organizationId, modelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModel(ctx context.Context, organizationId OrganizationId, modelId ModelId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModelRequest(c.Server, organizationId, modelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModelAPIKeys(ctx context.Context, organizationId OrganizationId, modelId ModelId, params *ListModelAPIKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModelAPIKeysRequest(c.Server, organizationId, modelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModelAPIKeyWithBody(ctx context.Context, organizationId OrganizationId, modelId ModelId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModelAPIKeyRequestWithBody(c.Server, organizationId, modelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModelAPIKey(ctx context.Context, organizationId OrganizationId, modelId ModelId, body CreateModelAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModelAPIKeyRequest(c.Server, organizationId, modelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModelAPIKey(ctx context.Context, organizationId OrganizationId, modelId ModelId, apiKeyId ModelAPIKeyId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModelAPIKeyRequest(c.Server, organizationId, modelId, apiKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModelAPIKey(ctx context.Context, organizationId OrganizationId, modelId ModelId, apiKeyId ModelAPIKeyId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModelAPIKeyRequest(c.Server, organizationId, modelId, apiKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnectionString(ctx context.Context, organizationId OrganizationId, modelId ModelId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectionStringRequest(c.Server, organizationId, modelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProviders(ctx context.Context, organizationId OrganizationId, params *ListProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProvidersRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProviderWithBody(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProviderRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProvider(ctx context.Context, organizationId OrganizationId, body CreateProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProviderRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProvider(ctx context.Context, organizationId OrganizationId, providerId ProviderId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProviderRequest(c.Server, organizationId, providerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProvider(ctx context.Context, organizationId OrganizationId, providerId ProviderId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProviderRequest(c.Server, organizationId, providerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProviderWithBody(ctx context.Context, organizationId OrganizationId, providerId ProviderId, params *UpdateProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProviderRequestWithBody(c.Server, organizationId, providerId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProvider(ctx context.Context, organizationId OrganizationId, providerId ProviderId, params *UpdateProviderParams, body UpdateProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProviderRequest(c.Server, organizationId, providerId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOrganizationLevelAnalyticsClusters(ctx context.Context, organizationId OrganizationId, params *ListOrganizationLevelAnalyticsClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrganizationLevelAnalyticsClustersRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOrganizationAPIKeys(ctx context.Context, organizationId OrganizationId, params *ListOrganizationAPIKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrganizationAPIKeysRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrganizationAPIKeysWithBody(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrganizationAPIKeysRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrganizationAPIKeys(ctx context.Context, organizationId OrganizationId, body PostOrganizationAPIKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrganizationAPIKeysRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationAPIKey(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationAPIKeyRequest(c.Server, organizationId, apiKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationAPIKeyByAccessKey(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationAPIKeyByAccessKeyRequest(c.Server, organizationId, apiKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrganizationAPIKeyRotateWithBody(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrganizationAPIKeyRotateRequestWithBody(c.Server, organizationId, apiKeyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrganizationAPIKeyRotate(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, body PostOrganizationAPIKeyRotateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrganizationAPIKeyRotateRequest(c.Server, organizationId, apiKeyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppServices(ctx context.Context, organizationId OrganizationId, params *ListAppServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppServicesRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCloudAccounts(ctx context.Context, organizationId OrganizationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCloudAccountsRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeyMetadataList(ctx context.Context, organizationId OrganizationId, params *GetKeyMetadataListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeyMetadataListRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCMEKMetadataWithBody(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCMEKMetadataRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCMEKMetadata(ctx context.Context, organizationId OrganizationId, body PostCMEKMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCMEKMetadataRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeyMetadata(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeyMetadataRequest(c.Server, organizationId, cmekId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeyMetadata(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeyMetadataRequest(c.Server, organizationId, cmekId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RotateCMEKKeyWithBody(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRotateCMEKKeyRequestWithBody(c.Server, organizationId, cmekId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RotateCMEKKey(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, body RotateCMEKKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRotateCMEKKeyRequest(c.Server, organizationId, cmekId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCMEKHistory(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, params *ListCMEKHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCMEKHistoryRequest(c.Server, organizationId, cmekId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutOrganizationConfigurationWithBody(ctx context.Context, organizationId OrganizationId, params *PutOrganizationConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutOrganizationConfigurationRequestWithBody(c.Server, organizationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutOrganizationConfiguration(ctx context.Context, organizationId OrganizationId, params *PutOrganizationConfigurationParams, body PutOrganizationConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutOrganizationConfigurationRequest(c.Server, organizationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEvents(ctx context.Context, organizationId OrganizationId, params *ListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventsRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventByID(ctx context.Context, organizationId OrganizationId, eventId EventId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventByIDRequest(c.Server, organizationId, eventId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjects(ctx context.Context, organizationId OrganizationId, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectsRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProjectWithBody(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProjectRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProject(ctx context.Context, organizationId OrganizationId, body PostProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProjectRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectByIDRequest(c.Server, organizationId, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectByIDRequest(c.Server, organizationId, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutProjectWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *PutProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutProjectRequestWithBody(c.Server, organizationId, projectId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutProject(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *PutProjectParams, body PutProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutProjectRequest(c.Server, organizationId, projectId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTestAlertIntegrationWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTestAlertIntegrationRequestWithBody(c.Server, organizationId, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTestAlertIntegration(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body PostTestAlertIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTestAlertIntegrationRequest(c.Server, organizationId, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAlertIntegrations(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListAlertIntegrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAlertIntegrationsRequest(c.Server, organizationId, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAlertIntegrationWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAlertIntegrationRequestWithBody(c.Server, organizationId, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAlertIntegration(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body PostAlertIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAlertIntegrationRequest(c.Server, organizationId, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAlertIntegrationByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAlertIntegrationByIDRequest(c.Server, organizationId, projectId, alertIntegrationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlertIntegrationByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlertIntegrationByIDRequest(c.Server, organizationId, projectId, alertIntegrationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAlertIntegrationWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAlertIntegrationRequestWithBody(c.Server, organizationId, projectId, alertIntegrationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAlertIntegration(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, body PutAlertIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAlertIntegrationRequest(c.Server, organizationId, projectId, alertIntegrationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectLevelAnalyticsClusters(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectLevelAnalyticsClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectLevelAnalyticsClustersRequest(c.Server, organizationId, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAnalyticsClusterWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAnalyticsClusterRequestWithBody(c.Server, organizationId, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAnalyticsCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body CreateAnalyticsClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAnalyticsClusterRequest(c.Server, organizationId, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAnalyticsCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAnalyticsClusterRequest(c.Server, organizationId, projectId, analyticsClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnalyticsCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnalyticsClusterRequest(c.Server, organizationId, projectId, analyticsClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAnalyticsClusterWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *PutAnalyticsClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAnalyticsClusterRequestWithBody(c.Server, organizationId, projectId, analyticsClusterId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAnalyticsCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *PutAnalyticsClusterParams, body PutAnalyticsClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAnalyticsClusterRequest(c.Server, organizationId, projectId, analyticsClusterId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnalyticsClusterOff(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnalyticsClusterOffRequest(c.Server, organizationId, projectId, analyticsClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnalyticsClusterOn(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnalyticsClusterOnRequest(c.Server, organizationId, projectId, analyticsClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAnalyticsAllowedCidrs(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListAnalyticsAllowedCidrsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAnalyticsAllowedCidrsRequest(c.Server, organizationId, projectId, analyticsClusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnalyticsAllowedCidrWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnalyticsAllowedCidrRequestWithBody(c.Server, organizationId, projectId, analyticsClusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnalyticsAllowedCidr(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PostAnalyticsAllowedCidrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnalyticsAllowedCidrRequest(c.Server, organizationId, projectId, analyticsClusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteColumnarAllowedCidrByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteColumnarAllowedCidrByIDRequest(c.Server, organizationId, projectId, analyticsClusterId, allowedCidrId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetColumnarAllowedCidrByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetColumnarAllowedCidrByIDRequest(c.Server, organizationId, projectId, analyticsClusterId, allowedCidrId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteColumnarAnalyticsBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteColumnarAnalyticsBackupScheduleRequest(c.Server, organizationId, projectId, analyticsClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetColumnarAnalyticsBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetColumnarAnalyticsBackupScheduleRequest(c.Server, organizationId, projectId, analyticsClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertColumnarAnalyticsBackupScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertColumnarAnalyticsBackupScheduleRequestWithBody(c.Server, organizationId, projectId, analyticsClusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertColumnarAnalyticsBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body UpsertColumnarAnalyticsBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertColumnarAnalyticsBackupScheduleRequest(c.Server, organizationId, projectId, analyticsClusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListColumnarAnalyticsBackups(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListColumnarAnalyticsBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListColumnarAnalyticsBackupsRequest(c.Server, organizationId, projectId, analyticsClusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateColumnarAnalyticsBackupWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateColumnarAnalyticsBackupRequestWithBody(c.Server, organizationId, projectId, analyticsClusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateColumnarAnalyticsBackup(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body CreateColumnarAnalyticsBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateColumnarAnalyticsBackupRequest(c.Server, organizationId, projectId, analyticsClusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListColumnarAnalyticsRestores(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListColumnarAnalyticsRestoresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListColumnarAnalyticsRestoresRequest(c.Server, organizationId, projectId, analyticsClusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteColumnarAnalyticsBackup(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteColumnarAnalyticsBackupRequest(c.Server, organizationId, projectId, analyticsClusterId, backupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateColumnarAnalyticsBackupRetentionWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateColumnarAnalyticsBackupRetentionRequestWithBody(c.Server, organizationId, projectId, analyticsClusterId, backupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateColumnarAnalyticsBackupRetention(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, body UpdateColumnarAnalyticsBackupRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateColumnarAnalyticsBackupRetentionRequest(c.Server, organizationId, projectId, analyticsClusterId, backupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreColumnarAnalyticsCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreColumnarAnalyticsClusterRequest(c.Server, organizationId, projectId, analyticsClusterId, backupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAnalyticsOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAnalyticsOnOffScheduleRequest(c.Server, organizationId, projectId, analyticsClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnalyticsOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnalyticsOnOffScheduleRequest(c.Server, organizationId, projectId, analyticsClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnalyticsOnOffScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnalyticsOnOffScheduleRequestWithBody(c.Server, organizationId, projectId, analyticsClusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnalyticsOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PostAnalyticsOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnalyticsOnOffScheduleRequest(c.Server, organizationId, projectId, analyticsClusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAnalyticsOnOffScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAnalyticsOnOffScheduleRequestWithBody(c.Server, organizationId, projectId, analyticsClusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAnalyticsOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PutAnalyticsOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAnalyticsOnOffScheduleRequest(c.Server, organizationId, projectId, analyticsClusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableColumnarPrivateEndpointService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableColumnarPrivateEndpointServiceRequest(c.Server, organizationId, projectId, analyticsClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetColumnarPrivateEndpointServiceStatus(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetColumnarPrivateEndpointServiceStatusRequest(c.Server, organizationId, projectId, analyticsClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableColumnarPrivateEndpointService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableColumnarPrivateEndpointServiceRequest(c.Server, organizationId, projectId, analyticsClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetColumnarPrivateEndpointServiceCommandWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetColumnarPrivateEndpointServiceCommandRequestWithBody(c.Server, organizationId, projectId, analyticsClusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetColumnarPrivateEndpointServiceCommand(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body GetColumnarPrivateEndpointServiceCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetColumnarPrivateEndpointServiceCommandRequest(c.Server, organizationId, projectId, analyticsClusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListColumnarPrivateEndpointServiceConnection(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListColumnarPrivateEndpointServiceConnectionRequest(c.Server, organizationId, projectId, analyticsClusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptColumnarPrivateEndpointServiceConnection(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptColumnarPrivateEndpointServiceConnectionRequest(c.Server, organizationId, projectId, analyticsClusterId, endpointId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RejectColumnarPrivateEndpointServiceConnection(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRejectColumnarPrivateEndpointServiceConnectionRequest(c.Server, organizationId, projectId, analyticsClusterId, endpointId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectLevelCloudSnapshotBackups(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectLevelCloudSnapshotBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectLevelCloudSnapshotBackupsRequest(c.Server, organizationId, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloneWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloneRequestWithBody(c.Server, organizationId, projectId, backupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Clone(ctx context.Context, organizationId OrganizationId, projectId ProjectId, backupId BackupId, body CloneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloneRequest(c.Server, organizationId, projectId, backupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusters(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClustersRequest(c.Server, organizationId, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClusterWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClusterRequestWithBody(c.Server, organizationId, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClusterRequest(c.Server, organizationId, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFreeTierClusterWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFreeTierClusterRequestWithBody(c.Server, organizationId, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFreeTierCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body CreateFreeTierClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFreeTierClusterRequest(c.Server, organizationId, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFreeTierCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFreeTierClusterRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFreeTierCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFreeTierClusterRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFreeTierClusterWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *UpdateFreeTierClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFreeTierClusterRequestWithBody(c.Server, organizationId, projectId, clusterId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFreeTierCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *UpdateFreeTierClusterParams, body UpdateFreeTierClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFreeTierClusterRequest(c.Server, organizationId, projectId, clusterId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FreeTierClusterOff(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFreeTierClusterOffRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FreeTierClusterOn(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFreeTierClusterOnRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, organizationId, projectId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutClusterWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *PutClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutClusterRequestWithBody(c.Server, organizationId, projectId, clusterId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutCluster(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *PutClusterParams, body PutClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutClusterRequest(c.Server, organizationId, projectId, clusterId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClusterOff(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClusterOffRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClusterOnWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClusterOnRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClusterOn(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body ClusterOnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClusterOnRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAiWorkflows(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAiWorkflowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAiWorkflowsRequest(c.Server, organizationId, projectId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAiWorkflowWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAiWorkflowRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAiWorkflow(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateAiWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAiWorkflowRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAiWorkflow(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAiWorkflowRequest(c.Server, organizationId, projectId, clusterId, workflowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAiWorkflow(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAiWorkflowRequest(c.Server, organizationId, projectId, clusterId, workflowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopAiWorkflowRun(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopAiWorkflowRunRequest(c.Server, organizationId, projectId, clusterId, workflowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAiWorkflowRuns(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, params *ListAiWorkflowRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAiWorkflowRunsRequest(c.Server, organizationId, projectId, clusterId, workflowId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAiWorkflowRun(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAiWorkflowRunRequest(c.Server, organizationId, projectId, clusterId, workflowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAiWorkflowRun(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, runId WorkflowRunId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAiWorkflowRunRequest(c.Server, organizationId, projectId, clusterId, workflowId, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAiWorkflowRunProcessedFiles(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, runId WorkflowRunId, params *GetAiWorkflowRunProcessedFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAiWorkflowRunProcessedFilesRequest(c.Server, organizationId, projectId, clusterId, workflowId, runId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllowedCidrs(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAllowedCidrsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllowedCidrsRequest(c.Server, organizationId, projectId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAllowedCidrsWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAllowedCidrsRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAllowedCidrs(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAllowedCidrsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAllowedCidrsRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAllowedCidrByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAllowedCidrByIDRequest(c.Server, organizationId, projectId, clusterId, allowedCidrId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllowedCidrByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllowedCidrByIDRequest(c.Server, organizationId, projectId, clusterId, allowedCidrId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppServiceWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppServiceRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppServiceRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFreeTierAppServiceWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFreeTierAppServiceRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFreeTierAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateFreeTierAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFreeTierAppServiceRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFreeTierAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFreeTierAppServiceRequest(c.Server, organizationId, projectId, clusterId, appServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFreeTierAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFreeTierAppServiceRequest(c.Server, organizationId, projectId, clusterId, appServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFreeTierAppServiceWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *UpdateFreeTierAppServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFreeTierAppServiceRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFreeTierAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *UpdateFreeTierAppServiceParams, body UpdateFreeTierAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFreeTierAppServiceRequest(c.Server, organizationId, projectId, clusterId, appServiceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppServiceRequest(c.Server, organizationId, projectId, clusterId, appServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppServiceRequest(c.Server, organizationId, projectId, clusterId, appServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAppServiceWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *PutAppServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAppServiceRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAppService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *PutAppServiceParams, body PutAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAppServiceRequest(c.Server, organizationId, projectId, clusterId, appServiceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppServiceOff(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppServiceOffRequest(c.Server, organizationId, projectId, clusterId, appServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppServiceOn(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppServiceOnRequest(c.Server, organizationId, projectId, clusterId, appServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppServiceAdminUsers(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAdminUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppServiceAdminUsersRequest(c.Server, organizationId, projectId, clusterId, appServiceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAppServiceAdminUserWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAppServiceAdminUserRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAppServiceAdminUser(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body AddAppServiceAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAppServiceAdminUserRequest(c.Server, organizationId, projectId, clusterId, appServiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAppServiceAdminUser(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppServiceAdminUserRequest(c.Server, organizationId, projectId, clusterId, appServiceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppServiceAdminUser(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppServiceAdminUserRequest(c.Server, organizationId, projectId, clusterId, appServiceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppServiceAdminUserWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppServiceAdminUserRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppServiceAdminUser(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, body UpdateAppServiceAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppServiceAdminUserRequest(c.Server, organizationId, projectId, clusterId, appServiceId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppServiceAllowedCidrs(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAllowedCidrsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppServiceAllowedCidrsRequest(c.Server, organizationId, projectId, clusterId, appServiceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppServiceAllowedCidrWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppServiceAllowedCidrRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppServiceAllowedCidr(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppServiceAllowedCidrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppServiceAllowedCidrRequest(c.Server, organizationId, projectId, clusterId, appServiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAppServiceAllowedCidr(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppServiceAllowedCidrRequest(c.Server, organizationId, projectId, clusterId, appServiceId, allowedCidrId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppEndpoints(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppEndpointsRequest(c.Server, organizationId, projectId, clusterId, appServiceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppEndpointWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppEndpointRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppEndpoint(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppEndpointRequest(c.Server, organizationId, projectId, clusterId, appServiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAccessFunction(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccessFunctionRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointKeyspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessFunction(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessFunctionRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointKeyspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAccessFunctionWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAccessFunctionRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointKeyspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImportFilter(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImportFilterRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointKeyspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImportFilter(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImportFilterRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointKeyspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutImportFilterWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutImportFilterRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointKeyspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAppEndpoint(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppEndpointRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppEndpoint(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppEndpointRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAppEndpointWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAppEndpointRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAppEndpoint(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAppEndpointRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAppEndpointActivationStatus(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppEndpointActivationStatusRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppEndpointActivationStatus(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppEndpointActivationStatusRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppEndpointAdminUsers(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointAdminUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppEndpointAdminUsersRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppEndpointAuditLogConfig(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppEndpointAuditLogConfigRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAppEndpointAuditLogConfigWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAppEndpointAuditLogConfigRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAppEndpointAuditLogConfig(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointAuditLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAppEndpointAuditLogConfigRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppServiceAuditLogEvents(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppServiceAuditLogEventsRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppEndpointCollections(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppEndpointCollectionsRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppEndpointCORS(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppEndpointCORSRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAppEndpointCORSWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAppEndpointCORSRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAppEndpointCORS(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointCORSJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAppEndpointCORSRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppEndpointOIDCProviders(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointOIDCProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppEndpointOIDCProvidersRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppEndpointOIDCProviderWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppEndpointOIDCProviderRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppEndpointOIDCProvider(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body CreateAppEndpointOIDCProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppEndpointOIDCProviderRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppEndpointOIDCDefaultProviderWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppEndpointOIDCDefaultProviderRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppEndpointOIDCDefaultProvider(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body UpdateAppEndpointOIDCDefaultProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppEndpointOIDCDefaultProviderRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAppEndpointOIDCProvider(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppEndpointOIDCProviderRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, oidcProviderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppEndpointOIDCProvider(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppEndpointOIDCProviderRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, oidcProviderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppEndpointOIDCProviderWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppEndpointOIDCProviderRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, oidcProviderId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppEndpointOIDCProvider(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, body UpdateAppEndpointOIDCProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppEndpointOIDCProviderRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, oidcProviderId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAppEndpointResync(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppEndpointResyncRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppEndpointResync(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppEndpointResyncRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppEndpointResyncWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppEndpointResyncRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppEndpointResync(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PostAppEndpointResyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppEndpointResyncRequest(c.Server, organizationId, projectId, clusterId, appServiceId, appEndpointName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppServiceAuditLogState(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppServiceAuditLogStateRequest(c.Server, organizationId, projectId, clusterId, appServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAppServiceAuditLogStateWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAppServiceAuditLogStateRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAppServiceAuditLogState(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PutAppServiceAuditLogStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAppServiceAuditLogStateRequest(c.Server, organizationId, projectId, clusterId, appServiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppServiceAuditLogExports(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAuditLogExportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppServiceAuditLogExportsRequest(c.Server, organizationId, projectId, clusterId, appServiceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppServiceAuditLogExportWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppServiceAuditLogExportRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppServiceAuditLogExport(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppServiceAuditLogExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppServiceAuditLogExportRequest(c.Server, organizationId, projectId, clusterId, appServiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppServiceAuditLogExportById(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, auditLogExportId AuditLogExportId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppServiceAuditLogExportByIdRequest(c.Server, organizationId, projectId, clusterId, appServiceId, auditLogExportId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppServiceAuditLogStreaming(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppServiceAuditLogStreamingRequest(c.Server, organizationId, projectId, clusterId, appServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAppServiceAuditLogStreamingWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAppServiceAuditLogStreamingRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAppServiceAuditLogStreaming(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PatchAppServiceAuditLogStreamingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAppServiceAuditLogStreamingRequest(c.Server, organizationId, projectId, clusterId, appServiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAppServiceAuditLogStreamingWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAppServiceAuditLogStreamingRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAppServiceAuditLogStreaming(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PutAppServiceAuditLogStreamingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAppServiceAuditLogStreamingRequest(c.Server, organizationId, projectId, clusterId, appServiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppServiceCertificate(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppServiceCertificateRequest(c.Server, organizationId, projectId, clusterId, appServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAppServicePrivateEndpoints(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppServicePrivateEndpointsRequest(c.Server, organizationId, projectId, clusterId, appServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppServicePrivateEndpoints(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppServicePrivateEndpointsRequest(c.Server, organizationId, projectId, clusterId, appServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppServicePrivateEndpoints(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppServicePrivateEndpointsRequest(c.Server, organizationId, projectId, clusterId, appServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppServicePrivateEndpoints(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppServicePrivateEndpointsRequest(c.Server, organizationId, projectId, clusterId, appServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePrivateEndpointRequest(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePrivateEndpointRequestRequest(c.Server, organizationId, projectId, clusterId, appServiceId, endpointId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptPrivateEndpointRequest(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptPrivateEndpointRequestRequest(c.Server, organizationId, projectId, clusterId, appServiceId, endpointId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppServicePrivateEndpointsCommandWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppServicePrivateEndpointsCommandRequestWithBody(c.Server, organizationId, projectId, clusterId, appServiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppServicePrivateEndpointsCommand(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body GetAppServicePrivateEndpointsCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppServicePrivateEndpointsCommandRequest(c.Server, organizationId, projectId, clusterId, appServiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterAuditSettings(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterAuditSettingsRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutClusterAuditSettingsWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutClusterAuditSettingsRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutClusterAuditSettings(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutClusterAuditSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutClusterAuditSettingsRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuditLogEventIDs(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuditLogEventIDsRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuditLogExports(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAuditLogExportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuditLogExportsRequest(c.Server, organizationId, projectId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuditLogExportWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuditLogExportRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuditLogExport(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAuditLogExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuditLogExportRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuditLogExport(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, auditLogExportId AuditLogExportId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuditLogExportRequest(c.Server, organizationId, projectId, clusterId, auditLogExportId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusterBackups(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClusterBackupsRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackupCycleByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBackupCycleByIDRequest(c.Server, organizationId, projectId, clusterId, backupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackupByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupByIDRequest(c.Server, organizationId, projectId, clusterId, backupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRestoreWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRestoreRequestWithBody(c.Server, organizationId, projectId, clusterId, backupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRestore(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body PostRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRestoreRequest(c.Server, organizationId, projectId, clusterId, backupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutBucketStorageBackendWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutBucketStorageBackendRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutBucketStorageBackend(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutBucketStorageBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutBucketStorageBackendRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuckets(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBucketsRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBucketWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBucketRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBucket(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBucketRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFreeTierBuckets(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFreeTierBucketsRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFreeTierBucketWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFreeTierBucketRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFreeTierBucket(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateFreeTierBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFreeTierBucketRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFreeTierBucketByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFreeTierBucketByIDRequest(c.Server, organizationId, projectId, clusterId, bucketId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFreeTierBucketByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFreeTierBucketByIDRequest(c.Server, organizationId, projectId, clusterId, bucketId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFreeTierBucketWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFreeTierBucketRequestWithBody(c.Server, organizationId, projectId, clusterId, bucketId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFreeTierBucket(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body UpdateFreeTierBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFreeTierBucketRequest(c.Server, organizationId, projectId, clusterId, bucketId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBucketByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBucketByIDRequest(c.Server, organizationId, projectId, clusterId, bucketId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBucketByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBucketByIDRequest(c.Server, organizationId, projectId, clusterId, bucketId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutBucketWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutBucketRequestWithBody(c.Server, organizationId, projectId, clusterId, bucketId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutBucket(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PutBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutBucketRequest(c.Server, organizationId, projectId, clusterId, bucketId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCycles(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, params *ListCyclesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCyclesRequest(c.Server, organizationId, projectId, clusterId, bucketId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBackups(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, cycleId CycleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBackupsRequest(c.Server, organizationId, projectId, clusterId, bucketId, cycleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBackupScheduleRequest(c.Server, organizationId, projectId, clusterId, bucketId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupScheduleRequest(c.Server, organizationId, projectId, clusterId, bucketId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBackupScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBackupScheduleRequestWithBody(c.Server, organizationId, projectId, clusterId, bucketId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PostBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBackupScheduleRequest(c.Server, organizationId, projectId, clusterId, bucketId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutBackupScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutBackupScheduleRequestWithBody(c.Server, organizationId, projectId, clusterId, bucketId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PutBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutBackupScheduleRequest(c.Server, organizationId, projectId, clusterId, bucketId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBackup(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBackupRequest(c.Server, organizationId, projectId, clusterId, bucketId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FlushBucket(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFlushBucketRequest(c.Server, organizationId, projectId, clusterId, bucketId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScopes(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScopesRequest(c.Server, organizationId, projectId, clusterId, bucketId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostScopeWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostScopeRequestWithBody(c.Server, organizationId, projectId, clusterId, bucketId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostScope(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PostScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostScopeRequest(c.Server, organizationId, projectId, clusterId, bucketId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteScopeByName(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScopeByNameRequest(c.Server, organizationId, projectId, clusterId, bucketId, scopeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScopeByName(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScopeByNameRequest(c.Server, organizationId, projectId, clusterId, bucketId, scopeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollections(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionsRequest(c.Server, organizationId, projectId, clusterId, bucketId, scopeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCollectionWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCollectionRequestWithBody(c.Server, organizationId, projectId, clusterId, bucketId, scopeName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCollection(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, body PostCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCollectionRequest(c.Server, organizationId, projectId, clusterId, bucketId, scopeName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCollectionByName(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCollectionByNameRequest(c.Server, organizationId, projectId, clusterId, bucketId, scopeName, collectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectionByName(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionByNameRequest(c.Server, organizationId, projectId, clusterId, bucketId, scopeName, collectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutCollectionWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutCollectionRequestWithBody(c.Server, organizationId, projectId, clusterId, bucketId, scopeName, collectionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutCollection(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, body PutCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutCollectionRequest(c.Server, organizationId, projectId, clusterId, bucketId, scopeName, collectionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertificate(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertificateRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCloudSnapshotBackups(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListCloudSnapshotBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCloudSnapshotBackupsRequest(c.Server, organizationId, projectId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCloudSnapshotBackupWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCloudSnapshotBackupRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCloudSnapshotBackup(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateCloudSnapshotBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCloudSnapshotBackupRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGeographicRegions(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGeographicRegionsRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCloudSnapshotRestores(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListCloudSnapshotRestoresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCloudSnapshotRestoresRequest(c.Server, organizationId, projectId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCloudSnapshotBackup(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCloudSnapshotBackupRequest(c.Server, organizationId, projectId, clusterId, backupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCloudSnapshotBackupRetentionWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCloudSnapshotBackupRetentionRequestWithBody(c.Server, organizationId, projectId, clusterId, backupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCloudSnapshotBackupRetention(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body EditCloudSnapshotBackupRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCloudSnapshotBackupRetentionRequest(c.Server, organizationId, projectId, clusterId, backupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreRequestWithBody(c.Server, organizationId, projectId, clusterId, backupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Restore(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body RestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreRequest(c.Server, organizationId, projectId, clusterId, backupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCloudSnapshotBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCloudSnapshotBackupScheduleRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCloudSnapshotBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCloudSnapshotBackupScheduleRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertCloudSnapshotBackupScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertCloudSnapshotBackupScheduleRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertCloudSnapshotBackupSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpsertCloudSnapshotBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertCloudSnapshotBackupScheduleRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssociateCMEK(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssociateCMEKRequest(c.Server, organizationId, projectId, clusterId, cmekId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassociateCMEK(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassociateCMEKRequest(c.Server, organizationId, projectId, clusterId, cmekId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataAPIStatus(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataAPIStatusRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDataApiAndPeeringWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDataApiAndPeeringRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDataApiAndPeering(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpdateDataApiAndPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDataApiAndPeeringRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataAPIPrivateEndpointCommandWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataAPIPrivateEndpointCommandRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataAPIPrivateEndpointCommand(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetDataAPIPrivateEndpointCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataAPIPrivateEndpointCommandRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDataAPIPrivateEndpoints(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDataAPIPrivateEndpointsRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssociateDataAPIPrivateEndpointRequest(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssociateDataAPIPrivateEndpointRequestRequest(c.Server, organizationId, projectId, clusterId, endpointId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisassociateDataAPIPrivateEndpoint(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisassociateDataAPIPrivateEndpointRequest(c.Server, organizationId, projectId, clusterId, endpointId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMtlsCertificates(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListMtlsCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMtlsCertificatesRequest(c.Server, organizationId, projectId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMtlsCertificateWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMtlsCertificateRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMtlsCertificate(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body AddMtlsCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMtlsCertificateRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMtlsCertificate(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMtlsCertificateRequest(c.Server, organizationId, projectId, clusterId, certId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMtlsCertificate(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMtlsCertificateRequest(c.Server, organizationId, projectId, clusterId, certId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutMtlsCertificateWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutMtlsCertificateRequestWithBody(c.Server, organizationId, projectId, clusterId, certId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutMtlsCertificate(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, body PutMtlsCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutMtlsCertificateRequest(c.Server, organizationId, projectId, clusterId, certId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMtlsConfiguration(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMtlsConfigurationRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMtlsConfigurationWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMtlsConfigurationRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMtlsConfiguration(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpdateMtlsConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMtlsConfigurationRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNetworkPeeringRecords(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListNetworkPeeringRecordsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNetworkPeeringRecordsRequest(c.Server, organizationId, projectId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNetworkPeeringWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNetworkPeeringRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNetworkPeering(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostNetworkPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNetworkPeeringRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAzureVnetPeeringCommandWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAzureVnetPeeringCommandRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAzureVnetPeeringCommand(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetAzureVnetPeeringCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAzureVnetPeeringCommandRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNetworkPeering(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, peerId PeerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNetworkPeeringRequest(c.Server, organizationId, projectId, clusterId, peerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkPeeringRecord(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, peerId PeerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkPeeringRecordRequest(c.Server, organizationId, projectId, clusterId, peerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOnOffScheduleRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOnOffScheduleRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOnOffScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOnOffScheduleRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOnOffScheduleRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutOnOffScheduleWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutOnOffScheduleRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutOnOffSchedule(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutOnOffScheduleRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisablePrivateEndpointService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisablePrivateEndpointServiceRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrivateEndpointServiceStatus(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPrivateEndpointServiceStatusRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnablePrivateEndpointService(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnablePrivateEndpointServiceRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrivateEndpointCommandWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPrivateEndpointCommandRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrivateEndpointCommand(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetPrivateEndpointCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPrivateEndpointCommandRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPrivateEndpoints(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPrivateEndpointsRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptPrivateEndpoint(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptPrivateEndpointRequest(c.Server, organizationId, projectId, clusterId, endpointId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePrivateEndpoint(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePrivateEndpointRequest(c.Server, organizationId, projectId, clusterId, endpointId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IndexBuildStatus(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, indexName IndexName, params *IndexBuildStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIndexBuildStatusRequest(c.Server, organizationId, projectId, clusterId, indexName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIndexDefinitions(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListIndexDefinitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIndexDefinitionsRequest(c.Server, organizationId, projectId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManageQueryIndexesWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManageQueryIndexesRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManageQueryIndexes(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body ManageQueryIndexesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManageQueryIndexesRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IndexDefinition(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, indexName IndexName, params *IndexDefinitionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIndexDefinitionRequest(c.Server, organizationId, projectId, clusterId, indexName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusterReplications(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListClusterReplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClusterReplicationsRequest(c.Server, organizationId, projectId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReplicationWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReplicationRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReplication(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateReplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReplicationRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReplication(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReplicationRequest(c.Server, organizationId, projectId, clusterId, replicationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReplication(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReplicationRequest(c.Server, organizationId, projectId, clusterId, replicationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateReplicationWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateReplicationRequestWithBody(c.Server, organizationId, projectId, clusterId, replicationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateReplication(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, body UpdateReplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateReplicationRequest(c.Server, organizationId, projectId, clusterId, replicationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PauseReplication(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPauseReplicationRequest(c.Server, organizationId, projectId, clusterId, replicationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeReplication(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeReplicationRequest(c.Server, organizationId, projectId, clusterId, replicationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSampleBuckets(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSampleBucketsRequest(c.Server, organizationId, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSampleBucketWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSampleBucketRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSampleBucket(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostSampleBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSampleBucketRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSampleDataByBucketID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSampleDataByBucketIDRequest(c.Server, organizationId, projectId, clusterId, bucketId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSampleBucketById(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSampleBucketByIdRequest(c.Server, organizationId, projectId, clusterId, bucketId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDatabaseCredentials(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListDatabaseCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDatabaseCredentialsRequest(c.Server, organizationId, projectId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDatabaseCredentialWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDatabaseCredentialRequestWithBody(c.Server, organizationId, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDatabaseCredential(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostDatabaseCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDatabaseCredentialRequest(c.Server, organizationId, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDatabaseCredential(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDatabaseCredentialRequest(c.Server, organizationId, projectId, clusterId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabaseCredential(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseCredentialRequest(c.Server, organizationId, projectId, clusterId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutDatabaseCredentialWithBody(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, params *PutDatabaseCredentialParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutDatabaseCredentialRequestWithBody(c.Server, organizationId, projectId, clusterId, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutDatabaseCredential(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, params *PutDatabaseCredentialParams, body PutDatabaseCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutDatabaseCredentialRequest(c.Server, organizationId, projectId, clusterId, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectEvents(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectEventsRequest(c.Server, organizationId, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectEventByID(ctx context.Context, organizationId OrganizationId, projectId ProjectId, eventId EventId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectEventByIDRequest(c.Server, organizationId, projectId, eventId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectReplications(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectReplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectReplicationsRequest(c.Server, organizationId, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, organizationId OrganizationId, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserWithBody(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUser(ctx context.Context, organizationId OrganizationId, body PostUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, organizationId OrganizationId, userId CPUserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, organizationId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, organizationId OrganizationId, userId CPUserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, organizationId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserWithBody(ctx context.Context, organizationId OrganizationId, userId CPUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserRequestWithBody(c.Server, organizationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUser(ctx context.Context, organizationId OrganizationId, userId CPUserId, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserRequest(c.Server, organizationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListOrganizationsRequest generates requests for ListOrganizations
func NewListOrganizationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationByIDRequest generates requests for GetOrganizationByID
func NewGetOrganizationByIDRequest(server string, organizationId OrganizationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListModelsRequest generates requests for ListModels
func NewListModelsRequest(server string, organizationId OrganizationId, params *ListModelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/aiServices/models", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModelStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modelStatus", runtime.ParamLocationQuery, *params.ModelStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModelKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modelKind", runtime.ParamLocationQuery, *params.ModelKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateModelRequest calls the generic CreateModel builder with application/json body
func NewCreateModelRequest(server string, organizationId OrganizationId, body CreateModelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateModelRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewCreateModelRequestWithBody generates requests for CreateModel with any type of body
func NewCreateModelRequestWithBody(server string, organizationId OrganizationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/aiServices/models", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDestroyModelRequest generates requests for DestroyModel
func NewDestroyModelRequest(server string, organizationId OrganizationId, modelId ModelId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/aiServices/models/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetModelRequest generates requests for GetModel
func NewGetModelRequest(server string, organizationId OrganizationId, modelId ModelId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/aiServices/models/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListModelAPIKeysRequest generates requests for ListModelAPIKeys
func NewListModelAPIKeysRequest(server string, organizationId OrganizationId, modelId ModelId, params *ListModelAPIKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/aiServices/models/%s/apiKeys", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateModelAPIKeyRequest calls the generic CreateModelAPIKey builder with application/json body
func NewCreateModelAPIKeyRequest(server string, organizationId OrganizationId, modelId ModelId, body CreateModelAPIKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateModelAPIKeyRequestWithBody(server, organizationId, modelId, "application/json", bodyReader)
}

// NewCreateModelAPIKeyRequestWithBody generates requests for CreateModelAPIKey with any type of body
func NewCreateModelAPIKeyRequestWithBody(server string, organizationId OrganizationId, modelId ModelId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/aiServices/models/%s/apiKeys", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteModelAPIKeyRequest generates requests for DeleteModelAPIKey
func NewDeleteModelAPIKeyRequest(server string, organizationId OrganizationId, modelId ModelId, apiKeyId ModelAPIKeyId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "apiKeyId", runtime.ParamLocationPath, apiKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/aiServices/models/%s/apiKeys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetModelAPIKeyRequest generates requests for GetModelAPIKey
func NewGetModelAPIKeyRequest(server string, organizationId OrganizationId, modelId ModelId, apiKeyId ModelAPIKeyId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "apiKeyId", runtime.ParamLocationPath, apiKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/aiServices/models/%s/apiKeys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConnectionStringRequest generates requests for GetConnectionString
func NewGetConnectionStringRequest(server string, organizationId OrganizationId, modelId ModelId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/aiServices/models/%s/connectionString", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProvidersRequest generates requests for ListProviders
func NewListProvidersRequest(server string, organizationId OrganizationId, params *ListProvidersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/aiServices/providers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProviderType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "providerType", runtime.ParamLocationQuery, *params.ProviderType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProviderRequest calls the generic CreateProvider builder with application/json body
func NewCreateProviderRequest(server string, organizationId OrganizationId, body CreateProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProviderRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewCreateProviderRequestWithBody generates requests for CreateProvider with any type of body
func NewCreateProviderRequestWithBody(server string, organizationId OrganizationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/aiServices/providers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProviderRequest generates requests for DeleteProvider
func NewDeleteProviderRequest(server string, organizationId OrganizationId, providerId ProviderId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "providerId", runtime.ParamLocationPath, providerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/aiServices/providers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProviderRequest generates requests for GetProvider
func NewGetProviderRequest(server string, organizationId OrganizationId, providerId ProviderId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "providerId", runtime.ParamLocationPath, providerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/aiServices/providers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProviderRequest calls the generic UpdateProvider builder with application/json body
func NewUpdateProviderRequest(server string, organizationId OrganizationId, providerId ProviderId, params *UpdateProviderParams, body UpdateProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProviderRequestWithBody(server, organizationId, providerId, params, "application/json", bodyReader)
}

// NewUpdateProviderRequestWithBody generates requests for UpdateProvider with any type of body
func NewUpdateProviderRequestWithBody(server string, organizationId OrganizationId, providerId ProviderId, params *UpdateProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "providerId", runtime.ParamLocationPath, providerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/aiServices/providers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewListOrganizationLevelAnalyticsClustersRequest generates requests for ListOrganizationLevelAnalyticsClusters
func NewListOrganizationLevelAnalyticsClustersRequest(server string, organizationId OrganizationId, params *ListOrganizationLevelAnalyticsClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/analyticsClusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOrganizationAPIKeysRequest generates requests for ListOrganizationAPIKeys
func NewListOrganizationAPIKeysRequest(server string, organizationId OrganizationId, params *ListOrganizationAPIKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/apikeys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrganizationAPIKeysRequest calls the generic PostOrganizationAPIKeys builder with application/json body
func NewPostOrganizationAPIKeysRequest(server string, organizationId OrganizationId, body PostOrganizationAPIKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrganizationAPIKeysRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewPostOrganizationAPIKeysRequestWithBody generates requests for PostOrganizationAPIKeys with any type of body
func NewPostOrganizationAPIKeysRequestWithBody(server string, organizationId OrganizationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/apikeys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrganizationAPIKeyRequest generates requests for DeleteOrganizationAPIKey
func NewDeleteOrganizationAPIKeyRequest(server string, organizationId OrganizationId, apiKeyId AccessKey) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ApiKeyId", runtime.ParamLocationPath, apiKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/apikeys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationAPIKeyByAccessKeyRequest generates requests for GetOrganizationAPIKeyByAccessKey
func NewGetOrganizationAPIKeyByAccessKeyRequest(server string, organizationId OrganizationId, apiKeyId AccessKey) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ApiKeyId", runtime.ParamLocationPath, apiKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/apikeys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrganizationAPIKeyRotateRequest calls the generic PostOrganizationAPIKeyRotate builder with application/json body
func NewPostOrganizationAPIKeyRotateRequest(server string, organizationId OrganizationId, apiKeyId AccessKey, body PostOrganizationAPIKeyRotateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrganizationAPIKeyRotateRequestWithBody(server, organizationId, apiKeyId, "application/json", bodyReader)
}

// NewPostOrganizationAPIKeyRotateRequestWithBody generates requests for PostOrganizationAPIKeyRotate with any type of body
func NewPostOrganizationAPIKeyRotateRequestWithBody(server string, organizationId OrganizationId, apiKeyId AccessKey, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ApiKeyId", runtime.ParamLocationPath, apiKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/apikeys/%s/rotate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAppServicesRequest generates requests for ListAppServices
func NewListAppServicesRequest(server string, organizationId OrganizationId, params *ListAppServicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/appservices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCloudAccountsRequest generates requests for GetCloudAccounts
func NewGetCloudAccountsRequest(server string, organizationId OrganizationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/cloudAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeyMetadataListRequest generates requests for GetKeyMetadataList
func NewGetKeyMetadataListRequest(server string, organizationId OrganizationId, params *GetKeyMetadataListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/cmek", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCMEKMetadataRequest calls the generic PostCMEKMetadata builder with application/json body
func NewPostCMEKMetadataRequest(server string, organizationId OrganizationId, body PostCMEKMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCMEKMetadataRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewPostCMEKMetadataRequestWithBody generates requests for PostCMEKMetadata with any type of body
func NewPostCMEKMetadataRequestWithBody(server string, organizationId OrganizationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/cmek", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeyMetadataRequest generates requests for DeleteKeyMetadata
func NewDeleteKeyMetadataRequest(server string, organizationId OrganizationId, cmekId CMEKId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cmekId", runtime.ParamLocationPath, cmekId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/cmek/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeyMetadataRequest generates requests for GetKeyMetadata
func NewGetKeyMetadataRequest(server string, organizationId OrganizationId, cmekId CMEKId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cmekId", runtime.ParamLocationPath, cmekId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/cmek/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRotateCMEKKeyRequest calls the generic RotateCMEKKey builder with application/json body
func NewRotateCMEKKeyRequest(server string, organizationId OrganizationId, cmekId CMEKId, body RotateCMEKKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRotateCMEKKeyRequestWithBody(server, organizationId, cmekId, "application/json", bodyReader)
}

// NewRotateCMEKKeyRequestWithBody generates requests for RotateCMEKKey with any type of body
func NewRotateCMEKKeyRequestWithBody(server string, organizationId OrganizationId, cmekId CMEKId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cmekId", runtime.ParamLocationPath, cmekId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/cmek/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCMEKHistoryRequest generates requests for ListCMEKHistory
func NewListCMEKHistoryRequest(server string, organizationId OrganizationId, cmekId CMEKId, params *ListCMEKHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cmekId", runtime.ParamLocationPath, cmekId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/cmek/%s/history", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutOrganizationConfigurationRequest calls the generic PutOrganizationConfiguration builder with application/json body
func NewPutOrganizationConfigurationRequest(server string, organizationId OrganizationId, params *PutOrganizationConfigurationParams, body PutOrganizationConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutOrganizationConfigurationRequestWithBody(server, organizationId, params, "application/json", bodyReader)
}

// NewPutOrganizationConfigurationRequestWithBody generates requests for PutOrganizationConfiguration with any type of body
func NewPutOrganizationConfigurationRequestWithBody(server string, organizationId OrganizationId, params *PutOrganizationConfigurationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/configuration", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewListEventsRequest generates requests for ListEvents
func NewListEventsRequest(server string, organizationId OrganizationId, params *ListEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userIds", runtime.ParamLocationQuery, *params.UserIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClusterIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clusterIds", runtime.ParamLocationQuery, *params.ClusterIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectIds", runtime.ParamLocationQuery, *params.ProjectIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeverityLevels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severityLevels", runtime.ParamLocationQuery, *params.SeverityLevels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventByIDRequest generates requests for GetEventByID
func NewGetEventByIDRequest(server string, organizationId OrganizationId, eventId EventId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "eventId", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/events/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectsRequest generates requests for ListProjects
func NewListProjectsRequest(server string, organizationId OrganizationId, params *ListProjectsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProjectRequest calls the generic PostProject builder with application/json body
func NewPostProjectRequest(server string, organizationId OrganizationId, body PostProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProjectRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewPostProjectRequestWithBody generates requests for PostProject with any type of body
func NewPostProjectRequestWithBody(server string, organizationId OrganizationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectByIDRequest generates requests for DeleteProjectByID
func NewDeleteProjectByIDRequest(server string, organizationId OrganizationId, projectId ProjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectByIDRequest generates requests for GetProjectByID
func NewGetProjectByIDRequest(server string, organizationId OrganizationId, projectId ProjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutProjectRequest calls the generic PutProject builder with application/json body
func NewPutProjectRequest(server string, organizationId OrganizationId, projectId ProjectId, params *PutProjectParams, body PutProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutProjectRequestWithBody(server, organizationId, projectId, params, "application/json", bodyReader)
}

// NewPutProjectRequestWithBody generates requests for PutProject with any type of body
func NewPutProjectRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, params *PutProjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewPostTestAlertIntegrationRequest calls the generic PostTestAlertIntegration builder with application/json body
func NewPostTestAlertIntegrationRequest(server string, organizationId OrganizationId, projectId ProjectId, body PostTestAlertIntegrationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTestAlertIntegrationRequestWithBody(server, organizationId, projectId, "application/json", bodyReader)
}

// NewPostTestAlertIntegrationRequestWithBody generates requests for PostTestAlertIntegration with any type of body
func NewPostTestAlertIntegrationRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/alertIntegrationTest", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAlertIntegrationsRequest generates requests for ListAlertIntegrations
func NewListAlertIntegrationsRequest(server string, organizationId OrganizationId, projectId ProjectId, params *ListAlertIntegrationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/alertIntegrations", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAlertIntegrationRequest calls the generic PostAlertIntegration builder with application/json body
func NewPostAlertIntegrationRequest(server string, organizationId OrganizationId, projectId ProjectId, body PostAlertIntegrationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAlertIntegrationRequestWithBody(server, organizationId, projectId, "application/json", bodyReader)
}

// NewPostAlertIntegrationRequestWithBody generates requests for PostAlertIntegration with any type of body
func NewPostAlertIntegrationRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/alertIntegrations", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAlertIntegrationByIDRequest generates requests for DeleteAlertIntegrationByID
func NewDeleteAlertIntegrationByIDRequest(server string, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "alertIntegrationId", runtime.ParamLocationPath, alertIntegrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/alertIntegrations/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAlertIntegrationByIDRequest generates requests for GetAlertIntegrationByID
func NewGetAlertIntegrationByIDRequest(server string, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "alertIntegrationId", runtime.ParamLocationPath, alertIntegrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/alertIntegrations/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutAlertIntegrationRequest calls the generic PutAlertIntegration builder with application/json body
func NewPutAlertIntegrationRequest(server string, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, body PutAlertIntegrationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutAlertIntegrationRequestWithBody(server, organizationId, projectId, alertIntegrationId, "application/json", bodyReader)
}

// NewPutAlertIntegrationRequestWithBody generates requests for PutAlertIntegration with any type of body
func NewPutAlertIntegrationRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "alertIntegrationId", runtime.ParamLocationPath, alertIntegrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/alertIntegrations/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectLevelAnalyticsClustersRequest generates requests for ListProjectLevelAnalyticsClusters
func NewListProjectLevelAnalyticsClustersRequest(server string, organizationId OrganizationId, projectId ProjectId, params *ListProjectLevelAnalyticsClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAnalyticsClusterRequest calls the generic CreateAnalyticsCluster builder with application/json body
func NewCreateAnalyticsClusterRequest(server string, organizationId OrganizationId, projectId ProjectId, body CreateAnalyticsClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAnalyticsClusterRequestWithBody(server, organizationId, projectId, "application/json", bodyReader)
}

// NewCreateAnalyticsClusterRequestWithBody generates requests for CreateAnalyticsCluster with any type of body
func NewCreateAnalyticsClusterRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAnalyticsClusterRequest generates requests for DeleteAnalyticsCluster
func NewDeleteAnalyticsClusterRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnalyticsClusterRequest generates requests for GetAnalyticsCluster
func NewGetAnalyticsClusterRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutAnalyticsClusterRequest calls the generic PutAnalyticsCluster builder with application/json body
func NewPutAnalyticsClusterRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *PutAnalyticsClusterParams, body PutAnalyticsClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutAnalyticsClusterRequestWithBody(server, organizationId, projectId, analyticsClusterId, params, "application/json", bodyReader)
}

// NewPutAnalyticsClusterRequestWithBody generates requests for PutAnalyticsCluster with any type of body
func NewPutAnalyticsClusterRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *PutAnalyticsClusterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewAnalyticsClusterOffRequest generates requests for AnalyticsClusterOff
func NewAnalyticsClusterOffRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/activationState", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAnalyticsClusterOnRequest generates requests for AnalyticsClusterOn
func NewAnalyticsClusterOnRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/activationState", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAnalyticsAllowedCidrsRequest generates requests for ListAnalyticsAllowedCidrs
func NewListAnalyticsAllowedCidrsRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListAnalyticsAllowedCidrsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/allowedcidrs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAnalyticsAllowedCidrRequest calls the generic PostAnalyticsAllowedCidr builder with application/json body
func NewPostAnalyticsAllowedCidrRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PostAnalyticsAllowedCidrJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAnalyticsAllowedCidrRequestWithBody(server, organizationId, projectId, analyticsClusterId, "application/json", bodyReader)
}

// NewPostAnalyticsAllowedCidrRequestWithBody generates requests for PostAnalyticsAllowedCidr with any type of body
func NewPostAnalyticsAllowedCidrRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/allowedcidrs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteColumnarAllowedCidrByIDRequest generates requests for DeleteColumnarAllowedCidrByID
func NewDeleteColumnarAllowedCidrByIDRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, allowedCidrId AllowedCidrId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "allowedCidrId", runtime.ParamLocationPath, allowedCidrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/allowedcidrs/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetColumnarAllowedCidrByIDRequest generates requests for GetColumnarAllowedCidrByID
func NewGetColumnarAllowedCidrByIDRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, allowedCidrId AllowedCidrId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "allowedCidrId", runtime.ParamLocationPath, allowedCidrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/allowedcidrs/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteColumnarAnalyticsBackupScheduleRequest generates requests for DeleteColumnarAnalyticsBackupSchedule
func NewDeleteColumnarAnalyticsBackupScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/cloudSnapshotBackupSchedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetColumnarAnalyticsBackupScheduleRequest generates requests for GetColumnarAnalyticsBackupSchedule
func NewGetColumnarAnalyticsBackupScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/cloudSnapshotBackupSchedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpsertColumnarAnalyticsBackupScheduleRequest calls the generic UpsertColumnarAnalyticsBackupSchedule builder with application/json body
func NewUpsertColumnarAnalyticsBackupScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body UpsertColumnarAnalyticsBackupScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertColumnarAnalyticsBackupScheduleRequestWithBody(server, organizationId, projectId, analyticsClusterId, "application/json", bodyReader)
}

// NewUpsertColumnarAnalyticsBackupScheduleRequestWithBody generates requests for UpsertColumnarAnalyticsBackupSchedule with any type of body
func NewUpsertColumnarAnalyticsBackupScheduleRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/cloudSnapshotBackupSchedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListColumnarAnalyticsBackupsRequest generates requests for ListColumnarAnalyticsBackups
func NewListColumnarAnalyticsBackupsRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListColumnarAnalyticsBackupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/cloudSnapshotBackups", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateColumnarAnalyticsBackupRequest calls the generic CreateColumnarAnalyticsBackup builder with application/json body
func NewCreateColumnarAnalyticsBackupRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body CreateColumnarAnalyticsBackupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateColumnarAnalyticsBackupRequestWithBody(server, organizationId, projectId, analyticsClusterId, "application/json", bodyReader)
}

// NewCreateColumnarAnalyticsBackupRequestWithBody generates requests for CreateColumnarAnalyticsBackup with any type of body
func NewCreateColumnarAnalyticsBackupRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/cloudSnapshotBackups", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListColumnarAnalyticsRestoresRequest generates requests for ListColumnarAnalyticsRestores
func NewListColumnarAnalyticsRestoresRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListColumnarAnalyticsRestoresParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/cloudSnapshotBackups/restores", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteColumnarAnalyticsBackupRequest generates requests for DeleteColumnarAnalyticsBackup
func NewDeleteColumnarAnalyticsBackupRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/cloudSnapshotBackups/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateColumnarAnalyticsBackupRetentionRequest calls the generic UpdateColumnarAnalyticsBackupRetention builder with application/json body
func NewUpdateColumnarAnalyticsBackupRetentionRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, body UpdateColumnarAnalyticsBackupRetentionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateColumnarAnalyticsBackupRetentionRequestWithBody(server, organizationId, projectId, analyticsClusterId, backupId, "application/json", bodyReader)
}

// NewUpdateColumnarAnalyticsBackupRetentionRequestWithBody generates requests for UpdateColumnarAnalyticsBackupRetention with any type of body
func NewUpdateColumnarAnalyticsBackupRetentionRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/cloudSnapshotBackups/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreColumnarAnalyticsClusterRequest generates requests for RestoreColumnarAnalyticsCluster
func NewRestoreColumnarAnalyticsClusterRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/cloudSnapshotBackups/%s/restore", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAnalyticsOnOffScheduleRequest generates requests for DeleteAnalyticsOnOffSchedule
func NewDeleteAnalyticsOnOffScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/onOffSchedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnalyticsOnOffScheduleRequest generates requests for GetAnalyticsOnOffSchedule
func NewGetAnalyticsOnOffScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/onOffSchedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAnalyticsOnOffScheduleRequest calls the generic PostAnalyticsOnOffSchedule builder with application/json body
func NewPostAnalyticsOnOffScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PostAnalyticsOnOffScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAnalyticsOnOffScheduleRequestWithBody(server, organizationId, projectId, analyticsClusterId, "application/json", bodyReader)
}

// NewPostAnalyticsOnOffScheduleRequestWithBody generates requests for PostAnalyticsOnOffSchedule with any type of body
func NewPostAnalyticsOnOffScheduleRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/onOffSchedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutAnalyticsOnOffScheduleRequest calls the generic PutAnalyticsOnOffSchedule builder with application/json body
func NewPutAnalyticsOnOffScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PutAnalyticsOnOffScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutAnalyticsOnOffScheduleRequestWithBody(server, organizationId, projectId, analyticsClusterId, "application/json", bodyReader)
}

// NewPutAnalyticsOnOffScheduleRequestWithBody generates requests for PutAnalyticsOnOffSchedule with any type of body
func NewPutAnalyticsOnOffScheduleRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/onOffSchedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisableColumnarPrivateEndpointServiceRequest generates requests for DisableColumnarPrivateEndpointService
func NewDisableColumnarPrivateEndpointServiceRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/privateEndpointService", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetColumnarPrivateEndpointServiceStatusRequest generates requests for GetColumnarPrivateEndpointServiceStatus
func NewGetColumnarPrivateEndpointServiceStatusRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/privateEndpointService", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnableColumnarPrivateEndpointServiceRequest generates requests for EnableColumnarPrivateEndpointService
func NewEnableColumnarPrivateEndpointServiceRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/privateEndpointService", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetColumnarPrivateEndpointServiceCommandRequest calls the generic GetColumnarPrivateEndpointServiceCommand builder with application/json body
func NewGetColumnarPrivateEndpointServiceCommandRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body GetColumnarPrivateEndpointServiceCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetColumnarPrivateEndpointServiceCommandRequestWithBody(server, organizationId, projectId, analyticsClusterId, "application/json", bodyReader)
}

// NewGetColumnarPrivateEndpointServiceCommandRequestWithBody generates requests for GetColumnarPrivateEndpointServiceCommand with any type of body
func NewGetColumnarPrivateEndpointServiceCommandRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/privateEndpointService/endpointCommand", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListColumnarPrivateEndpointServiceConnectionRequest generates requests for ListColumnarPrivateEndpointServiceConnection
func NewListColumnarPrivateEndpointServiceConnectionRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/privateEndpointService/endpoints", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptColumnarPrivateEndpointServiceConnectionRequest generates requests for AcceptColumnarPrivateEndpointServiceConnection
func NewAcceptColumnarPrivateEndpointServiceConnectionRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, endpointId EndpointID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "endpointId", runtime.ParamLocationPath, endpointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/privateEndpointService/endpoints/%s/associate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRejectColumnarPrivateEndpointServiceConnectionRequest generates requests for RejectColumnarPrivateEndpointServiceConnection
func NewRejectColumnarPrivateEndpointServiceConnectionRequest(server string, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, endpointId EndpointID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analyticsClusterId", runtime.ParamLocationPath, analyticsClusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "endpointId", runtime.ParamLocationPath, endpointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/analyticsClusters/%s/privateEndpointService/endpoints/%s/unassociate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectLevelCloudSnapshotBackupsRequest generates requests for ListProjectLevelCloudSnapshotBackups
func NewListProjectLevelCloudSnapshotBackupsRequest(server string, organizationId OrganizationId, projectId ProjectId, params *ListProjectLevelCloudSnapshotBackupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/cloudsnapshotbackups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCloneRequest calls the generic Clone builder with application/json body
func NewCloneRequest(server string, organizationId OrganizationId, projectId ProjectId, backupId BackupId, body CloneJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCloneRequestWithBody(server, organizationId, projectId, backupId, "application/json", bodyReader)
}

// NewCloneRequestWithBody generates requests for Clone with any type of body
func NewCloneRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, backupId BackupId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/cloudsnapshotbackups/%s/clone", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListClustersRequest generates requests for ListClusters
func NewListClustersRequest(server string, organizationId OrganizationId, projectId ProjectId, params *ListClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClusterRequest calls the generic PostCluster builder with application/json body
func NewPostClusterRequest(server string, organizationId OrganizationId, projectId ProjectId, body PostClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClusterRequestWithBody(server, organizationId, projectId, "application/json", bodyReader)
}

// NewPostClusterRequestWithBody generates requests for PostCluster with any type of body
func NewPostClusterRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateFreeTierClusterRequest calls the generic CreateFreeTierCluster builder with application/json body
func NewCreateFreeTierClusterRequest(server string, organizationId OrganizationId, projectId ProjectId, body CreateFreeTierClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFreeTierClusterRequestWithBody(server, organizationId, projectId, "application/json", bodyReader)
}

// NewCreateFreeTierClusterRequestWithBody generates requests for CreateFreeTierCluster with any type of body
func NewCreateFreeTierClusterRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/freeTier", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFreeTierClusterRequest generates requests for DeleteFreeTierCluster
func NewDeleteFreeTierClusterRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/freeTier/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFreeTierClusterRequest generates requests for GetFreeTierCluster
func NewGetFreeTierClusterRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/freeTier/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFreeTierClusterRequest calls the generic UpdateFreeTierCluster builder with application/json body
func NewUpdateFreeTierClusterRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *UpdateFreeTierClusterParams, body UpdateFreeTierClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFreeTierClusterRequestWithBody(server, organizationId, projectId, clusterId, params, "application/json", bodyReader)
}

// NewUpdateFreeTierClusterRequestWithBody generates requests for UpdateFreeTierCluster with any type of body
func NewUpdateFreeTierClusterRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *UpdateFreeTierClusterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/freeTier/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewFreeTierClusterOffRequest generates requests for FreeTierClusterOff
func NewFreeTierClusterOffRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/freeTier/%s/activationState", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFreeTierClusterOnRequest generates requests for FreeTierClusterOn
func NewFreeTierClusterOnRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/freeTier/%s/activationState", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *DeleteClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Retainsnapshotbackups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "retainsnapshotbackups", runtime.ParamLocationQuery, *params.Retainsnapshotbackups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutClusterRequest calls the generic PutCluster builder with application/json body
func NewPutClusterRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *PutClusterParams, body PutClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutClusterRequestWithBody(server, organizationId, projectId, clusterId, params, "application/json", bodyReader)
}

// NewPutClusterRequestWithBody generates requests for PutCluster with any type of body
func NewPutClusterRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *PutClusterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewClusterOffRequest generates requests for ClusterOff
func NewClusterOffRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/activationState", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClusterOnRequest calls the generic ClusterOn builder with application/json body
func NewClusterOnRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body ClusterOnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewClusterOnRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewClusterOnRequestWithBody generates requests for ClusterOn with any type of body
func NewClusterOnRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/activationState", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAiWorkflowsRequest generates requests for ListAiWorkflows
func NewListAiWorkflowsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAiWorkflowsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/aiServices/workflows", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAiWorkflowRequest calls the generic CreateAiWorkflow builder with application/json body
func NewCreateAiWorkflowRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateAiWorkflowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAiWorkflowRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewCreateAiWorkflowRequestWithBody generates requests for CreateAiWorkflow with any type of body
func NewCreateAiWorkflowRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/aiServices/workflows", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAiWorkflowRequest generates requests for DeleteAiWorkflow
func NewDeleteAiWorkflowRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "workflowId", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/aiServices/workflows/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAiWorkflowRequest generates requests for GetAiWorkflow
func NewGetAiWorkflowRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "workflowId", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/aiServices/workflows/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopAiWorkflowRunRequest generates requests for StopAiWorkflowRun
func NewStopAiWorkflowRunRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "workflowId", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/aiServices/workflows/%s/runs", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAiWorkflowRunsRequest generates requests for ListAiWorkflowRuns
func NewListAiWorkflowRunsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, params *ListAiWorkflowRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "workflowId", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/aiServices/workflows/%s/runs", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAiWorkflowRunRequest generates requests for CreateAiWorkflowRun
func NewCreateAiWorkflowRunRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "workflowId", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/aiServices/workflows/%s/runs", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAiWorkflowRunRequest generates requests for GetAiWorkflowRun
func NewGetAiWorkflowRunRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, runId WorkflowRunId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "workflowId", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "runId", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/aiServices/workflows/%s/runs/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAiWorkflowRunProcessedFilesRequest generates requests for GetAiWorkflowRunProcessedFiles
func NewGetAiWorkflowRunProcessedFilesRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, runId WorkflowRunId, params *GetAiWorkflowRunProcessedFilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "workflowId", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "runId", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/aiServices/workflows/%s/runs/%s/processedFiles", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fileStatus", runtime.ParamLocationQuery, *params.FileStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllowedCidrsRequest generates requests for ListAllowedCidrs
func NewListAllowedCidrsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAllowedCidrsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/allowedcidrs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAllowedCidrsRequest calls the generic PostAllowedCidrs builder with application/json body
func NewPostAllowedCidrsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAllowedCidrsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAllowedCidrsRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewPostAllowedCidrsRequestWithBody generates requests for PostAllowedCidrs with any type of body
func NewPostAllowedCidrsRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/allowedcidrs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAllowedCidrByIDRequest generates requests for DeleteAllowedCidrByID
func NewDeleteAllowedCidrByIDRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, allowedCidrId AllowedCidrId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "allowedCidrId", runtime.ParamLocationPath, allowedCidrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/allowedcidrs/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllowedCidrByIDRequest generates requests for GetAllowedCidrByID
func NewGetAllowedCidrByIDRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, allowedCidrId AllowedCidrId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "allowedCidrId", runtime.ParamLocationPath, allowedCidrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/allowedcidrs/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAppServiceRequest calls the generic PostAppService builder with application/json body
func NewPostAppServiceRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAppServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAppServiceRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewPostAppServiceRequestWithBody generates requests for PostAppService with any type of body
func NewPostAppServiceRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateFreeTierAppServiceRequest calls the generic CreateFreeTierAppService builder with application/json body
func NewCreateFreeTierAppServiceRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateFreeTierAppServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFreeTierAppServiceRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewCreateFreeTierAppServiceRequestWithBody generates requests for CreateFreeTierAppService with any type of body
func NewCreateFreeTierAppServiceRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/freeTier", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFreeTierAppServiceRequest generates requests for DeleteFreeTierAppService
func NewDeleteFreeTierAppServiceRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/freeTier/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFreeTierAppServiceRequest generates requests for GetFreeTierAppService
func NewGetFreeTierAppServiceRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/freeTier/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFreeTierAppServiceRequest calls the generic UpdateFreeTierAppService builder with application/json body
func NewUpdateFreeTierAppServiceRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *UpdateFreeTierAppServiceParams, body UpdateFreeTierAppServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFreeTierAppServiceRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, params, "application/json", bodyReader)
}

// NewUpdateFreeTierAppServiceRequestWithBody generates requests for UpdateFreeTierAppService with any type of body
func NewUpdateFreeTierAppServiceRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *UpdateFreeTierAppServiceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/freeTier/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAppServiceRequest generates requests for DeleteAppService
func NewDeleteAppServiceRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppServiceRequest generates requests for GetAppService
func NewGetAppServiceRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutAppServiceRequest calls the generic PutAppService builder with application/json body
func NewPutAppServiceRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *PutAppServiceParams, body PutAppServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutAppServiceRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, params, "application/json", bodyReader)
}

// NewPutAppServiceRequestWithBody generates requests for PutAppService with any type of body
func NewPutAppServiceRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *PutAppServiceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewAppServiceOffRequest generates requests for AppServiceOff
func NewAppServiceOffRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/activationState", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppServiceOnRequest generates requests for AppServiceOn
func NewAppServiceOnRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/activationState", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAppServiceAdminUsersRequest generates requests for ListAppServiceAdminUsers
func NewListAppServiceAdminUsersRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAdminUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/adminUsers", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddAppServiceAdminUserRequest calls the generic AddAppServiceAdminUser builder with application/json body
func NewAddAppServiceAdminUserRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body AddAppServiceAdminUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddAppServiceAdminUserRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, "application/json", bodyReader)
}

// NewAddAppServiceAdminUserRequestWithBody generates requests for AddAppServiceAdminUser with any type of body
func NewAddAppServiceAdminUserRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/adminUsers", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAppServiceAdminUserRequest generates requests for DeleteAppServiceAdminUser
func NewDeleteAppServiceAdminUserRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/adminUsers/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppServiceAdminUserRequest generates requests for GetAppServiceAdminUser
func NewGetAppServiceAdminUserRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/adminUsers/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppServiceAdminUserRequest calls the generic UpdateAppServiceAdminUser builder with application/json body
func NewUpdateAppServiceAdminUserRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, body UpdateAppServiceAdminUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppServiceAdminUserRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, userId, "application/json", bodyReader)
}

// NewUpdateAppServiceAdminUserRequestWithBody generates requests for UpdateAppServiceAdminUser with any type of body
func NewUpdateAppServiceAdminUserRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/adminUsers/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAppServiceAllowedCidrsRequest generates requests for ListAppServiceAllowedCidrs
func NewListAppServiceAllowedCidrsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAllowedCidrsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/allowedcidrs", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAppServiceAllowedCidrRequest calls the generic PostAppServiceAllowedCidr builder with application/json body
func NewPostAppServiceAllowedCidrRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppServiceAllowedCidrJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAppServiceAllowedCidrRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, "application/json", bodyReader)
}

// NewPostAppServiceAllowedCidrRequestWithBody generates requests for PostAppServiceAllowedCidr with any type of body
func NewPostAppServiceAllowedCidrRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/allowedcidrs", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAppServiceAllowedCidrRequest generates requests for DeleteAppServiceAllowedCidr
func NewDeleteAppServiceAllowedCidrRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, allowedCidrId AllowedCidrId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "allowedCidrId", runtime.ParamLocationPath, allowedCidrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/allowedcidrs/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAppEndpointsRequest generates requests for ListAppEndpoints
func NewListAppEndpointsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppEndpointsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAppEndpointRequest calls the generic PostAppEndpoint builder with application/json body
func NewPostAppEndpointRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppEndpointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAppEndpointRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, "application/json", bodyReader)
}

// NewPostAppEndpointRequestWithBody generates requests for PostAppEndpoint with any type of body
func NewPostAppEndpointRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAccessFunctionRequest generates requests for DeleteAccessFunction
func NewDeleteAccessFunctionRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointKeyspace", runtime.ParamLocationPath, appEndpointKeyspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/accessControlFunction", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccessFunctionRequest generates requests for GetAccessFunction
func NewGetAccessFunctionRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointKeyspace", runtime.ParamLocationPath, appEndpointKeyspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/accessControlFunction", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutAccessFunctionRequestWithBody generates requests for PutAccessFunction with any type of body
func NewPutAccessFunctionRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointKeyspace", runtime.ParamLocationPath, appEndpointKeyspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/accessControlFunction", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteImportFilterRequest generates requests for DeleteImportFilter
func NewDeleteImportFilterRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointKeyspace", runtime.ParamLocationPath, appEndpointKeyspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/importFilter", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetImportFilterRequest generates requests for GetImportFilter
func NewGetImportFilterRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointKeyspace", runtime.ParamLocationPath, appEndpointKeyspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/importFilter", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutImportFilterRequestWithBody generates requests for PutImportFilter with any type of body
func NewPutImportFilterRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointKeyspace", runtime.ParamLocationPath, appEndpointKeyspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/importFilter", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAppEndpointRequest generates requests for DeleteAppEndpoint
func NewDeleteAppEndpointRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppEndpointRequest generates requests for GetAppEndpoint
func NewGetAppEndpointRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutAppEndpointRequest calls the generic PutAppEndpoint builder with application/json body
func NewPutAppEndpointRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutAppEndpointRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, appEndpointName, "application/json", bodyReader)
}

// NewPutAppEndpointRequestWithBody generates requests for PutAppEndpoint with any type of body
func NewPutAppEndpointRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAppEndpointActivationStatusRequest generates requests for DeleteAppEndpointActivationStatus
func NewDeleteAppEndpointActivationStatusRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/activationStatus", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAppEndpointActivationStatusRequest generates requests for PostAppEndpointActivationStatus
func NewPostAppEndpointActivationStatusRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/activationStatus", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAppEndpointAdminUsersRequest generates requests for ListAppEndpointAdminUsers
func NewListAppEndpointAdminUsersRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointAdminUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/adminUsers", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppEndpointAuditLogConfigRequest generates requests for GetAppEndpointAuditLogConfig
func NewGetAppEndpointAuditLogConfigRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/auditLog", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutAppEndpointAuditLogConfigRequest calls the generic PutAppEndpointAuditLogConfig builder with application/json body
func NewPutAppEndpointAuditLogConfigRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointAuditLogConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutAppEndpointAuditLogConfigRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, appEndpointName, "application/json", bodyReader)
}

// NewPutAppEndpointAuditLogConfigRequestWithBody generates requests for PutAppEndpointAuditLogConfig with any type of body
func NewPutAppEndpointAuditLogConfigRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/auditLog", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppServiceAuditLogEventsRequest generates requests for GetAppServiceAuditLogEvents
func NewGetAppServiceAuditLogEventsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/auditLogEvents", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAppEndpointCollectionsRequest generates requests for ListAppEndpointCollections
func NewListAppEndpointCollectionsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointCollectionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/collections", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppEndpointCORSRequest generates requests for GetAppEndpointCORS
func NewGetAppEndpointCORSRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/cors", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutAppEndpointCORSRequest calls the generic PutAppEndpointCORS builder with application/json body
func NewPutAppEndpointCORSRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointCORSJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutAppEndpointCORSRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, appEndpointName, "application/json", bodyReader)
}

// NewPutAppEndpointCORSRequestWithBody generates requests for PutAppEndpointCORS with any type of body
func NewPutAppEndpointCORSRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/cors", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAppEndpointOIDCProvidersRequest generates requests for ListAppEndpointOIDCProviders
func NewListAppEndpointOIDCProvidersRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointOIDCProvidersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/oidcProviders", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAppEndpointOIDCProviderRequest calls the generic CreateAppEndpointOIDCProvider builder with application/json body
func NewCreateAppEndpointOIDCProviderRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body CreateAppEndpointOIDCProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppEndpointOIDCProviderRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, appEndpointName, "application/json", bodyReader)
}

// NewCreateAppEndpointOIDCProviderRequestWithBody generates requests for CreateAppEndpointOIDCProvider with any type of body
func NewCreateAppEndpointOIDCProviderRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/oidcProviders", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateAppEndpointOIDCDefaultProviderRequest calls the generic UpdateAppEndpointOIDCDefaultProvider builder with application/json body
func NewUpdateAppEndpointOIDCDefaultProviderRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body UpdateAppEndpointOIDCDefaultProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppEndpointOIDCDefaultProviderRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, appEndpointName, "application/json", bodyReader)
}

// NewUpdateAppEndpointOIDCDefaultProviderRequestWithBody generates requests for UpdateAppEndpointOIDCDefaultProvider with any type of body
func NewUpdateAppEndpointOIDCDefaultProviderRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/oidcProviders/defaultProvider", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAppEndpointOIDCProviderRequest generates requests for DeleteAppEndpointOIDCProvider
func NewDeleteAppEndpointOIDCProviderRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	var pathParam5 string

	pathParam5, err = runtime.StyleParamWithLocation("simple", false, "OIDCProviderId", runtime.ParamLocationPath, oidcProviderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/oidcProviders/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4, pathParam5)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppEndpointOIDCProviderRequest generates requests for GetAppEndpointOIDCProvider
func NewGetAppEndpointOIDCProviderRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	var pathParam5 string

	pathParam5, err = runtime.StyleParamWithLocation("simple", false, "OIDCProviderId", runtime.ParamLocationPath, oidcProviderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/oidcProviders/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4, pathParam5)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppEndpointOIDCProviderRequest calls the generic UpdateAppEndpointOIDCProvider builder with application/json body
func NewUpdateAppEndpointOIDCProviderRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, body UpdateAppEndpointOIDCProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppEndpointOIDCProviderRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, appEndpointName, oidcProviderId, "application/json", bodyReader)
}

// NewUpdateAppEndpointOIDCProviderRequestWithBody generates requests for UpdateAppEndpointOIDCProvider with any type of body
func NewUpdateAppEndpointOIDCProviderRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	var pathParam5 string

	pathParam5, err = runtime.StyleParamWithLocation("simple", false, "OIDCProviderId", runtime.ParamLocationPath, oidcProviderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/oidcProviders/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4, pathParam5)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAppEndpointResyncRequest generates requests for DeleteAppEndpointResync
func NewDeleteAppEndpointResyncRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/resync", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppEndpointResyncRequest generates requests for GetAppEndpointResync
func NewGetAppEndpointResyncRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/resync", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAppEndpointResyncRequest calls the generic PostAppEndpointResync builder with application/json body
func NewPostAppEndpointResyncRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PostAppEndpointResyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAppEndpointResyncRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, appEndpointName, "application/json", bodyReader)
}

// NewPostAppEndpointResyncRequestWithBody generates requests for PostAppEndpointResync with any type of body
func NewPostAppEndpointResyncRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "appEndpointName", runtime.ParamLocationPath, appEndpointName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/appEndpoints/%s/resync", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppServiceAuditLogStateRequest generates requests for GetAppServiceAuditLogState
func NewGetAppServiceAuditLogStateRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/auditLog", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutAppServiceAuditLogStateRequest calls the generic PutAppServiceAuditLogState builder with application/json body
func NewPutAppServiceAuditLogStateRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PutAppServiceAuditLogStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutAppServiceAuditLogStateRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, "application/json", bodyReader)
}

// NewPutAppServiceAuditLogStateRequestWithBody generates requests for PutAppServiceAuditLogState with any type of body
func NewPutAppServiceAuditLogStateRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/auditLog", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAppServiceAuditLogExportsRequest generates requests for ListAppServiceAuditLogExports
func NewListAppServiceAuditLogExportsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAuditLogExportsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/auditLogExports", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAppServiceAuditLogExportRequest calls the generic PostAppServiceAuditLogExport builder with application/json body
func NewPostAppServiceAuditLogExportRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppServiceAuditLogExportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAppServiceAuditLogExportRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, "application/json", bodyReader)
}

// NewPostAppServiceAuditLogExportRequestWithBody generates requests for PostAppServiceAuditLogExport with any type of body
func NewPostAppServiceAuditLogExportRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/auditLogExports", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppServiceAuditLogExportByIdRequest generates requests for GetAppServiceAuditLogExportById
func NewGetAppServiceAuditLogExportByIdRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, auditLogExportId AuditLogExportId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "auditLogExportId", runtime.ParamLocationPath, auditLogExportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/auditLogExports/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppServiceAuditLogStreamingRequest generates requests for GetAppServiceAuditLogStreaming
func NewGetAppServiceAuditLogStreamingRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/auditLogStreaming", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchAppServiceAuditLogStreamingRequest calls the generic PatchAppServiceAuditLogStreaming builder with application/json body
func NewPatchAppServiceAuditLogStreamingRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PatchAppServiceAuditLogStreamingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchAppServiceAuditLogStreamingRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, "application/json", bodyReader)
}

// NewPatchAppServiceAuditLogStreamingRequestWithBody generates requests for PatchAppServiceAuditLogStreaming with any type of body
func NewPatchAppServiceAuditLogStreamingRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/auditLogStreaming", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutAppServiceAuditLogStreamingRequest calls the generic PutAppServiceAuditLogStreaming builder with application/json body
func NewPutAppServiceAuditLogStreamingRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PutAppServiceAuditLogStreamingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutAppServiceAuditLogStreamingRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, "application/json", bodyReader)
}

// NewPutAppServiceAuditLogStreamingRequestWithBody generates requests for PutAppServiceAuditLogStreaming with any type of body
func NewPutAppServiceAuditLogStreamingRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/auditLogStreaming", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppServiceCertificateRequest generates requests for GetAppServiceCertificate
func NewGetAppServiceCertificateRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/certificates", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAppServicePrivateEndpointsRequest generates requests for DeleteAppServicePrivateEndpoints
func NewDeleteAppServicePrivateEndpointsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/privateEndpointService", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppServicePrivateEndpointsRequest generates requests for GetAppServicePrivateEndpoints
func NewGetAppServicePrivateEndpointsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/privateEndpointService", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAppServicePrivateEndpointsRequest generates requests for PostAppServicePrivateEndpoints
func NewPostAppServicePrivateEndpointsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/privateEndpointService", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAppServicePrivateEndpointsRequest generates requests for ListAppServicePrivateEndpoints
func NewListAppServicePrivateEndpointsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/privateEndpointService/endpoints", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePrivateEndpointRequestRequest generates requests for DeletePrivateEndpointRequest
func NewDeletePrivateEndpointRequestRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, endpointId EndpointID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "endpointId", runtime.ParamLocationPath, endpointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/privateEndpointService/endpoints/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptPrivateEndpointRequestRequest generates requests for AcceptPrivateEndpointRequest
func NewAcceptPrivateEndpointRequestRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, endpointId EndpointID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "endpointId", runtime.ParamLocationPath, endpointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/privateEndpointService/endpoints/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppServicePrivateEndpointsCommandRequest calls the generic GetAppServicePrivateEndpointsCommand builder with application/json body
func NewGetAppServicePrivateEndpointsCommandRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body GetAppServicePrivateEndpointsCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetAppServicePrivateEndpointsCommandRequestWithBody(server, organizationId, projectId, clusterId, appServiceId, "application/json", bodyReader)
}

// NewGetAppServicePrivateEndpointsCommandRequestWithBody generates requests for GetAppServicePrivateEndpointsCommand with any type of body
func NewGetAppServicePrivateEndpointsCommandRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "appServiceId", runtime.ParamLocationPath, appServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/appservices/%s/privateEndpointService/privateEndpointCommand", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterAuditSettingsRequest generates requests for GetClusterAuditSettings
func NewGetClusterAuditSettingsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/auditLog", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutClusterAuditSettingsRequest calls the generic PutClusterAuditSettings builder with application/json body
func NewPutClusterAuditSettingsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutClusterAuditSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutClusterAuditSettingsRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewPutClusterAuditSettingsRequestWithBody generates requests for PutClusterAuditSettings with any type of body
func NewPutClusterAuditSettingsRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/auditLog", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAuditLogEventIDsRequest generates requests for GetAuditLogEventIDs
func NewGetAuditLogEventIDsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/auditLogEvents", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAuditLogExportsRequest generates requests for ListAuditLogExports
func NewListAuditLogExportsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAuditLogExportsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/auditLogExports", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAuditLogExportRequest calls the generic PostAuditLogExport builder with application/json body
func NewPostAuditLogExportRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAuditLogExportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuditLogExportRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewPostAuditLogExportRequestWithBody generates requests for PostAuditLogExport with any type of body
func NewPostAuditLogExportRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/auditLogExports", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAuditLogExportRequest generates requests for GetAuditLogExport
func NewGetAuditLogExportRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, auditLogExportId AuditLogExportId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "auditLogExportId", runtime.ParamLocationPath, auditLogExportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/auditLogExports/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClusterBackupsRequest generates requests for ListClusterBackups
func NewListClusterBackupsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/backups", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBackupCycleByIDRequest generates requests for DeleteBackupCycleByID
func NewDeleteBackupCycleByIDRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/backups/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackupByIDRequest generates requests for GetBackupByID
func NewGetBackupByIDRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/backups/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRestoreRequest calls the generic PostRestore builder with application/json body
func NewPostRestoreRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body PostRestoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRestoreRequestWithBody(server, organizationId, projectId, clusterId, backupId, "application/json", bodyReader)
}

// NewPostRestoreRequestWithBody generates requests for PostRestore with any type of body
func NewPostRestoreRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/backups/%s/restore", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutBucketStorageBackendRequest calls the generic PutBucketStorageBackend builder with application/json body
func NewPutBucketStorageBackendRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutBucketStorageBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutBucketStorageBackendRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewPutBucketStorageBackendRequestWithBody generates requests for PutBucketStorageBackend with any type of body
func NewPutBucketStorageBackendRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/bucketStorageMigration", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBucketsRequest generates requests for ListBuckets
func NewListBucketsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostBucketRequest calls the generic PostBucket builder with application/json body
func NewPostBucketRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostBucketJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBucketRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewPostBucketRequestWithBody generates requests for PostBucket with any type of body
func NewPostBucketRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFreeTierBucketsRequest generates requests for ListFreeTierBuckets
func NewListFreeTierBucketsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/freeTier", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFreeTierBucketRequest calls the generic CreateFreeTierBucket builder with application/json body
func NewCreateFreeTierBucketRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateFreeTierBucketJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFreeTierBucketRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewCreateFreeTierBucketRequestWithBody generates requests for CreateFreeTierBucket with any type of body
func NewCreateFreeTierBucketRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/freeTier", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFreeTierBucketByIDRequest generates requests for DeleteFreeTierBucketByID
func NewDeleteFreeTierBucketByIDRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/freeTier/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFreeTierBucketByIDRequest generates requests for GetFreeTierBucketByID
func NewGetFreeTierBucketByIDRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/freeTier/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFreeTierBucketRequest calls the generic UpdateFreeTierBucket builder with application/json body
func NewUpdateFreeTierBucketRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body UpdateFreeTierBucketJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFreeTierBucketRequestWithBody(server, organizationId, projectId, clusterId, bucketId, "application/json", bodyReader)
}

// NewUpdateFreeTierBucketRequestWithBody generates requests for UpdateFreeTierBucket with any type of body
func NewUpdateFreeTierBucketRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/freeTier/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBucketByIDRequest generates requests for DeleteBucketByID
func NewDeleteBucketByIDRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBucketByIDRequest generates requests for GetBucketByID
func NewGetBucketByIDRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutBucketRequest calls the generic PutBucket builder with application/json body
func NewPutBucketRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PutBucketJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutBucketRequestWithBody(server, organizationId, projectId, clusterId, bucketId, "application/json", bodyReader)
}

// NewPutBucketRequestWithBody generates requests for PutBucket with any type of body
func NewPutBucketRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCyclesRequest generates requests for ListCycles
func NewListCyclesRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, params *ListCyclesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/backup/cycles", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBackupsRequest generates requests for ListBackups
func NewListBackupsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, cycleId CycleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "cycleId", runtime.ParamLocationPath, cycleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/backup/cycles/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBackupScheduleRequest generates requests for DeleteBackupSchedule
func NewDeleteBackupScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/backup/schedules", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackupScheduleRequest generates requests for GetBackupSchedule
func NewGetBackupScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/backup/schedules", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostBackupScheduleRequest calls the generic PostBackupSchedule builder with application/json body
func NewPostBackupScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PostBackupScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBackupScheduleRequestWithBody(server, organizationId, projectId, clusterId, bucketId, "application/json", bodyReader)
}

// NewPostBackupScheduleRequestWithBody generates requests for PostBackupSchedule with any type of body
func NewPostBackupScheduleRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/backup/schedules", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutBackupScheduleRequest calls the generic PutBackupSchedule builder with application/json body
func NewPutBackupScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PutBackupScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutBackupScheduleRequestWithBody(server, organizationId, projectId, clusterId, bucketId, "application/json", bodyReader)
}

// NewPutBackupScheduleRequestWithBody generates requests for PutBackupSchedule with any type of body
func NewPutBackupScheduleRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/backup/schedules", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostBackupRequest generates requests for PostBackup
func NewPostBackupRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/backups", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFlushBucketRequest generates requests for FlushBucket
func NewFlushBucketRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/flush", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScopesRequest generates requests for GetScopes
func NewGetScopesRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/scopes", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostScopeRequest calls the generic PostScope builder with application/json body
func NewPostScopeRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PostScopeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostScopeRequestWithBody(server, organizationId, projectId, clusterId, bucketId, "application/json", bodyReader)
}

// NewPostScopeRequestWithBody generates requests for PostScope with any type of body
func NewPostScopeRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/scopes", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteScopeByNameRequest generates requests for DeleteScopeByName
func NewDeleteScopeByNameRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "scopeName", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/scopes/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScopeByNameRequest generates requests for GetScopeByName
func NewGetScopeByNameRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "scopeName", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/scopes/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectionsRequest generates requests for GetCollections
func NewGetCollectionsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "scopeName", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/scopes/%s/collections", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCollectionRequest calls the generic PostCollection builder with application/json body
func NewPostCollectionRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, body PostCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCollectionRequestWithBody(server, organizationId, projectId, clusterId, bucketId, scopeName, "application/json", bodyReader)
}

// NewPostCollectionRequestWithBody generates requests for PostCollection with any type of body
func NewPostCollectionRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "scopeName", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/scopes/%s/collections", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCollectionByNameRequest generates requests for DeleteCollectionByName
func NewDeleteCollectionByNameRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "scopeName", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam5 string

	pathParam5, err = runtime.StyleParamWithLocation("simple", false, "collectionName", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/scopes/%s/collections/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4, pathParam5)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectionByNameRequest generates requests for GetCollectionByName
func NewGetCollectionByNameRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "scopeName", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam5 string

	pathParam5, err = runtime.StyleParamWithLocation("simple", false, "collectionName", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/scopes/%s/collections/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4, pathParam5)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutCollectionRequest calls the generic PutCollection builder with application/json body
func NewPutCollectionRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, body PutCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutCollectionRequestWithBody(server, organizationId, projectId, clusterId, bucketId, scopeName, collectionName, "application/json", bodyReader)
}

// NewPutCollectionRequestWithBody generates requests for PutCollection with any type of body
func NewPutCollectionRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "scopeName", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam5 string

	pathParam5, err = runtime.StyleParamWithLocation("simple", false, "collectionName", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/buckets/%s/scopes/%s/collections/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4, pathParam5)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCertificateRequest generates requests for GetCertificate
func NewGetCertificateRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/certificates", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCloudSnapshotBackupsRequest generates requests for ListCloudSnapshotBackups
func NewListCloudSnapshotBackupsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListCloudSnapshotBackupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/cloudsnapshotbackups", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCloudSnapshotBackupRequest calls the generic CreateCloudSnapshotBackup builder with application/json body
func NewCreateCloudSnapshotBackupRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateCloudSnapshotBackupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCloudSnapshotBackupRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewCreateCloudSnapshotBackupRequestWithBody generates requests for CreateCloudSnapshotBackup with any type of body
func NewCreateCloudSnapshotBackupRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/cloudsnapshotbackups", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGeographicRegionsRequest generates requests for ListGeographicRegions
func NewListGeographicRegionsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/cloudsnapshotbackups/regions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCloudSnapshotRestoresRequest generates requests for ListCloudSnapshotRestores
func NewListCloudSnapshotRestoresRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListCloudSnapshotRestoresParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/cloudsnapshotbackups/restores", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCloudSnapshotBackupRequest generates requests for DeleteCloudSnapshotBackup
func NewDeleteCloudSnapshotBackupRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/cloudsnapshotbackups/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditCloudSnapshotBackupRetentionRequest calls the generic EditCloudSnapshotBackupRetention builder with application/json body
func NewEditCloudSnapshotBackupRetentionRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body EditCloudSnapshotBackupRetentionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditCloudSnapshotBackupRetentionRequestWithBody(server, organizationId, projectId, clusterId, backupId, "application/json", bodyReader)
}

// NewEditCloudSnapshotBackupRetentionRequestWithBody generates requests for EditCloudSnapshotBackupRetention with any type of body
func NewEditCloudSnapshotBackupRetentionRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/cloudsnapshotbackups/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreRequest calls the generic Restore builder with application/json body
func NewRestoreRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body RestoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreRequestWithBody(server, organizationId, projectId, clusterId, backupId, "application/json", bodyReader)
}

// NewRestoreRequestWithBody generates requests for Restore with any type of body
func NewRestoreRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/cloudsnapshotbackups/%s/restore", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCloudSnapshotBackupScheduleRequest generates requests for DeleteCloudSnapshotBackupSchedule
func NewDeleteCloudSnapshotBackupScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/cloudsnapshotbackupschedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCloudSnapshotBackupScheduleRequest generates requests for GetCloudSnapshotBackupSchedule
func NewGetCloudSnapshotBackupScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/cloudsnapshotbackupschedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpsertCloudSnapshotBackupScheduleRequest calls the generic UpsertCloudSnapshotBackupSchedule builder with application/json body
func NewUpsertCloudSnapshotBackupScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpsertCloudSnapshotBackupScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertCloudSnapshotBackupScheduleRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewUpsertCloudSnapshotBackupScheduleRequestWithBody generates requests for UpsertCloudSnapshotBackupSchedule with any type of body
func NewUpsertCloudSnapshotBackupScheduleRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/cloudsnapshotbackupschedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssociateCMEKRequest generates requests for AssociateCMEK
func NewAssociateCMEKRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, cmekId CMEKId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "cmekId", runtime.ParamLocationPath, cmekId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/cmek/%s/associate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnassociateCMEKRequest generates requests for UnassociateCMEK
func NewUnassociateCMEKRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, cmekId CMEKId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "cmekId", runtime.ParamLocationPath, cmekId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/cmek/%s/unassociate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataAPIStatusRequest generates requests for GetDataAPIStatus
func NewGetDataAPIStatusRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/dataAPI", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDataApiAndPeeringRequest calls the generic UpdateDataApiAndPeering builder with application/json body
func NewUpdateDataApiAndPeeringRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpdateDataApiAndPeeringJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDataApiAndPeeringRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewUpdateDataApiAndPeeringRequestWithBody generates requests for UpdateDataApiAndPeering with any type of body
func NewUpdateDataApiAndPeeringRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/dataAPI", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDataAPIPrivateEndpointCommandRequest calls the generic GetDataAPIPrivateEndpointCommand builder with application/json body
func NewGetDataAPIPrivateEndpointCommandRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetDataAPIPrivateEndpointCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetDataAPIPrivateEndpointCommandRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewGetDataAPIPrivateEndpointCommandRequestWithBody generates requests for GetDataAPIPrivateEndpointCommand with any type of body
func NewGetDataAPIPrivateEndpointCommandRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/dataAPI/privateEndpointCommand", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListDataAPIPrivateEndpointsRequest generates requests for ListDataAPIPrivateEndpoints
func NewListDataAPIPrivateEndpointsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/dataAPI/privateEndpoints", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssociateDataAPIPrivateEndpointRequestRequest generates requests for AssociateDataAPIPrivateEndpointRequest
func NewAssociateDataAPIPrivateEndpointRequestRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "endpointId", runtime.ParamLocationPath, endpointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/dataAPI/privateEndpoints/%s/associate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisassociateDataAPIPrivateEndpointRequest generates requests for DisassociateDataAPIPrivateEndpoint
func NewDisassociateDataAPIPrivateEndpointRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "endpointId", runtime.ParamLocationPath, endpointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/dataAPI/privateEndpoints/%s/unassociate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMtlsCertificatesRequest generates requests for ListMtlsCertificates
func NewListMtlsCertificatesRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListMtlsCertificatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/mtls/certificates", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddMtlsCertificateRequest calls the generic AddMtlsCertificate builder with application/json body
func NewAddMtlsCertificateRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body AddMtlsCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddMtlsCertificateRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewAddMtlsCertificateRequestWithBody generates requests for AddMtlsCertificate with any type of body
func NewAddMtlsCertificateRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/mtls/certificates", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMtlsCertificateRequest generates requests for DeleteMtlsCertificate
func NewDeleteMtlsCertificateRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "certId", runtime.ParamLocationPath, certId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/mtls/certificates/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMtlsCertificateRequest generates requests for GetMtlsCertificate
func NewGetMtlsCertificateRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "certId", runtime.ParamLocationPath, certId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/mtls/certificates/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutMtlsCertificateRequest calls the generic PutMtlsCertificate builder with application/json body
func NewPutMtlsCertificateRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, body PutMtlsCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutMtlsCertificateRequestWithBody(server, organizationId, projectId, clusterId, certId, "application/json", bodyReader)
}

// NewPutMtlsCertificateRequestWithBody generates requests for PutMtlsCertificate with any type of body
func NewPutMtlsCertificateRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "certId", runtime.ParamLocationPath, certId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/mtls/certificates/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMtlsConfigurationRequest generates requests for GetMtlsConfiguration
func NewGetMtlsConfigurationRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/mtls/config", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMtlsConfigurationRequest calls the generic UpdateMtlsConfiguration builder with application/json body
func NewUpdateMtlsConfigurationRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpdateMtlsConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMtlsConfigurationRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewUpdateMtlsConfigurationRequestWithBody generates requests for UpdateMtlsConfiguration with any type of body
func NewUpdateMtlsConfigurationRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/mtls/config", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListNetworkPeeringRecordsRequest generates requests for ListNetworkPeeringRecords
func NewListNetworkPeeringRecordsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListNetworkPeeringRecordsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/networkPeers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostNetworkPeeringRequest calls the generic PostNetworkPeering builder with application/json body
func NewPostNetworkPeeringRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostNetworkPeeringJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNetworkPeeringRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewPostNetworkPeeringRequestWithBody generates requests for PostNetworkPeering with any type of body
func NewPostNetworkPeeringRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/networkPeers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAzureVnetPeeringCommandRequest calls the generic GetAzureVnetPeeringCommand builder with application/json body
func NewGetAzureVnetPeeringCommandRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetAzureVnetPeeringCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetAzureVnetPeeringCommandRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewGetAzureVnetPeeringCommandRequestWithBody generates requests for GetAzureVnetPeeringCommand with any type of body
func NewGetAzureVnetPeeringCommandRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/networkPeers/networkPeerCommand", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNetworkPeeringRequest generates requests for DeleteNetworkPeering
func NewDeleteNetworkPeeringRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, peerId PeerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "peerId", runtime.ParamLocationPath, peerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/networkPeers/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetworkPeeringRecordRequest generates requests for GetNetworkPeeringRecord
func NewGetNetworkPeeringRecordRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, peerId PeerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "peerId", runtime.ParamLocationPath, peerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/networkPeers/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteOnOffScheduleRequest generates requests for DeleteOnOffSchedule
func NewDeleteOnOffScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/onOffSchedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOnOffScheduleRequest generates requests for GetOnOffSchedule
func NewGetOnOffScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/onOffSchedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOnOffScheduleRequest calls the generic PostOnOffSchedule builder with application/json body
func NewPostOnOffScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostOnOffScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOnOffScheduleRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewPostOnOffScheduleRequestWithBody generates requests for PostOnOffSchedule with any type of body
func NewPostOnOffScheduleRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/onOffSchedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutOnOffScheduleRequest calls the generic PutOnOffSchedule builder with application/json body
func NewPutOnOffScheduleRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutOnOffScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutOnOffScheduleRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewPutOnOffScheduleRequestWithBody generates requests for PutOnOffSchedule with any type of body
func NewPutOnOffScheduleRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/onOffSchedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisablePrivateEndpointServiceRequest generates requests for DisablePrivateEndpointService
func NewDisablePrivateEndpointServiceRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/privateEndpointService", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPrivateEndpointServiceStatusRequest generates requests for GetPrivateEndpointServiceStatus
func NewGetPrivateEndpointServiceStatusRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/privateEndpointService", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnablePrivateEndpointServiceRequest generates requests for EnablePrivateEndpointService
func NewEnablePrivateEndpointServiceRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/privateEndpointService", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPrivateEndpointCommandRequest calls the generic GetPrivateEndpointCommand builder with application/json body
func NewGetPrivateEndpointCommandRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetPrivateEndpointCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPrivateEndpointCommandRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewGetPrivateEndpointCommandRequestWithBody generates requests for GetPrivateEndpointCommand with any type of body
func NewGetPrivateEndpointCommandRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/privateEndpointService/endpointCommand", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPrivateEndpointsRequest generates requests for ListPrivateEndpoints
func NewListPrivateEndpointsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/privateEndpointService/endpoints", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptPrivateEndpointRequest generates requests for AcceptPrivateEndpoint
func NewAcceptPrivateEndpointRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "endpointId", runtime.ParamLocationPath, endpointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/privateEndpointService/endpoints/%s/associate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePrivateEndpointRequest generates requests for DeletePrivateEndpoint
func NewDeletePrivateEndpointRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "endpointId", runtime.ParamLocationPath, endpointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/privateEndpointService/endpoints/%s/unassociate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIndexBuildStatusRequest generates requests for IndexBuildStatus
func NewIndexBuildStatusRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, indexName IndexName, params *IndexBuildStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "indexName", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/queryService/indexBuildStatus/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bucket", runtime.ParamLocationQuery, params.Bucket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Collection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collection", runtime.ParamLocationQuery, *params.Collection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIndexDefinitionsRequest generates requests for ListIndexDefinitions
func NewListIndexDefinitionsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListIndexDefinitionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/queryService/indexes", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bucket", runtime.ParamLocationQuery, params.Bucket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Collection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collection", runtime.ParamLocationQuery, *params.Collection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewManageQueryIndexesRequest calls the generic ManageQueryIndexes builder with application/json body
func NewManageQueryIndexesRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body ManageQueryIndexesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewManageQueryIndexesRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewManageQueryIndexesRequestWithBody generates requests for ManageQueryIndexes with any type of body
func NewManageQueryIndexesRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/queryService/indexes", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIndexDefinitionRequest generates requests for IndexDefinition
func NewIndexDefinitionRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, indexName IndexName, params *IndexDefinitionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "indexName", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/queryService/indexes/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bucket", runtime.ParamLocationQuery, params.Bucket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Collection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collection", runtime.ParamLocationQuery, *params.Collection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClusterReplicationsRequest generates requests for ListClusterReplications
func NewListClusterReplicationsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListClusterReplicationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/replications", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateReplicationRequest calls the generic CreateReplication builder with application/json body
func NewCreateReplicationRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateReplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateReplicationRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewCreateReplicationRequestWithBody generates requests for CreateReplication with any type of body
func NewCreateReplicationRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/replications", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReplicationRequest generates requests for DeleteReplication
func NewDeleteReplicationRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "replicationId", runtime.ParamLocationPath, replicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/replications/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReplicationRequest generates requests for GetReplication
func NewGetReplicationRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "replicationId", runtime.ParamLocationPath, replicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/replications/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateReplicationRequest calls the generic UpdateReplication builder with application/json body
func NewUpdateReplicationRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, body UpdateReplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateReplicationRequestWithBody(server, organizationId, projectId, clusterId, replicationId, "application/json", bodyReader)
}

// NewUpdateReplicationRequestWithBody generates requests for UpdateReplication with any type of body
func NewUpdateReplicationRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "replicationId", runtime.ParamLocationPath, replicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/replications/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPauseReplicationRequest generates requests for PauseReplication
func NewPauseReplicationRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "replicationId", runtime.ParamLocationPath, replicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/replications/%s/activationStatus", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResumeReplicationRequest generates requests for ResumeReplication
func NewResumeReplicationRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "replicationId", runtime.ParamLocationPath, replicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/replications/%s/activationStatus", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSampleBucketsRequest generates requests for ListSampleBuckets
func NewListSampleBucketsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/sampleBuckets", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSampleBucketRequest calls the generic PostSampleBucket builder with application/json body
func NewPostSampleBucketRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostSampleBucketJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSampleBucketRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewPostSampleBucketRequestWithBody generates requests for PostSampleBucket with any type of body
func NewPostSampleBucketRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/sampleBuckets", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSampleDataByBucketIDRequest generates requests for DeleteSampleDataByBucketID
func NewDeleteSampleDataByBucketIDRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/sampleBuckets/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSampleBucketByIdRequest generates requests for GetSampleBucketById
func NewGetSampleBucketByIdRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "bucketId", runtime.ParamLocationPath, bucketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/sampleBuckets/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDatabaseCredentialsRequest generates requests for ListDatabaseCredentials
func NewListDatabaseCredentialsRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListDatabaseCredentialsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/users", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDatabaseCredentialRequest calls the generic PostDatabaseCredential builder with application/json body
func NewPostDatabaseCredentialRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostDatabaseCredentialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDatabaseCredentialRequestWithBody(server, organizationId, projectId, clusterId, "application/json", bodyReader)
}

// NewPostDatabaseCredentialRequestWithBody generates requests for PostDatabaseCredential with any type of body
func NewPostDatabaseCredentialRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/users", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDatabaseCredentialRequest generates requests for DeleteDatabaseCredential
func NewDeleteDatabaseCredentialRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/users/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatabaseCredentialRequest generates requests for GetDatabaseCredential
func NewGetDatabaseCredentialRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/users/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutDatabaseCredentialRequest calls the generic PutDatabaseCredential builder with application/json body
func NewPutDatabaseCredentialRequest(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, params *PutDatabaseCredentialParams, body PutDatabaseCredentialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutDatabaseCredentialRequestWithBody(server, organizationId, projectId, clusterId, userId, params, "application/json", bodyReader)
}

// NewPutDatabaseCredentialRequestWithBody generates requests for PutDatabaseCredential with any type of body
func NewPutDatabaseCredentialRequestWithBody(server string, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, params *PutDatabaseCredentialParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/clusters/%s/users/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewListProjectEventsRequest generates requests for ListProjectEvents
func NewListProjectEventsRequest(server string, organizationId OrganizationId, projectId ProjectId, params *ListProjectEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/events", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userIds", runtime.ParamLocationQuery, *params.UserIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClusterIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clusterIds", runtime.ParamLocationQuery, *params.ClusterIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeverityLevels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severityLevels", runtime.ParamLocationQuery, *params.SeverityLevels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectEventByIDRequest generates requests for GetProjectEventByID
func NewGetProjectEventByIDRequest(server string, organizationId OrganizationId, projectId ProjectId, eventId EventId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "eventId", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/events/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectReplicationsRequest generates requests for ListProjectReplications
func NewListProjectReplicationsRequest(server string, organizationId OrganizationId, projectId ProjectId, params *ListProjectReplicationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/projects/%s/replications", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, organizationId OrganizationId, params *ListUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUserRequest calls the generic PostUser builder with application/json body
func NewPostUserRequest(server string, organizationId OrganizationId, body PostUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUserRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewPostUserRequestWithBody generates requests for PostUser with any type of body
func NewPostUserRequestWithBody(server string, organizationId OrganizationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, organizationId OrganizationId, userId CPUserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, organizationId OrganizationId, userId CPUserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUserRequest calls the generic PatchUser builder with application/json body
func NewPatchUserRequest(server string, organizationId OrganizationId, userId CPUserId, body PatchUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserRequestWithBody(server, organizationId, userId, "application/json", bodyReader)
}

// NewPatchUserRequestWithBody generates requests for PatchUser with any type of body
func NewPatchUserRequestWithBody(server string, organizationId OrganizationId, userId CPUserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v4/organizations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListOrganizationsWithResponse request
	ListOrganizationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOrganizationsResp, error)

	// GetOrganizationByIDWithResponse request
	GetOrganizationByIDWithResponse(ctx context.Context, organizationId OrganizationId, reqEditors ...RequestEditorFn) (*GetOrganizationByIDResp, error)

	// ListModelsWithResponse request
	ListModelsWithResponse(ctx context.Context, organizationId OrganizationId, params *ListModelsParams, reqEditors ...RequestEditorFn) (*ListModelsResp, error)

	// CreateModelWithBodyWithResponse request with any body
	CreateModelWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModelResp, error)

	CreateModelWithResponse(ctx context.Context, organizationId OrganizationId, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModelResp, error)

	// DestroyModelWithResponse request
	DestroyModelWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, reqEditors ...RequestEditorFn) (*DestroyModelResp, error)

	// GetModelWithResponse request
	GetModelWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, reqEditors ...RequestEditorFn) (*GetModelResp, error)

	// ListModelAPIKeysWithResponse request
	ListModelAPIKeysWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, params *ListModelAPIKeysParams, reqEditors ...RequestEditorFn) (*ListModelAPIKeysResp, error)

	// CreateModelAPIKeyWithBodyWithResponse request with any body
	CreateModelAPIKeyWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModelAPIKeyResp, error)

	CreateModelAPIKeyWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, body CreateModelAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModelAPIKeyResp, error)

	// DeleteModelAPIKeyWithResponse request
	DeleteModelAPIKeyWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, apiKeyId ModelAPIKeyId, reqEditors ...RequestEditorFn) (*DeleteModelAPIKeyResp, error)

	// GetModelAPIKeyWithResponse request
	GetModelAPIKeyWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, apiKeyId ModelAPIKeyId, reqEditors ...RequestEditorFn) (*GetModelAPIKeyResp, error)

	// GetConnectionStringWithResponse request
	GetConnectionStringWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, reqEditors ...RequestEditorFn) (*GetConnectionStringResp, error)

	// ListProvidersWithResponse request
	ListProvidersWithResponse(ctx context.Context, organizationId OrganizationId, params *ListProvidersParams, reqEditors ...RequestEditorFn) (*ListProvidersResp, error)

	// CreateProviderWithBodyWithResponse request with any body
	CreateProviderWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProviderResp, error)

	CreateProviderWithResponse(ctx context.Context, organizationId OrganizationId, body CreateProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProviderResp, error)

	// DeleteProviderWithResponse request
	DeleteProviderWithResponse(ctx context.Context, organizationId OrganizationId, providerId ProviderId, reqEditors ...RequestEditorFn) (*DeleteProviderResp, error)

	// GetProviderWithResponse request
	GetProviderWithResponse(ctx context.Context, organizationId OrganizationId, providerId ProviderId, reqEditors ...RequestEditorFn) (*GetProviderResp, error)

	// UpdateProviderWithBodyWithResponse request with any body
	UpdateProviderWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, providerId ProviderId, params *UpdateProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProviderResp, error)

	UpdateProviderWithResponse(ctx context.Context, organizationId OrganizationId, providerId ProviderId, params *UpdateProviderParams, body UpdateProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProviderResp, error)

	// ListOrganizationLevelAnalyticsClustersWithResponse request
	ListOrganizationLevelAnalyticsClustersWithResponse(ctx context.Context, organizationId OrganizationId, params *ListOrganizationLevelAnalyticsClustersParams, reqEditors ...RequestEditorFn) (*ListOrganizationLevelAnalyticsClustersResp, error)

	// ListOrganizationAPIKeysWithResponse request
	ListOrganizationAPIKeysWithResponse(ctx context.Context, organizationId OrganizationId, params *ListOrganizationAPIKeysParams, reqEditors ...RequestEditorFn) (*ListOrganizationAPIKeysResp, error)

	// PostOrganizationAPIKeysWithBodyWithResponse request with any body
	PostOrganizationAPIKeysWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrganizationAPIKeysResp, error)

	PostOrganizationAPIKeysWithResponse(ctx context.Context, organizationId OrganizationId, body PostOrganizationAPIKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrganizationAPIKeysResp, error)

	// DeleteOrganizationAPIKeyWithResponse request
	DeleteOrganizationAPIKeyWithResponse(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, reqEditors ...RequestEditorFn) (*DeleteOrganizationAPIKeyResp, error)

	// GetOrganizationAPIKeyByAccessKeyWithResponse request
	GetOrganizationAPIKeyByAccessKeyWithResponse(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, reqEditors ...RequestEditorFn) (*GetOrganizationAPIKeyByAccessKeyResp, error)

	// PostOrganizationAPIKeyRotateWithBodyWithResponse request with any body
	PostOrganizationAPIKeyRotateWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrganizationAPIKeyRotateResp, error)

	PostOrganizationAPIKeyRotateWithResponse(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, body PostOrganizationAPIKeyRotateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrganizationAPIKeyRotateResp, error)

	// ListAppServicesWithResponse request
	ListAppServicesWithResponse(ctx context.Context, organizationId OrganizationId, params *ListAppServicesParams, reqEditors ...RequestEditorFn) (*ListAppServicesResp, error)

	// GetCloudAccountsWithResponse request
	GetCloudAccountsWithResponse(ctx context.Context, organizationId OrganizationId, reqEditors ...RequestEditorFn) (*GetCloudAccountsResp, error)

	// GetKeyMetadataListWithResponse request
	GetKeyMetadataListWithResponse(ctx context.Context, organizationId OrganizationId, params *GetKeyMetadataListParams, reqEditors ...RequestEditorFn) (*GetKeyMetadataListResp, error)

	// PostCMEKMetadataWithBodyWithResponse request with any body
	PostCMEKMetadataWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCMEKMetadataResp, error)

	PostCMEKMetadataWithResponse(ctx context.Context, organizationId OrganizationId, body PostCMEKMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCMEKMetadataResp, error)

	// DeleteKeyMetadataWithResponse request
	DeleteKeyMetadataWithResponse(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*DeleteKeyMetadataResp, error)

	// GetKeyMetadataWithResponse request
	GetKeyMetadataWithResponse(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*GetKeyMetadataResp, error)

	// RotateCMEKKeyWithBodyWithResponse request with any body
	RotateCMEKKeyWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RotateCMEKKeyResp, error)

	RotateCMEKKeyWithResponse(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, body RotateCMEKKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*RotateCMEKKeyResp, error)

	// ListCMEKHistoryWithResponse request
	ListCMEKHistoryWithResponse(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, params *ListCMEKHistoryParams, reqEditors ...RequestEditorFn) (*ListCMEKHistoryResp, error)

	// PutOrganizationConfigurationWithBodyWithResponse request with any body
	PutOrganizationConfigurationWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, params *PutOrganizationConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutOrganizationConfigurationResp, error)

	PutOrganizationConfigurationWithResponse(ctx context.Context, organizationId OrganizationId, params *PutOrganizationConfigurationParams, body PutOrganizationConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*PutOrganizationConfigurationResp, error)

	// ListEventsWithResponse request
	ListEventsWithResponse(ctx context.Context, organizationId OrganizationId, params *ListEventsParams, reqEditors ...RequestEditorFn) (*ListEventsResp, error)

	// GetEventByIDWithResponse request
	GetEventByIDWithResponse(ctx context.Context, organizationId OrganizationId, eventId EventId, reqEditors ...RequestEditorFn) (*GetEventByIDResp, error)

	// ListProjectsWithResponse request
	ListProjectsWithResponse(ctx context.Context, organizationId OrganizationId, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResp, error)

	// PostProjectWithBodyWithResponse request with any body
	PostProjectWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProjectResp, error)

	PostProjectWithResponse(ctx context.Context, organizationId OrganizationId, body PostProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProjectResp, error)

	// DeleteProjectByIDWithResponse request
	DeleteProjectByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, reqEditors ...RequestEditorFn) (*DeleteProjectByIDResp, error)

	// GetProjectByIDWithResponse request
	GetProjectByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, reqEditors ...RequestEditorFn) (*GetProjectByIDResp, error)

	// PutProjectWithBodyWithResponse request with any body
	PutProjectWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *PutProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutProjectResp, error)

	PutProjectWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *PutProjectParams, body PutProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*PutProjectResp, error)

	// PostTestAlertIntegrationWithBodyWithResponse request with any body
	PostTestAlertIntegrationWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTestAlertIntegrationResp, error)

	PostTestAlertIntegrationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body PostTestAlertIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTestAlertIntegrationResp, error)

	// ListAlertIntegrationsWithResponse request
	ListAlertIntegrationsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListAlertIntegrationsParams, reqEditors ...RequestEditorFn) (*ListAlertIntegrationsResp, error)

	// PostAlertIntegrationWithBodyWithResponse request with any body
	PostAlertIntegrationWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAlertIntegrationResp, error)

	PostAlertIntegrationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body PostAlertIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAlertIntegrationResp, error)

	// DeleteAlertIntegrationByIDWithResponse request
	DeleteAlertIntegrationByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, reqEditors ...RequestEditorFn) (*DeleteAlertIntegrationByIDResp, error)

	// GetAlertIntegrationByIDWithResponse request
	GetAlertIntegrationByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, reqEditors ...RequestEditorFn) (*GetAlertIntegrationByIDResp, error)

	// PutAlertIntegrationWithBodyWithResponse request with any body
	PutAlertIntegrationWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAlertIntegrationResp, error)

	PutAlertIntegrationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, body PutAlertIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAlertIntegrationResp, error)

	// ListProjectLevelAnalyticsClustersWithResponse request
	ListProjectLevelAnalyticsClustersWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectLevelAnalyticsClustersParams, reqEditors ...RequestEditorFn) (*ListProjectLevelAnalyticsClustersResp, error)

	// CreateAnalyticsClusterWithBodyWithResponse request with any body
	CreateAnalyticsClusterWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAnalyticsClusterResp, error)

	CreateAnalyticsClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body CreateAnalyticsClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAnalyticsClusterResp, error)

	// DeleteAnalyticsClusterWithResponse request
	DeleteAnalyticsClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*DeleteAnalyticsClusterResp, error)

	// GetAnalyticsClusterWithResponse request
	GetAnalyticsClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*GetAnalyticsClusterResp, error)

	// PutAnalyticsClusterWithBodyWithResponse request with any body
	PutAnalyticsClusterWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *PutAnalyticsClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAnalyticsClusterResp, error)

	PutAnalyticsClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *PutAnalyticsClusterParams, body PutAnalyticsClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAnalyticsClusterResp, error)

	// AnalyticsClusterOffWithResponse request
	AnalyticsClusterOffWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*AnalyticsClusterOffResp, error)

	// AnalyticsClusterOnWithResponse request
	AnalyticsClusterOnWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*AnalyticsClusterOnResp, error)

	// ListAnalyticsAllowedCidrsWithResponse request
	ListAnalyticsAllowedCidrsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListAnalyticsAllowedCidrsParams, reqEditors ...RequestEditorFn) (*ListAnalyticsAllowedCidrsResp, error)

	// PostAnalyticsAllowedCidrWithBodyWithResponse request with any body
	PostAnalyticsAllowedCidrWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnalyticsAllowedCidrResp, error)

	PostAnalyticsAllowedCidrWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PostAnalyticsAllowedCidrJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnalyticsAllowedCidrResp, error)

	// DeleteColumnarAllowedCidrByIDWithResponse request
	DeleteColumnarAllowedCidrByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*DeleteColumnarAllowedCidrByIDResp, error)

	// GetColumnarAllowedCidrByIDWithResponse request
	GetColumnarAllowedCidrByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*GetColumnarAllowedCidrByIDResp, error)

	// DeleteColumnarAnalyticsBackupScheduleWithResponse request
	DeleteColumnarAnalyticsBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*DeleteColumnarAnalyticsBackupScheduleResp, error)

	// GetColumnarAnalyticsBackupScheduleWithResponse request
	GetColumnarAnalyticsBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*GetColumnarAnalyticsBackupScheduleResp, error)

	// UpsertColumnarAnalyticsBackupScheduleWithBodyWithResponse request with any body
	UpsertColumnarAnalyticsBackupScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertColumnarAnalyticsBackupScheduleResp, error)

	UpsertColumnarAnalyticsBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body UpsertColumnarAnalyticsBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertColumnarAnalyticsBackupScheduleResp, error)

	// ListColumnarAnalyticsBackupsWithResponse request
	ListColumnarAnalyticsBackupsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListColumnarAnalyticsBackupsParams, reqEditors ...RequestEditorFn) (*ListColumnarAnalyticsBackupsResp, error)

	// CreateColumnarAnalyticsBackupWithBodyWithResponse request with any body
	CreateColumnarAnalyticsBackupWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateColumnarAnalyticsBackupResp, error)

	CreateColumnarAnalyticsBackupWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body CreateColumnarAnalyticsBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateColumnarAnalyticsBackupResp, error)

	// ListColumnarAnalyticsRestoresWithResponse request
	ListColumnarAnalyticsRestoresWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListColumnarAnalyticsRestoresParams, reqEditors ...RequestEditorFn) (*ListColumnarAnalyticsRestoresResp, error)

	// DeleteColumnarAnalyticsBackupWithResponse request
	DeleteColumnarAnalyticsBackupWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*DeleteColumnarAnalyticsBackupResp, error)

	// UpdateColumnarAnalyticsBackupRetentionWithBodyWithResponse request with any body
	UpdateColumnarAnalyticsBackupRetentionWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateColumnarAnalyticsBackupRetentionResp, error)

	UpdateColumnarAnalyticsBackupRetentionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, body UpdateColumnarAnalyticsBackupRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateColumnarAnalyticsBackupRetentionResp, error)

	// RestoreColumnarAnalyticsClusterWithResponse request
	RestoreColumnarAnalyticsClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*RestoreColumnarAnalyticsClusterResp, error)

	// DeleteAnalyticsOnOffScheduleWithResponse request
	DeleteAnalyticsOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*DeleteAnalyticsOnOffScheduleResp, error)

	// GetAnalyticsOnOffScheduleWithResponse request
	GetAnalyticsOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*GetAnalyticsOnOffScheduleResp, error)

	// PostAnalyticsOnOffScheduleWithBodyWithResponse request with any body
	PostAnalyticsOnOffScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnalyticsOnOffScheduleResp, error)

	PostAnalyticsOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PostAnalyticsOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnalyticsOnOffScheduleResp, error)

	// PutAnalyticsOnOffScheduleWithBodyWithResponse request with any body
	PutAnalyticsOnOffScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAnalyticsOnOffScheduleResp, error)

	PutAnalyticsOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PutAnalyticsOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAnalyticsOnOffScheduleResp, error)

	// DisableColumnarPrivateEndpointServiceWithResponse request
	DisableColumnarPrivateEndpointServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*DisableColumnarPrivateEndpointServiceResp, error)

	// GetColumnarPrivateEndpointServiceStatusWithResponse request
	GetColumnarPrivateEndpointServiceStatusWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*GetColumnarPrivateEndpointServiceStatusResp, error)

	// EnableColumnarPrivateEndpointServiceWithResponse request
	EnableColumnarPrivateEndpointServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*EnableColumnarPrivateEndpointServiceResp, error)

	// GetColumnarPrivateEndpointServiceCommandWithBodyWithResponse request with any body
	GetColumnarPrivateEndpointServiceCommandWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetColumnarPrivateEndpointServiceCommandResp, error)

	GetColumnarPrivateEndpointServiceCommandWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body GetColumnarPrivateEndpointServiceCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*GetColumnarPrivateEndpointServiceCommandResp, error)

	// ListColumnarPrivateEndpointServiceConnectionWithResponse request
	ListColumnarPrivateEndpointServiceConnectionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*ListColumnarPrivateEndpointServiceConnectionResp, error)

	// AcceptColumnarPrivateEndpointServiceConnectionWithResponse request
	AcceptColumnarPrivateEndpointServiceConnectionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*AcceptColumnarPrivateEndpointServiceConnectionResp, error)

	// RejectColumnarPrivateEndpointServiceConnectionWithResponse request
	RejectColumnarPrivateEndpointServiceConnectionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*RejectColumnarPrivateEndpointServiceConnectionResp, error)

	// ListProjectLevelCloudSnapshotBackupsWithResponse request
	ListProjectLevelCloudSnapshotBackupsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectLevelCloudSnapshotBackupsParams, reqEditors ...RequestEditorFn) (*ListProjectLevelCloudSnapshotBackupsResp, error)

	// CloneWithBodyWithResponse request with any body
	CloneWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloneResp, error)

	CloneWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, backupId BackupId, body CloneJSONRequestBody, reqEditors ...RequestEditorFn) (*CloneResp, error)

	// ListClustersWithResponse request
	ListClustersWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResp, error)

	// PostClusterWithBodyWithResponse request with any body
	PostClusterWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClusterResp, error)

	PostClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClusterResp, error)

	// CreateFreeTierClusterWithBodyWithResponse request with any body
	CreateFreeTierClusterWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFreeTierClusterResp, error)

	CreateFreeTierClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body CreateFreeTierClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFreeTierClusterResp, error)

	// DeleteFreeTierClusterWithResponse request
	DeleteFreeTierClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*DeleteFreeTierClusterResp, error)

	// GetFreeTierClusterWithResponse request
	GetFreeTierClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetFreeTierClusterResp, error)

	// UpdateFreeTierClusterWithBodyWithResponse request with any body
	UpdateFreeTierClusterWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *UpdateFreeTierClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFreeTierClusterResp, error)

	UpdateFreeTierClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *UpdateFreeTierClusterParams, body UpdateFreeTierClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFreeTierClusterResp, error)

	// FreeTierClusterOffWithResponse request
	FreeTierClusterOffWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*FreeTierClusterOffResp, error)

	// FreeTierClusterOnWithResponse request
	FreeTierClusterOnWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*FreeTierClusterOnResp, error)

	// DeleteClusterWithResponse request
	DeleteClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResp, error)

	// GetClusterWithResponse request
	GetClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetClusterResp, error)

	// PutClusterWithBodyWithResponse request with any body
	PutClusterWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *PutClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutClusterResp, error)

	PutClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *PutClusterParams, body PutClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PutClusterResp, error)

	// ClusterOffWithResponse request
	ClusterOffWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ClusterOffResp, error)

	// ClusterOnWithBodyWithResponse request with any body
	ClusterOnWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClusterOnResp, error)

	ClusterOnWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body ClusterOnJSONRequestBody, reqEditors ...RequestEditorFn) (*ClusterOnResp, error)

	// ListAiWorkflowsWithResponse request
	ListAiWorkflowsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAiWorkflowsParams, reqEditors ...RequestEditorFn) (*ListAiWorkflowsResp, error)

	// CreateAiWorkflowWithBodyWithResponse request with any body
	CreateAiWorkflowWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAiWorkflowResp, error)

	CreateAiWorkflowWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateAiWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAiWorkflowResp, error)

	// DeleteAiWorkflowWithResponse request
	DeleteAiWorkflowWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*DeleteAiWorkflowResp, error)

	// GetAiWorkflowWithResponse request
	GetAiWorkflowWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*GetAiWorkflowResp, error)

	// StopAiWorkflowRunWithResponse request
	StopAiWorkflowRunWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*StopAiWorkflowRunResp, error)

	// ListAiWorkflowRunsWithResponse request
	ListAiWorkflowRunsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, params *ListAiWorkflowRunsParams, reqEditors ...RequestEditorFn) (*ListAiWorkflowRunsResp, error)

	// CreateAiWorkflowRunWithResponse request
	CreateAiWorkflowRunWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*CreateAiWorkflowRunResp, error)

	// GetAiWorkflowRunWithResponse request
	GetAiWorkflowRunWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, runId WorkflowRunId, reqEditors ...RequestEditorFn) (*GetAiWorkflowRunResp, error)

	// GetAiWorkflowRunProcessedFilesWithResponse request
	GetAiWorkflowRunProcessedFilesWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, runId WorkflowRunId, params *GetAiWorkflowRunProcessedFilesParams, reqEditors ...RequestEditorFn) (*GetAiWorkflowRunProcessedFilesResp, error)

	// ListAllowedCidrsWithResponse request
	ListAllowedCidrsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAllowedCidrsParams, reqEditors ...RequestEditorFn) (*ListAllowedCidrsResp, error)

	// PostAllowedCidrsWithBodyWithResponse request with any body
	PostAllowedCidrsWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAllowedCidrsResp, error)

	PostAllowedCidrsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAllowedCidrsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAllowedCidrsResp, error)

	// DeleteAllowedCidrByIDWithResponse request
	DeleteAllowedCidrByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*DeleteAllowedCidrByIDResp, error)

	// GetAllowedCidrByIDWithResponse request
	GetAllowedCidrByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*GetAllowedCidrByIDResp, error)

	// PostAppServiceWithBodyWithResponse request with any body
	PostAppServiceWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppServiceResp, error)

	PostAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppServiceResp, error)

	// CreateFreeTierAppServiceWithBodyWithResponse request with any body
	CreateFreeTierAppServiceWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFreeTierAppServiceResp, error)

	CreateFreeTierAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateFreeTierAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFreeTierAppServiceResp, error)

	// DeleteFreeTierAppServiceWithResponse request
	DeleteFreeTierAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*DeleteFreeTierAppServiceResp, error)

	// GetFreeTierAppServiceWithResponse request
	GetFreeTierAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*GetFreeTierAppServiceResp, error)

	// UpdateFreeTierAppServiceWithBodyWithResponse request with any body
	UpdateFreeTierAppServiceWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *UpdateFreeTierAppServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFreeTierAppServiceResp, error)

	UpdateFreeTierAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *UpdateFreeTierAppServiceParams, body UpdateFreeTierAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFreeTierAppServiceResp, error)

	// DeleteAppServiceWithResponse request
	DeleteAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*DeleteAppServiceResp, error)

	// GetAppServiceWithResponse request
	GetAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*GetAppServiceResp, error)

	// PutAppServiceWithBodyWithResponse request with any body
	PutAppServiceWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *PutAppServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAppServiceResp, error)

	PutAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *PutAppServiceParams, body PutAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAppServiceResp, error)

	// AppServiceOffWithResponse request
	AppServiceOffWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*AppServiceOffResp, error)

	// AppServiceOnWithResponse request
	AppServiceOnWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*AppServiceOnResp, error)

	// ListAppServiceAdminUsersWithResponse request
	ListAppServiceAdminUsersWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAdminUsersParams, reqEditors ...RequestEditorFn) (*ListAppServiceAdminUsersResp, error)

	// AddAppServiceAdminUserWithBodyWithResponse request with any body
	AddAppServiceAdminUserWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAppServiceAdminUserResp, error)

	AddAppServiceAdminUserWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body AddAppServiceAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAppServiceAdminUserResp, error)

	// DeleteAppServiceAdminUserWithResponse request
	DeleteAppServiceAdminUserWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, reqEditors ...RequestEditorFn) (*DeleteAppServiceAdminUserResp, error)

	// GetAppServiceAdminUserWithResponse request
	GetAppServiceAdminUserWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, reqEditors ...RequestEditorFn) (*GetAppServiceAdminUserResp, error)

	// UpdateAppServiceAdminUserWithBodyWithResponse request with any body
	UpdateAppServiceAdminUserWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppServiceAdminUserResp, error)

	UpdateAppServiceAdminUserWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, body UpdateAppServiceAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppServiceAdminUserResp, error)

	// ListAppServiceAllowedCidrsWithResponse request
	ListAppServiceAllowedCidrsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAllowedCidrsParams, reqEditors ...RequestEditorFn) (*ListAppServiceAllowedCidrsResp, error)

	// PostAppServiceAllowedCidrWithBodyWithResponse request with any body
	PostAppServiceAllowedCidrWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppServiceAllowedCidrResp, error)

	PostAppServiceAllowedCidrWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppServiceAllowedCidrJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppServiceAllowedCidrResp, error)

	// DeleteAppServiceAllowedCidrWithResponse request
	DeleteAppServiceAllowedCidrWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*DeleteAppServiceAllowedCidrResp, error)

	// ListAppEndpointsWithResponse request
	ListAppEndpointsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppEndpointsParams, reqEditors ...RequestEditorFn) (*ListAppEndpointsResp, error)

	// PostAppEndpointWithBodyWithResponse request with any body
	PostAppEndpointWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppEndpointResp, error)

	PostAppEndpointWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppEndpointResp, error)

	// DeleteAccessFunctionWithResponse request
	DeleteAccessFunctionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*DeleteAccessFunctionResp, error)

	// GetAccessFunctionWithResponse request
	GetAccessFunctionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*GetAccessFunctionResp, error)

	// PutAccessFunctionWithBodyWithResponse request with any body
	PutAccessFunctionWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAccessFunctionResp, error)

	// DeleteImportFilterWithResponse request
	DeleteImportFilterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*DeleteImportFilterResp, error)

	// GetImportFilterWithResponse request
	GetImportFilterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*GetImportFilterResp, error)

	// PutImportFilterWithBodyWithResponse request with any body
	PutImportFilterWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutImportFilterResp, error)

	// DeleteAppEndpointWithResponse request
	DeleteAppEndpointWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*DeleteAppEndpointResp, error)

	// GetAppEndpointWithResponse request
	GetAppEndpointWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*GetAppEndpointResp, error)

	// PutAppEndpointWithBodyWithResponse request with any body
	PutAppEndpointWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAppEndpointResp, error)

	PutAppEndpointWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAppEndpointResp, error)

	// DeleteAppEndpointActivationStatusWithResponse request
	DeleteAppEndpointActivationStatusWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*DeleteAppEndpointActivationStatusResp, error)

	// PostAppEndpointActivationStatusWithResponse request
	PostAppEndpointActivationStatusWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*PostAppEndpointActivationStatusResp, error)

	// ListAppEndpointAdminUsersWithResponse request
	ListAppEndpointAdminUsersWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointAdminUsersParams, reqEditors ...RequestEditorFn) (*ListAppEndpointAdminUsersResp, error)

	// GetAppEndpointAuditLogConfigWithResponse request
	GetAppEndpointAuditLogConfigWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*GetAppEndpointAuditLogConfigResp, error)

	// PutAppEndpointAuditLogConfigWithBodyWithResponse request with any body
	PutAppEndpointAuditLogConfigWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAppEndpointAuditLogConfigResp, error)

	PutAppEndpointAuditLogConfigWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointAuditLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAppEndpointAuditLogConfigResp, error)

	// GetAppServiceAuditLogEventsWithResponse request
	GetAppServiceAuditLogEventsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*GetAppServiceAuditLogEventsResp, error)

	// ListAppEndpointCollectionsWithResponse request
	ListAppEndpointCollectionsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointCollectionsParams, reqEditors ...RequestEditorFn) (*ListAppEndpointCollectionsResp, error)

	// GetAppEndpointCORSWithResponse request
	GetAppEndpointCORSWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*GetAppEndpointCORSResp, error)

	// PutAppEndpointCORSWithBodyWithResponse request with any body
	PutAppEndpointCORSWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAppEndpointCORSResp, error)

	PutAppEndpointCORSWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointCORSJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAppEndpointCORSResp, error)

	// ListAppEndpointOIDCProvidersWithResponse request
	ListAppEndpointOIDCProvidersWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointOIDCProvidersParams, reqEditors ...RequestEditorFn) (*ListAppEndpointOIDCProvidersResp, error)

	// CreateAppEndpointOIDCProviderWithBodyWithResponse request with any body
	CreateAppEndpointOIDCProviderWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppEndpointOIDCProviderResp, error)

	CreateAppEndpointOIDCProviderWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body CreateAppEndpointOIDCProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppEndpointOIDCProviderResp, error)

	// UpdateAppEndpointOIDCDefaultProviderWithBodyWithResponse request with any body
	UpdateAppEndpointOIDCDefaultProviderWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppEndpointOIDCDefaultProviderResp, error)

	UpdateAppEndpointOIDCDefaultProviderWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body UpdateAppEndpointOIDCDefaultProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppEndpointOIDCDefaultProviderResp, error)

	// DeleteAppEndpointOIDCProviderWithResponse request
	DeleteAppEndpointOIDCProviderWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, reqEditors ...RequestEditorFn) (*DeleteAppEndpointOIDCProviderResp, error)

	// GetAppEndpointOIDCProviderWithResponse request
	GetAppEndpointOIDCProviderWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, reqEditors ...RequestEditorFn) (*GetAppEndpointOIDCProviderResp, error)

	// UpdateAppEndpointOIDCProviderWithBodyWithResponse request with any body
	UpdateAppEndpointOIDCProviderWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppEndpointOIDCProviderResp, error)

	UpdateAppEndpointOIDCProviderWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, body UpdateAppEndpointOIDCProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppEndpointOIDCProviderResp, error)

	// DeleteAppEndpointResyncWithResponse request
	DeleteAppEndpointResyncWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*DeleteAppEndpointResyncResp, error)

	// GetAppEndpointResyncWithResponse request
	GetAppEndpointResyncWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*GetAppEndpointResyncResp, error)

	// PostAppEndpointResyncWithBodyWithResponse request with any body
	PostAppEndpointResyncWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppEndpointResyncResp, error)

	PostAppEndpointResyncWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PostAppEndpointResyncJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppEndpointResyncResp, error)

	// GetAppServiceAuditLogStateWithResponse request
	GetAppServiceAuditLogStateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*GetAppServiceAuditLogStateResp, error)

	// PutAppServiceAuditLogStateWithBodyWithResponse request with any body
	PutAppServiceAuditLogStateWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAppServiceAuditLogStateResp, error)

	PutAppServiceAuditLogStateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PutAppServiceAuditLogStateJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAppServiceAuditLogStateResp, error)

	// ListAppServiceAuditLogExportsWithResponse request
	ListAppServiceAuditLogExportsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAuditLogExportsParams, reqEditors ...RequestEditorFn) (*ListAppServiceAuditLogExportsResp, error)

	// PostAppServiceAuditLogExportWithBodyWithResponse request with any body
	PostAppServiceAuditLogExportWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppServiceAuditLogExportResp, error)

	PostAppServiceAuditLogExportWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppServiceAuditLogExportJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppServiceAuditLogExportResp, error)

	// GetAppServiceAuditLogExportByIdWithResponse request
	GetAppServiceAuditLogExportByIdWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, auditLogExportId AuditLogExportId, reqEditors ...RequestEditorFn) (*GetAppServiceAuditLogExportByIdResp, error)

	// GetAppServiceAuditLogStreamingWithResponse request
	GetAppServiceAuditLogStreamingWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*GetAppServiceAuditLogStreamingResp, error)

	// PatchAppServiceAuditLogStreamingWithBodyWithResponse request with any body
	PatchAppServiceAuditLogStreamingWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAppServiceAuditLogStreamingResp, error)

	PatchAppServiceAuditLogStreamingWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PatchAppServiceAuditLogStreamingJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAppServiceAuditLogStreamingResp, error)

	// PutAppServiceAuditLogStreamingWithBodyWithResponse request with any body
	PutAppServiceAuditLogStreamingWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAppServiceAuditLogStreamingResp, error)

	PutAppServiceAuditLogStreamingWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PutAppServiceAuditLogStreamingJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAppServiceAuditLogStreamingResp, error)

	// GetAppServiceCertificateWithResponse request
	GetAppServiceCertificateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*GetAppServiceCertificateResp, error)

	// DeleteAppServicePrivateEndpointsWithResponse request
	DeleteAppServicePrivateEndpointsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*DeleteAppServicePrivateEndpointsResp, error)

	// GetAppServicePrivateEndpointsWithResponse request
	GetAppServicePrivateEndpointsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*GetAppServicePrivateEndpointsResp, error)

	// PostAppServicePrivateEndpointsWithResponse request
	PostAppServicePrivateEndpointsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*PostAppServicePrivateEndpointsResp, error)

	// ListAppServicePrivateEndpointsWithResponse request
	ListAppServicePrivateEndpointsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*ListAppServicePrivateEndpointsResp, error)

	// DeletePrivateEndpointRequestWithResponse request
	DeletePrivateEndpointRequestWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*DeletePrivateEndpointRequestResp, error)

	// AcceptPrivateEndpointRequestWithResponse request
	AcceptPrivateEndpointRequestWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*AcceptPrivateEndpointRequestResp, error)

	// GetAppServicePrivateEndpointsCommandWithBodyWithResponse request with any body
	GetAppServicePrivateEndpointsCommandWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetAppServicePrivateEndpointsCommandResp, error)

	GetAppServicePrivateEndpointsCommandWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body GetAppServicePrivateEndpointsCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*GetAppServicePrivateEndpointsCommandResp, error)

	// GetClusterAuditSettingsWithResponse request
	GetClusterAuditSettingsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetClusterAuditSettingsResp, error)

	// PutClusterAuditSettingsWithBodyWithResponse request with any body
	PutClusterAuditSettingsWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutClusterAuditSettingsResp, error)

	PutClusterAuditSettingsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutClusterAuditSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PutClusterAuditSettingsResp, error)

	// GetAuditLogEventIDsWithResponse request
	GetAuditLogEventIDsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetAuditLogEventIDsResp, error)

	// ListAuditLogExportsWithResponse request
	ListAuditLogExportsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAuditLogExportsParams, reqEditors ...RequestEditorFn) (*ListAuditLogExportsResp, error)

	// PostAuditLogExportWithBodyWithResponse request with any body
	PostAuditLogExportWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuditLogExportResp, error)

	PostAuditLogExportWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAuditLogExportJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuditLogExportResp, error)

	// GetAuditLogExportWithResponse request
	GetAuditLogExportWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, auditLogExportId AuditLogExportId, reqEditors ...RequestEditorFn) (*GetAuditLogExportResp, error)

	// ListClusterBackupsWithResponse request
	ListClusterBackupsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListClusterBackupsResp, error)

	// DeleteBackupCycleByIDWithResponse request
	DeleteBackupCycleByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*DeleteBackupCycleByIDResp, error)

	// GetBackupByIDWithResponse request
	GetBackupByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*GetBackupByIDResp, error)

	// PostRestoreWithBodyWithResponse request with any body
	PostRestoreWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRestoreResp, error)

	PostRestoreWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body PostRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRestoreResp, error)

	// PutBucketStorageBackendWithBodyWithResponse request with any body
	PutBucketStorageBackendWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutBucketStorageBackendResp, error)

	PutBucketStorageBackendWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutBucketStorageBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*PutBucketStorageBackendResp, error)

	// ListBucketsWithResponse request
	ListBucketsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListBucketsResp, error)

	// PostBucketWithBodyWithResponse request with any body
	PostBucketWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBucketResp, error)

	PostBucketWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBucketResp, error)

	// ListFreeTierBucketsWithResponse request
	ListFreeTierBucketsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListFreeTierBucketsResp, error)

	// CreateFreeTierBucketWithBodyWithResponse request with any body
	CreateFreeTierBucketWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFreeTierBucketResp, error)

	CreateFreeTierBucketWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateFreeTierBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFreeTierBucketResp, error)

	// DeleteFreeTierBucketByIDWithResponse request
	DeleteFreeTierBucketByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*DeleteFreeTierBucketByIDResp, error)

	// GetFreeTierBucketByIDWithResponse request
	GetFreeTierBucketByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*GetFreeTierBucketByIDResp, error)

	// UpdateFreeTierBucketWithBodyWithResponse request with any body
	UpdateFreeTierBucketWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFreeTierBucketResp, error)

	UpdateFreeTierBucketWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body UpdateFreeTierBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFreeTierBucketResp, error)

	// DeleteBucketByIDWithResponse request
	DeleteBucketByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*DeleteBucketByIDResp, error)

	// GetBucketByIDWithResponse request
	GetBucketByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*GetBucketByIDResp, error)

	// PutBucketWithBodyWithResponse request with any body
	PutBucketWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutBucketResp, error)

	PutBucketWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PutBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*PutBucketResp, error)

	// ListCyclesWithResponse request
	ListCyclesWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, params *ListCyclesParams, reqEditors ...RequestEditorFn) (*ListCyclesResp, error)

	// ListBackupsWithResponse request
	ListBackupsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, cycleId CycleId, reqEditors ...RequestEditorFn) (*ListBackupsResp, error)

	// DeleteBackupScheduleWithResponse request
	DeleteBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*DeleteBackupScheduleResp, error)

	// GetBackupScheduleWithResponse request
	GetBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*GetBackupScheduleResp, error)

	// PostBackupScheduleWithBodyWithResponse request with any body
	PostBackupScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBackupScheduleResp, error)

	PostBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PostBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBackupScheduleResp, error)

	// PutBackupScheduleWithBodyWithResponse request with any body
	PutBackupScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutBackupScheduleResp, error)

	PutBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PutBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PutBackupScheduleResp, error)

	// PostBackupWithResponse request
	PostBackupWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*PostBackupResp, error)

	// FlushBucketWithResponse request
	FlushBucketWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*FlushBucketResp, error)

	// GetScopesWithResponse request
	GetScopesWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*GetScopesResp, error)

	// PostScopeWithBodyWithResponse request with any body
	PostScopeWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostScopeResp, error)

	PostScopeWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PostScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostScopeResp, error)

	// DeleteScopeByNameWithResponse request
	DeleteScopeByNameWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, reqEditors ...RequestEditorFn) (*DeleteScopeByNameResp, error)

	// GetScopeByNameWithResponse request
	GetScopeByNameWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, reqEditors ...RequestEditorFn) (*GetScopeByNameResp, error)

	// GetCollectionsWithResponse request
	GetCollectionsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, reqEditors ...RequestEditorFn) (*GetCollectionsResp, error)

	// PostCollectionWithBodyWithResponse request with any body
	PostCollectionWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCollectionResp, error)

	PostCollectionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, body PostCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCollectionResp, error)

	// DeleteCollectionByNameWithResponse request
	DeleteCollectionByNameWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, reqEditors ...RequestEditorFn) (*DeleteCollectionByNameResp, error)

	// GetCollectionByNameWithResponse request
	GetCollectionByNameWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, reqEditors ...RequestEditorFn) (*GetCollectionByNameResp, error)

	// PutCollectionWithBodyWithResponse request with any body
	PutCollectionWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutCollectionResp, error)

	PutCollectionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, body PutCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PutCollectionResp, error)

	// GetCertificateWithResponse request
	GetCertificateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetCertificateResp, error)

	// ListCloudSnapshotBackupsWithResponse request
	ListCloudSnapshotBackupsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListCloudSnapshotBackupsParams, reqEditors ...RequestEditorFn) (*ListCloudSnapshotBackupsResp, error)

	// CreateCloudSnapshotBackupWithBodyWithResponse request with any body
	CreateCloudSnapshotBackupWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCloudSnapshotBackupResp, error)

	CreateCloudSnapshotBackupWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateCloudSnapshotBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCloudSnapshotBackupResp, error)

	// ListGeographicRegionsWithResponse request
	ListGeographicRegionsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListGeographicRegionsResp, error)

	// ListCloudSnapshotRestoresWithResponse request
	ListCloudSnapshotRestoresWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListCloudSnapshotRestoresParams, reqEditors ...RequestEditorFn) (*ListCloudSnapshotRestoresResp, error)

	// DeleteCloudSnapshotBackupWithResponse request
	DeleteCloudSnapshotBackupWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*DeleteCloudSnapshotBackupResp, error)

	// EditCloudSnapshotBackupRetentionWithBodyWithResponse request with any body
	EditCloudSnapshotBackupRetentionWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCloudSnapshotBackupRetentionResp, error)

	EditCloudSnapshotBackupRetentionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body EditCloudSnapshotBackupRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCloudSnapshotBackupRetentionResp, error)

	// RestoreWithBodyWithResponse request with any body
	RestoreWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreResp, error)

	RestoreWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body RestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreResp, error)

	// DeleteCloudSnapshotBackupScheduleWithResponse request
	DeleteCloudSnapshotBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*DeleteCloudSnapshotBackupScheduleResp, error)

	// GetCloudSnapshotBackupScheduleWithResponse request
	GetCloudSnapshotBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetCloudSnapshotBackupScheduleResp, error)

	// UpsertCloudSnapshotBackupScheduleWithBodyWithResponse request with any body
	UpsertCloudSnapshotBackupScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertCloudSnapshotBackupScheduleResp, error)

	UpsertCloudSnapshotBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpsertCloudSnapshotBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertCloudSnapshotBackupScheduleResp, error)

	// AssociateCMEKWithResponse request
	AssociateCMEKWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*AssociateCMEKResp, error)

	// UnassociateCMEKWithResponse request
	UnassociateCMEKWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*UnassociateCMEKResp, error)

	// GetDataAPIStatusWithResponse request
	GetDataAPIStatusWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetDataAPIStatusResp, error)

	// UpdateDataApiAndPeeringWithBodyWithResponse request with any body
	UpdateDataApiAndPeeringWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDataApiAndPeeringResp, error)

	UpdateDataApiAndPeeringWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpdateDataApiAndPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDataApiAndPeeringResp, error)

	// GetDataAPIPrivateEndpointCommandWithBodyWithResponse request with any body
	GetDataAPIPrivateEndpointCommandWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetDataAPIPrivateEndpointCommandResp, error)

	GetDataAPIPrivateEndpointCommandWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetDataAPIPrivateEndpointCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*GetDataAPIPrivateEndpointCommandResp, error)

	// ListDataAPIPrivateEndpointsWithResponse request
	ListDataAPIPrivateEndpointsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListDataAPIPrivateEndpointsResp, error)

	// AssociateDataAPIPrivateEndpointRequestWithResponse request
	AssociateDataAPIPrivateEndpointRequestWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*AssociateDataAPIPrivateEndpointRequestResp, error)

	// DisassociateDataAPIPrivateEndpointWithResponse request
	DisassociateDataAPIPrivateEndpointWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*DisassociateDataAPIPrivateEndpointResp, error)

	// ListMtlsCertificatesWithResponse request
	ListMtlsCertificatesWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListMtlsCertificatesParams, reqEditors ...RequestEditorFn) (*ListMtlsCertificatesResp, error)

	// AddMtlsCertificateWithBodyWithResponse request with any body
	AddMtlsCertificateWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMtlsCertificateResp, error)

	AddMtlsCertificateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body AddMtlsCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMtlsCertificateResp, error)

	// DeleteMtlsCertificateWithResponse request
	DeleteMtlsCertificateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, reqEditors ...RequestEditorFn) (*DeleteMtlsCertificateResp, error)

	// GetMtlsCertificateWithResponse request
	GetMtlsCertificateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, reqEditors ...RequestEditorFn) (*GetMtlsCertificateResp, error)

	// PutMtlsCertificateWithBodyWithResponse request with any body
	PutMtlsCertificateWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutMtlsCertificateResp, error)

	PutMtlsCertificateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, body PutMtlsCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*PutMtlsCertificateResp, error)

	// GetMtlsConfigurationWithResponse request
	GetMtlsConfigurationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetMtlsConfigurationResp, error)

	// UpdateMtlsConfigurationWithBodyWithResponse request with any body
	UpdateMtlsConfigurationWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMtlsConfigurationResp, error)

	UpdateMtlsConfigurationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpdateMtlsConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMtlsConfigurationResp, error)

	// ListNetworkPeeringRecordsWithResponse request
	ListNetworkPeeringRecordsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListNetworkPeeringRecordsParams, reqEditors ...RequestEditorFn) (*ListNetworkPeeringRecordsResp, error)

	// PostNetworkPeeringWithBodyWithResponse request with any body
	PostNetworkPeeringWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNetworkPeeringResp, error)

	PostNetworkPeeringWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostNetworkPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNetworkPeeringResp, error)

	// GetAzureVnetPeeringCommandWithBodyWithResponse request with any body
	GetAzureVnetPeeringCommandWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetAzureVnetPeeringCommandResp, error)

	GetAzureVnetPeeringCommandWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetAzureVnetPeeringCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*GetAzureVnetPeeringCommandResp, error)

	// DeleteNetworkPeeringWithResponse request
	DeleteNetworkPeeringWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, peerId PeerId, reqEditors ...RequestEditorFn) (*DeleteNetworkPeeringResp, error)

	// GetNetworkPeeringRecordWithResponse request
	GetNetworkPeeringRecordWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, peerId PeerId, reqEditors ...RequestEditorFn) (*GetNetworkPeeringRecordResp, error)

	// DeleteOnOffScheduleWithResponse request
	DeleteOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*DeleteOnOffScheduleResp, error)

	// GetOnOffScheduleWithResponse request
	GetOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetOnOffScheduleResp, error)

	// PostOnOffScheduleWithBodyWithResponse request with any body
	PostOnOffScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOnOffScheduleResp, error)

	PostOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOnOffScheduleResp, error)

	// PutOnOffScheduleWithBodyWithResponse request with any body
	PutOnOffScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutOnOffScheduleResp, error)

	PutOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PutOnOffScheduleResp, error)

	// DisablePrivateEndpointServiceWithResponse request
	DisablePrivateEndpointServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*DisablePrivateEndpointServiceResp, error)

	// GetPrivateEndpointServiceStatusWithResponse request
	GetPrivateEndpointServiceStatusWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetPrivateEndpointServiceStatusResp, error)

	// EnablePrivateEndpointServiceWithResponse request
	EnablePrivateEndpointServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*EnablePrivateEndpointServiceResp, error)

	// GetPrivateEndpointCommandWithBodyWithResponse request with any body
	GetPrivateEndpointCommandWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPrivateEndpointCommandResp, error)

	GetPrivateEndpointCommandWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetPrivateEndpointCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPrivateEndpointCommandResp, error)

	// ListPrivateEndpointsWithResponse request
	ListPrivateEndpointsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListPrivateEndpointsResp, error)

	// AcceptPrivateEndpointWithResponse request
	AcceptPrivateEndpointWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*AcceptPrivateEndpointResp, error)

	// DeletePrivateEndpointWithResponse request
	DeletePrivateEndpointWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*DeletePrivateEndpointResp, error)

	// IndexBuildStatusWithResponse request
	IndexBuildStatusWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, indexName IndexName, params *IndexBuildStatusParams, reqEditors ...RequestEditorFn) (*IndexBuildStatusResp, error)

	// ListIndexDefinitionsWithResponse request
	ListIndexDefinitionsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListIndexDefinitionsParams, reqEditors ...RequestEditorFn) (*ListIndexDefinitionsResp, error)

	// ManageQueryIndexesWithBodyWithResponse request with any body
	ManageQueryIndexesWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManageQueryIndexesResp, error)

	ManageQueryIndexesWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body ManageQueryIndexesJSONRequestBody, reqEditors ...RequestEditorFn) (*ManageQueryIndexesResp, error)

	// IndexDefinitionWithResponse request
	IndexDefinitionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, indexName IndexName, params *IndexDefinitionParams, reqEditors ...RequestEditorFn) (*IndexDefinitionResp, error)

	// ListClusterReplicationsWithResponse request
	ListClusterReplicationsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListClusterReplicationsParams, reqEditors ...RequestEditorFn) (*ListClusterReplicationsResp, error)

	// CreateReplicationWithBodyWithResponse request with any body
	CreateReplicationWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReplicationResp, error)

	CreateReplicationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateReplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReplicationResp, error)

	// DeleteReplicationWithResponse request
	DeleteReplicationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*DeleteReplicationResp, error)

	// GetReplicationWithResponse request
	GetReplicationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*GetReplicationResp, error)

	// UpdateReplicationWithBodyWithResponse request with any body
	UpdateReplicationWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateReplicationResp, error)

	UpdateReplicationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, body UpdateReplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateReplicationResp, error)

	// PauseReplicationWithResponse request
	PauseReplicationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*PauseReplicationResp, error)

	// ResumeReplicationWithResponse request
	ResumeReplicationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*ResumeReplicationResp, error)

	// ListSampleBucketsWithResponse request
	ListSampleBucketsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListSampleBucketsResp, error)

	// PostSampleBucketWithBodyWithResponse request with any body
	PostSampleBucketWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSampleBucketResp, error)

	PostSampleBucketWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostSampleBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSampleBucketResp, error)

	// DeleteSampleDataByBucketIDWithResponse request
	DeleteSampleDataByBucketIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*DeleteSampleDataByBucketIDResp, error)

	// GetSampleBucketByIdWithResponse request
	GetSampleBucketByIdWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*GetSampleBucketByIdResp, error)

	// ListDatabaseCredentialsWithResponse request
	ListDatabaseCredentialsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListDatabaseCredentialsParams, reqEditors ...RequestEditorFn) (*ListDatabaseCredentialsResp, error)

	// PostDatabaseCredentialWithBodyWithResponse request with any body
	PostDatabaseCredentialWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDatabaseCredentialResp, error)

	PostDatabaseCredentialWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostDatabaseCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDatabaseCredentialResp, error)

	// DeleteDatabaseCredentialWithResponse request
	DeleteDatabaseCredentialWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, reqEditors ...RequestEditorFn) (*DeleteDatabaseCredentialResp, error)

	// GetDatabaseCredentialWithResponse request
	GetDatabaseCredentialWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, reqEditors ...RequestEditorFn) (*GetDatabaseCredentialResp, error)

	// PutDatabaseCredentialWithBodyWithResponse request with any body
	PutDatabaseCredentialWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, params *PutDatabaseCredentialParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutDatabaseCredentialResp, error)

	PutDatabaseCredentialWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, params *PutDatabaseCredentialParams, body PutDatabaseCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*PutDatabaseCredentialResp, error)

	// ListProjectEventsWithResponse request
	ListProjectEventsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectEventsParams, reqEditors ...RequestEditorFn) (*ListProjectEventsResp, error)

	// GetProjectEventByIDWithResponse request
	GetProjectEventByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, eventId EventId, reqEditors ...RequestEditorFn) (*GetProjectEventByIDResp, error)

	// ListProjectReplicationsWithResponse request
	ListProjectReplicationsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectReplicationsParams, reqEditors ...RequestEditorFn) (*ListProjectReplicationsResp, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, organizationId OrganizationId, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResp, error)

	// PostUserWithBodyWithResponse request with any body
	PostUserWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserResp, error)

	PostUserWithResponse(ctx context.Context, organizationId OrganizationId, body PostUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUserResp, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, organizationId OrganizationId, userId CPUserId, reqEditors ...RequestEditorFn) (*DeleteUserResp, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, organizationId OrganizationId, userId CPUserId, reqEditors ...RequestEditorFn) (*GetUserResp, error)

	// PatchUserWithBodyWithResponse request with any body
	PatchUserWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, userId CPUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserResp, error)

	PatchUserWithResponse(ctx context.Context, organizationId OrganizationId, userId CPUserId, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserResp, error)
}

type ListOrganizationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrganizationsResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListOrganizationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrganizationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrganizationResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOrganizationByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModelsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetLanguageModelsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListModelsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModelsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateModelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateLanguageModelResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateModelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateModelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DestroyModelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DestroyModelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DestroyModelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetLanguageModelResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetModelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModelAPIKeysResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListLanguageModelAPIKeysResponse
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON422      *UnprocessableContent
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListModelAPIKeysResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModelAPIKeysResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateModelAPIKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateLanguageModelAPIKeyResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON422      *UnprocessableContent
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateModelAPIKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateModelAPIKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteModelAPIKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteModelAPIKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModelAPIKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModelAPIKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetLanguageModelAPIKeyResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetModelAPIKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModelAPIKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectionStringResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetConnectionStringResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetConnectionStringResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectionStringResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProvidersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListProvidersResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProvidersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProvidersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProviderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateProviderResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProviderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProviderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProviderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProviderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProviderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProviderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetProviderResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProviderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProviderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProviderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProviderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProviderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOrganizationLevelAnalyticsClustersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetColumnarAnalyticsClustersResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListOrganizationLevelAnalyticsClustersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrganizationLevelAnalyticsClustersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOrganizationAPIKeysResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAPIKeys
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListOrganizationAPIKeysResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrganizationAPIKeysResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrganizationAPIKeysResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateAPIKeyResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostOrganizationAPIKeysResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrganizationAPIKeysResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationAPIKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationAPIKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationAPIKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationAPIKeyByAccessKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAPIKey
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOrganizationAPIKeyByAccessKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationAPIKeyByAccessKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrganizationAPIKeyRotateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RotateAPIKeyResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostOrganizationAPIKeyRotateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrganizationAPIKeyRotateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppServicesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAppServicesResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAppServicesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppServicesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCloudAccountsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloudAccounts
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCloudAccountsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCloudAccountsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeyMetadataListResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCMEKMetadataListResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKeyMetadataListResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeyMetadataListResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCMEKMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateCMEKMetadataResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostCMEKMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCMEKMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeyMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteKeyMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeyMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeyMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCMEKMetadata
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKeyMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeyMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RotateCMEKKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RotateCMEKKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RotateCMEKKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCMEKHistoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCMEKHistoryMetadataListResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListCMEKHistoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCMEKHistoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutOrganizationConfigurationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutOrganizationConfigurationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutOrganizationConfigurationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEventsResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListEventsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEventResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEventByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetProjectsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateProjectResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostProjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetProjectResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProjectByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutProjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutProjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutProjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTestAlertIntegrationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostTestAlertIntegrationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTestAlertIntegrationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAlertIntegrationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAlertsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAlertIntegrationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAlertIntegrationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAlertIntegrationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateAlertResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostAlertIntegrationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAlertIntegrationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAlertIntegrationByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAlertIntegrationByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAlertIntegrationByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlertIntegrationByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAlertResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAlertIntegrationByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlertIntegrationByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAlertIntegrationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutAlertIntegrationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAlertIntegrationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectLevelAnalyticsClustersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetColumnarAnalyticsClustersResponse
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectLevelAnalyticsClustersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectLevelAnalyticsClustersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAnalyticsClusterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateColumnarAnalyticsClusterResponse
	JSON401      *Unauthorized
	JSON402      *Error
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateAnalyticsClusterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAnalyticsClusterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAnalyticsClusterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAnalyticsClusterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAnalyticsClusterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnalyticsClusterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetColumnarAnalyticsClusterResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAnalyticsClusterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnalyticsClusterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAnalyticsClusterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutAnalyticsClusterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAnalyticsClusterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnalyticsClusterOffResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AnalyticsClusterOffResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnalyticsClusterOffResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnalyticsClusterOnResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AnalyticsClusterOnResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnalyticsClusterOnResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAnalyticsAllowedCidrsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAllowedCidrsResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAnalyticsAllowedCidrsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAnalyticsAllowedCidrsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAnalyticsAllowedCidrResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateAllowedCidrResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostAnalyticsAllowedCidrResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAnalyticsAllowedCidrResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteColumnarAllowedCidrByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteColumnarAllowedCidrByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteColumnarAllowedCidrByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetColumnarAllowedCidrByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllowedCidr
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetColumnarAllowedCidrByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetColumnarAllowedCidrByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteColumnarAnalyticsBackupScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteColumnarAnalyticsBackupScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteColumnarAnalyticsBackupScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetColumnarAnalyticsBackupScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetColumnarAnalyticsBackupScheduleResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetColumnarAnalyticsBackupScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetColumnarAnalyticsBackupScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertColumnarAnalyticsBackupScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpsertColumnarAnalyticsBackupScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertColumnarAnalyticsBackupScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListColumnarAnalyticsBackupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListColumnarAnalyticsBackupsResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListColumnarAnalyticsBackupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListColumnarAnalyticsBackupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateColumnarAnalyticsBackupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateColumnarAnalyticsBackupResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateColumnarAnalyticsBackupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateColumnarAnalyticsBackupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListColumnarAnalyticsRestoresResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListColumnarAnalyticsRestoresResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListColumnarAnalyticsRestoresResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListColumnarAnalyticsRestoresResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteColumnarAnalyticsBackupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteColumnarAnalyticsBackupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteColumnarAnalyticsBackupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateColumnarAnalyticsBackupRetentionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateColumnarAnalyticsBackupRetentionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateColumnarAnalyticsBackupRetentionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreColumnarAnalyticsClusterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateColumnarAnalyticsRestoreResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RestoreColumnarAnalyticsClusterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreColumnarAnalyticsClusterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAnalyticsOnOffScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAnalyticsOnOffScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAnalyticsOnOffScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnalyticsOnOffScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ColumnarAnalyticsOnOffSchedule
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAnalyticsOnOffScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnalyticsOnOffScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAnalyticsOnOffScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostAnalyticsOnOffScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAnalyticsOnOffScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAnalyticsOnOffScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutAnalyticsOnOffScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAnalyticsOnOffScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableColumnarPrivateEndpointServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DisableColumnarPrivateEndpointServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableColumnarPrivateEndpointServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetColumnarPrivateEndpointServiceStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPrivateEndpointServiceResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetColumnarPrivateEndpointServiceStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetColumnarPrivateEndpointServiceStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableColumnarPrivateEndpointServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EnableColumnarPrivateEndpointServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableColumnarPrivateEndpointServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetColumnarPrivateEndpointServiceCommandResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePrivateEndpointServiceCommandResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetColumnarPrivateEndpointServiceCommandResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetColumnarPrivateEndpointServiceCommandResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListColumnarPrivateEndpointServiceConnectionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPrivateEndpointServiceConnectionsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListColumnarPrivateEndpointServiceConnectionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListColumnarPrivateEndpointServiceConnectionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptColumnarPrivateEndpointServiceConnectionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AcceptColumnarPrivateEndpointServiceConnectionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptColumnarPrivateEndpointServiceConnectionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RejectColumnarPrivateEndpointServiceConnectionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RejectColumnarPrivateEndpointServiceConnectionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RejectColumnarPrivateEndpointServiceConnectionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectLevelCloudSnapshotBackupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListProjectLevelCloudSnapshotResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectLevelCloudSnapshotBackupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectLevelCloudSnapshotBackupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloneResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateCloudSnapshotCloneResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CloneResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloneResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClustersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetClustersResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClustersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClustersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClusterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateClusterResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostClusterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClusterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFreeTierClusterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateClusterResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *Error
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateFreeTierClusterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFreeTierClusterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFreeTierClusterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteFreeTierClusterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFreeTierClusterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFreeTierClusterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AppServiceId The ID of the linked App Service.
		AppServiceId *openapi_types.UUID `json:"appServiceId,omitempty"`
		Audit        CouchbaseAuditData  `json:"audit"`
		Availability Availability        `json:"availability"`

		// CloudProvider The cloud provider where the cluster will be hosted.
		// For information about providers and supported regions, see:
		//
		// - [Amazon Web Services](https://docs.couchbase.com/cloud/reference/aws.html)
		//
		// - [Google Cloud Platform](https://docs.couchbase.com/cloud/reference/gcp.html)
		//
		// - [Microsoft Azure](https://docs.couchbase.com/cloud/reference/azure.html)
		CloudProvider CloudProvider `json:"cloudProvider"`

		// CmekId The ID of the CMEK Key.
		CmekId *string `json:"cmekId,omitempty"`

		// ConfigurationType - Multi-node databases are best for deployments that require high availability. If your app requires high performance and high availability, choose the Multi-node option.
		// - Single-node databases have resource limitations that make them a good choice for learning, prototyping, and non-production uses. They have limited availability.
		// - Single-node databases should contain only 1 node and 1 Service Group. Adding number of nodes or service groups > 1 is not allowed for such databases.
		// - By default the configurationType is multiNode.
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		ConfigurationType ConfigurationType `json:"configurationType"`

		// ConnectionString ConnectionString specifies the Capella database endpoint for your client connection.
		ConnectionString string          `json:"connectionString"`
		CouchbaseServer  CouchbaseServer `json:"couchbaseServer"`
		CurrentState     CurrentState    `json:"currentState"`

		// Description Description of the cluster (up to 1024 characters).
		Description                string `json:"description"`
		EnablePrivateDNSResolution *bool  `json:"enablePrivateDNSResolution,omitempty"`

		// Id The ID of the cluster created.
		Id openapi_types.UUID `json:"id"`

		// Name Name of the cluster (up to 256 characters).
		Name          string         `json:"name"`
		ServiceGroups []ServiceGroup `json:"serviceGroups"`
		Support       struct {
			Plan GetFreeTierCluster200SupportPlan `json:"plan"`

			// Timezone The standard timezone for the cluster. Should be the TZ identifier.
			Timezone SupportTimezone `json:"timezone"`
		} `json:"support"`
	}
	JSON403 *AccessForbidden
	JSON404 *ResourceNotFound
	JSON422 *UnprocessableContent
	JSON429 *RateLimitExceeded
	JSON500 *InternalServerError
}
type GetFreeTierCluster200SupportPlan string

// Status returns HTTPResponse.Status
func (r GetFreeTierClusterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFreeTierClusterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFreeTierClusterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateFreeTierClusterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFreeTierClusterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FreeTierClusterOffResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r FreeTierClusterOffResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FreeTierClusterOffResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FreeTierClusterOnResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r FreeTierClusterOnResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FreeTierClusterOnResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetClusterResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClusterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutClusterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutClusterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutClusterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClusterOffResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ClusterOffResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClusterOffResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClusterOnResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ClusterOnResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClusterOnResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAiWorkflowsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListWorkflowsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAiWorkflowsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAiWorkflowsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAiWorkflowResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateWorkflowResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateAiWorkflowResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAiWorkflowResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAiWorkflowResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAiWorkflowResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAiWorkflowResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAiWorkflowResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetWorkflowResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAiWorkflowResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAiWorkflowResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopAiWorkflowRunResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StopAiWorkflowRunResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopAiWorkflowRunResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAiWorkflowRunsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetWorkflowRunsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAiWorkflowRunsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAiWorkflowRunsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAiWorkflowRunResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateWorkflowRunResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateAiWorkflowRunResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAiWorkflowRunResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAiWorkflowRunResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetWorkflowRunResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAiWorkflowRunResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAiWorkflowRunResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAiWorkflowRunProcessedFilesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetWorkflowRunProcessedFilesResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAiWorkflowRunProcessedFilesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAiWorkflowRunProcessedFilesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllowedCidrsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAllowedCidrsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAllowedCidrsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllowedCidrsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAllowedCidrsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateAllowedCidrResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostAllowedCidrsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAllowedCidrsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAllowedCidrByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAllowedCidrByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAllowedCidrByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllowedCidrByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllowedCidr
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllowedCidrByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllowedCidrByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAppServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateAppServicesResponse
	JSON403      *AccessForbidden
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostAppServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAppServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFreeTierAppServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateAppServicesResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateFreeTierAppServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFreeTierAppServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFreeTierAppServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteFreeTierAppServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFreeTierAppServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFreeTierAppServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Audit CouchbaseAuditData `json:"audit"`

		// CloudProvider Provider is the cloud service provider for the App Service.
		CloudProvider string `json:"cloudProvider"`

		// ClusterId The ID of the cluster linked to the App Service.
		ClusterId openapi_types.UUID `json:"clusterId"`

		// Compute The CPU and RAM configuration of the App Service. The supported combinations are:
		// | CPU (cores)| RAM  (GB)   |
		// | --------   |   -------   |
		// | 2          | 4           |
		// | 4          | 8           |
		// | 8          | 16          |
		// | 16         | 32          |
		// | 36         | 72          |
		Compute      AppServiceCompute `json:"compute"`
		CurrentState AppServiceStates  `json:"currentState"`

		// Description Description of the App Service (up to 1024 characters).
		Description string `json:"description"`

		// Id The ID of the App Service created.
		Id openapi_types.UUID `json:"id"`

		// Name Name of the App Service (up to 256 characters).
		Name string `json:"name"`

		// Nodes Number of nodes configured for the App Service.
		Nodes int                          `json:"nodes"`
		Plan  GetFreeTierAppService200Plan `json:"plan"`

		// Version The version of the App Service server. If left empty, it will be defaulted to the latest available version.
		Version string `json:"version"`
	}
	JSON403 *AccessForbidden
	JSON404 *ResourceNotFound
	JSON422 *UnprocessableContent
	JSON429 *RateLimitExceeded
	JSON500 *InternalServerError
}
type GetFreeTierAppService200Plan string

// Status returns HTTPResponse.Status
func (r GetFreeTierAppServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFreeTierAppServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFreeTierAppServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateFreeTierAppServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFreeTierAppServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAppServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAppServiceResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAppServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAppServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutAppServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAppServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppServiceOffResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AppServiceOffResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppServiceOffResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppServiceOnResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AppServiceOnResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppServiceOnResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppServiceAdminUsersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAdminUsersResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ListAppServiceAdminUsersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppServiceAdminUsersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddAppServiceAdminUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateAppServiceAdminUserResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddAppServiceAdminUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddAppServiceAdminUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppServiceAdminUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAppServiceAdminUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppServiceAdminUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppServiceAdminUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppServiceAdminUser
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetAppServiceAdminUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppServiceAdminUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppServiceAdminUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateAppServiceAdminUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppServiceAdminUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppServiceAllowedCidrsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAppServiceAllowedCidrsResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAppServiceAllowedCidrsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppServiceAllowedCidrsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAppServiceAllowedCidrResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateAllowedCidrResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostAppServiceAllowedCidrResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAppServiceAllowedCidrResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppServiceAllowedCidrResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAppServiceAllowedCidrResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppServiceAllowedCidrResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppEndpointsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAppEndpointsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ListAppEndpointsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppEndpointsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAppEndpointResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PostAppEndpointResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAppEndpointResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAccessFunctionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteAccessFunctionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccessFunctionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessFunctionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetAccessFunctionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessFunctionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAccessFunctionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PutAccessFunctionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAccessFunctionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImportFilterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteImportFilterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImportFilterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImportFilterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetImportFilterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImportFilterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutImportFilterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PutImportFilterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutImportFilterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppEndpointResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteAppEndpointResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppEndpointResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppEndpointResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAppEndpointResponse
	JSON400      *BadRequest
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetAppEndpointResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppEndpointResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAppEndpointResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PutAppEndpointResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAppEndpointResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppEndpointActivationStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON412      *PreconditionFailed
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteAppEndpointActivationStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppEndpointActivationStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAppEndpointActivationStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON412      *PreconditionFailed
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PostAppEndpointActivationStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAppEndpointActivationStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppEndpointAdminUsersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAdminUsersResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ListAppEndpointAdminUsersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppEndpointAdminUsersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppEndpointAuditLogConfigResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAppEndpointAuditLogResponse
	JSON400      *BadRequest
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetAppEndpointAuditLogConfigResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppEndpointAuditLogConfigResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAppEndpointAuditLogConfigResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PutAppEndpointAuditLogConfigResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAppEndpointAuditLogConfigResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppServiceAuditLogEventsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditLogEventsResponse
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r GetAppServiceAuditLogEventsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppServiceAuditLogEventsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppEndpointCollectionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScopesConfig
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ListAppEndpointCollectionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppEndpointCollectionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppEndpointCORSResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CORSConfig
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetAppEndpointCORSResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppEndpointCORSResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAppEndpointCORSResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r PutAppEndpointCORSResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAppEndpointCORSResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppEndpointOIDCProvidersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListOIDCProvidersResponse
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r ListAppEndpointOIDCProvidersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppEndpointOIDCProvidersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppEndpointOIDCProviderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OIDCProviderID
	JSON400      *BadRequest
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r CreateAppEndpointOIDCProviderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppEndpointOIDCProviderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppEndpointOIDCDefaultProviderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r UpdateAppEndpointOIDCDefaultProviderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppEndpointOIDCDefaultProviderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppEndpointOIDCProviderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r DeleteAppEndpointOIDCProviderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppEndpointOIDCProviderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppEndpointOIDCProviderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OIDCProvider
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetAppEndpointOIDCProviderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppEndpointOIDCProviderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppEndpointOIDCProviderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r UpdateAppEndpointOIDCProviderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppEndpointOIDCProviderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppEndpointResyncResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r DeleteAppEndpointResyncResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppEndpointResyncResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppEndpointResyncResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResyncStatus
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetAppEndpointResyncResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppEndpointResyncResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAppEndpointResyncResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AppEndpointAccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON503      *ServiceUnavailable
	JSON504      *GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r PostAppEndpointResyncResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAppEndpointResyncResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppServiceAuditLogStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateAppServiceAuditLogRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAppServiceAuditLogStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppServiceAuditLogStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAppServiceAuditLogStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutAppServiceAuditLogStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAppServiceAuditLogStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppServiceAuditLogExportsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAuditExportDocs
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAppServiceAuditLogExportsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppServiceAuditLogExportsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAppServiceAuditLogExportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateClusterAuditLogExportResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostAppServiceAuditLogExportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAppServiceAuditLogExportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppServiceAuditLogExportByIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAuditExportDocResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAppServiceAuditLogExportByIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppServiceAuditLogExportByIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppServiceAuditLogStreamingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAuditLogStreamingResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAppServiceAuditLogStreamingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppServiceAuditLogStreamingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAppServiceAuditLogStreamingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PatchAppServiceAuditLogStreamingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAppServiceAuditLogStreamingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAppServiceAuditLogStreamingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutAppServiceAuditLogStreamingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAppServiceAuditLogStreamingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppServiceCertificateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCertificateResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAppServiceCertificateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppServiceCertificateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppServicePrivateEndpointsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAppServicePrivateEndpointsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppServicePrivateEndpointsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppServicePrivateEndpointsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAppServicePrivateEndpointStateResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAppServicePrivateEndpointsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppServicePrivateEndpointsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAppServicePrivateEndpointsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostAppServicePrivateEndpointsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAppServicePrivateEndpointsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppServicePrivateEndpointsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPrivateEndpointsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAppServicePrivateEndpointsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppServicePrivateEndpointsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePrivateEndpointRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeletePrivateEndpointRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePrivateEndpointRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptPrivateEndpointRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AcceptPrivateEndpointRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptPrivateEndpointRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppServicePrivateEndpointsCommandResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePrivateEndpointCommandResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAppServicePrivateEndpointsCommandResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppServicePrivateEndpointsCommandResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterAuditSettingsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetClusterAuditSettingsResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClusterAuditSettingsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterAuditSettingsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutClusterAuditSettingsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutClusterAuditSettingsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutClusterAuditSettingsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuditLogEventIDsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAuditLogEventsResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAuditLogEventIDsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuditLogEventIDsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuditLogExportsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetClusterAuditLogExportsResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAuditLogExportsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuditLogExportsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuditLogExportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateClusterAuditLogExportResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *Error
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostAuditLogExportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuditLogExportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuditLogExportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetClusterAuditLogExportResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAuditLogExportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuditLogExportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClusterBackupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBackupsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClusterBackupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClusterBackupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBackupCycleByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteBackupCycleByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBackupCycleByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBackupByIDResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetBackupByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRestoreResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostRestoreResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRestoreResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutBucketStorageBackendResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutBucketStorageBackendResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutBucketStorageBackendResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBucketsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBucketsResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListBucketsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBucketsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBucketResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateBucketResponse
	JSON403      *AccessForbidden
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostBucketResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBucketResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFreeTierBucketsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBucketsResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListFreeTierBucketsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFreeTierBucketsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFreeTierBucketResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateBucketResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateFreeTierBucketResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFreeTierBucketResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFreeTierBucketByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteFreeTierBucketByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFreeTierBucketByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFreeTierBucketByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBucketResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetFreeTierBucketByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFreeTierBucketByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFreeTierBucketResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateFreeTierBucketResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFreeTierBucketResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBucketByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteBucketByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBucketByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBucketByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBucketResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetBucketByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBucketByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutBucketResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutBucketResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutBucketResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCyclesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCyclesResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListCyclesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCyclesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBackupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBackupsResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListBackupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBackupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBackupScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteBackupScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBackupScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetScheduledBackupResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetBackupScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBackupScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostBackupScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBackupScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutBackupScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutBackupScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutBackupScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBackupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostBackupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBackupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FlushBucketResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r FlushBucketResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FlushBucketResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScopesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetScopesResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetScopesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScopesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostScopeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostScopeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostScopeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScopeByNameResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteScopeByNameResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScopeByNameResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScopeByNameResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetScopeResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetScopeByNameResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScopeByNameResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCollectionsResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCollectionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCollectionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostCollectionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCollectionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCollectionByNameResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteCollectionByNameResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCollectionByNameResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionByNameResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCollectionResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCollectionByNameResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionByNameResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutCollectionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutCollectionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutCollectionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertificateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCertificateResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCertificateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertificateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCloudSnapshotBackupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCloudSnapshotBackupsResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListCloudSnapshotBackupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCloudSnapshotBackupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCloudSnapshotBackupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateCloudSnapshotBackupResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateCloudSnapshotBackupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCloudSnapshotBackupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGeographicRegionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloudSnapshotGeographicRegions
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r ListGeographicRegionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGeographicRegionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCloudSnapshotRestoresResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCloudSnapshotRestoresResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListCloudSnapshotRestoresResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCloudSnapshotRestoresResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCloudSnapshotBackupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *map[string]interface{}
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteCloudSnapshotBackupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCloudSnapshotBackupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditCloudSnapshotBackupRetentionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EditCloudSnapshotBackupRetentionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditCloudSnapshotBackupRetentionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateCloudSnapshotRestoreResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RestoreResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCloudSnapshotBackupScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteCloudSnapshotBackupScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCloudSnapshotBackupScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCloudSnapshotBackupScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCloudSnapshotBackupScheduleResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCloudSnapshotBackupScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCloudSnapshotBackupScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertCloudSnapshotBackupScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UpsertCloudSnapshotBackupScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertCloudSnapshotBackupScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssociateCMEKResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AssociateCMEKResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssociateCMEKResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassociateCMEKResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UnassociateCMEKResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassociateCMEKResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataAPIStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Enabled Indicates whether Data API is enabled or disabled on the cluster.
		Enabled bool `json:"enabled"`

		// EnabledForNetworkPeering Whether network peering was enabled or disabled for the Data API.
		EnabledForNetworkPeering bool `json:"enabledForNetworkPeering"`

		// State Current status of the Data API.  Here are the possible values:
		//
		//   - `enabled`: Data API is active and fully functional
		//   - `enabling`: Data API is in the process of being enabled
		//   - `disabled`: Data API is not enabled with no infrastructure being deployed for it at the moment
		//   - `disabling`: Data API is in the process of being disabled
		//   - `configuring`: Data API is in the process of being configured, thus here should not be any downtime for existing clients,
		//                    but new functionality like network peering will not be available until status is enabled
		State GetDataAPIStatus200State `json:"state"`

		// StateForNetworkPeering Current status for vpc peering for Data API.  Here are the possible values:
		//
		//   - `enabled`: network peering it is currently enabled
		//   - `enabling`: network peering is in the process of being enabled
		//   - `disabled`: network peering it is not enabled with no infrastructure being deployed for it at the moment
		//   - `disabling`: network peering is in the process of being disabled
		StateForNetworkPeering GetDataAPIStatus200StateForNetworkPeering `json:"stateForNetworkPeering"`
	}
	JSON400 *BadRequest
	JSON403 *AccessForbidden
	JSON404 *ResourceNotFound
	JSON422 *UnprocessableContent
	JSON429 *RateLimitExceeded
	JSON500 *InternalServerError
}
type GetDataAPIStatus200State string
type GetDataAPIStatus200StateForNetworkPeering string

// Status returns HTTPResponse.Status
func (r GetDataAPIStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataAPIStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDataApiAndPeeringResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateDataApiAndPeeringResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDataApiAndPeeringResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataAPIPrivateEndpointCommandResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePrivateEndpointCommandResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDataAPIPrivateEndpointCommandResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataAPIPrivateEndpointCommandResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDataAPIPrivateEndpointsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPrivateEndpointsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListDataAPIPrivateEndpointsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDataAPIPrivateEndpointsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssociateDataAPIPrivateEndpointRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AssociateDataAPIPrivateEndpointRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssociateDataAPIPrivateEndpointRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisassociateDataAPIPrivateEndpointResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DisassociateDataAPIPrivateEndpointResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisassociateDataAPIPrivateEndpointResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMtlsCertificatesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MtlsCertificates
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListMtlsCertificatesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMtlsCertificatesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMtlsCertificateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddMtlsCertificateResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddMtlsCertificateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMtlsCertificateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMtlsCertificateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteMtlsCertificateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMtlsCertificateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMtlsCertificateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MtlsCertificate
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMtlsCertificateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMtlsCertificateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutMtlsCertificateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutMtlsCertificateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutMtlsCertificateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMtlsConfigurationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetMtlsConfigurationResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMtlsConfigurationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMtlsConfigurationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMtlsConfigurationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateMtlsConfigurationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMtlsConfigurationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNetworkPeeringRecordsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListNetworkPeeringRecordsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListNetworkPeeringRecordsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNetworkPeeringRecordsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNetworkPeeringResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateNetworkPeeringResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostNetworkPeeringResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNetworkPeeringResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAzureVnetPeeringCommandResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAzureVNetPeeringCommandResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAzureVnetPeeringCommandResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAzureVnetPeeringCommandResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNetworkPeeringResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteNetworkPeeringResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNetworkPeeringResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkPeeringRecordResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetNetworkPeeringRecordResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetNetworkPeeringRecordResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkPeeringRecordResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOnOffScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteOnOffScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOnOffScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOnOffScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterOnOffSchedule
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOnOffScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOnOffScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOnOffScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostOnOffScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOnOffScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutOnOffScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutOnOffScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutOnOffScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisablePrivateEndpointServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DisablePrivateEndpointServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisablePrivateEndpointServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPrivateEndpointServiceStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPrivateEndpointServiceStatusResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPrivateEndpointServiceStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPrivateEndpointServiceStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnablePrivateEndpointServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON412      *PreconditionFailed
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EnablePrivateEndpointServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnablePrivateEndpointServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPrivateEndpointCommandResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePrivateEndpointCommandResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPrivateEndpointCommandResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPrivateEndpointCommandResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPrivateEndpointsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPrivateEndpointsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListPrivateEndpointsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPrivateEndpointsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptPrivateEndpointResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AcceptPrivateEndpointResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptPrivateEndpointResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePrivateEndpointResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeletePrivateEndpointResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePrivateEndpointResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IndexBuildStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexBuildStatusResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *IndexNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r IndexBuildStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IndexBuildStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIndexDefinitionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIndexDefinitionsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *IndexNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListIndexDefinitionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIndexDefinitionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManageQueryIndexesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexDDLResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *IndexNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ManageQueryIndexesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManageQueryIndexesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IndexDefinitionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexPropertiesResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *IndexNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r IndexDefinitionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IndexDefinitionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClusterReplicationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListClusterReplicationsResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClusterReplicationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClusterReplicationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReplicationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateReplicationJSONResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateReplicationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReplicationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReplicationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteReplicationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReplicationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReplicationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetReplicationResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetReplicationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReplicationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateReplicationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateReplicationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateReplicationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PauseReplicationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PauseReplicationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PauseReplicationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeReplicationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON409      *Conflict
	JSON422      *UnprocessableContent
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ResumeReplicationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeReplicationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSampleBucketsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBucketsResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListSampleBucketsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSampleBucketsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSampleBucketResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PostSampleBucketResponse
	JSON403      *AccessForbidden
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostSampleBucketResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSampleBucketResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSampleDataByBucketIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteSampleDataByBucketIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSampleDataByBucketIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSampleBucketByIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBucketResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSampleBucketByIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSampleBucketByIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDatabaseCredentialsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDatabaseCredentialsResponse
	JSON403      *AccessForbidden
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListDatabaseCredentialsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDatabaseCredentialsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDatabaseCredentialResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateDatabaseCredentialResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostDatabaseCredentialResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDatabaseCredentialResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDatabaseCredentialResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteDatabaseCredentialResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDatabaseCredentialResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseCredentialResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDatabaseCredentialResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDatabaseCredentialResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseCredentialResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutDatabaseCredentialResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutDatabaseCredentialResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutDatabaseCredentialResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectEventsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEventsResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectEventsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectEventsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectEventByIDResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEventResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProjectEventByIDResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectEventByIDResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectReplicationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListProjectReplicationsResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectReplicationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectReplicationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUsersResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListUsersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateUserResponse
	JSON400      *BadRequest
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserResponse
	JSON403      *AccessForbidden
	JSON404      *ResourceNotFound
	JSON422      *UnprocessableContent
	JSON429      *RateLimitExceeded
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PatchUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListOrganizationsWithResponse request returning *ListOrganizationsResp
func (c *ClientWithResponses) ListOrganizationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOrganizationsResp, error) {
	rsp, err := c.ListOrganizations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrganizationsResp(rsp)
}

// GetOrganizationByIDWithResponse request returning *GetOrganizationByIDResp
func (c *ClientWithResponses) GetOrganizationByIDWithResponse(ctx context.Context, organizationId OrganizationId, reqEditors ...RequestEditorFn) (*GetOrganizationByIDResp, error) {
	rsp, err := c.GetOrganizationByID(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationByIDResp(rsp)
}

// ListModelsWithResponse request returning *ListModelsResp
func (c *ClientWithResponses) ListModelsWithResponse(ctx context.Context, organizationId OrganizationId, params *ListModelsParams, reqEditors ...RequestEditorFn) (*ListModelsResp, error) {
	rsp, err := c.ListModels(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModelsResp(rsp)
}

// CreateModelWithBodyWithResponse request with arbitrary body returning *CreateModelResp
func (c *ClientWithResponses) CreateModelWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModelResp, error) {
	rsp, err := c.CreateModelWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModelResp(rsp)
}

func (c *ClientWithResponses) CreateModelWithResponse(ctx context.Context, organizationId OrganizationId, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModelResp, error) {
	rsp, err := c.CreateModel(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModelResp(rsp)
}

// DestroyModelWithResponse request returning *DestroyModelResp
func (c *ClientWithResponses) DestroyModelWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, reqEditors ...RequestEditorFn) (*DestroyModelResp, error) {
	rsp, err := c.DestroyModel(ctx, organizationId, modelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDestroyModelResp(rsp)
}

// GetModelWithResponse request returning *GetModelResp
func (c *ClientWithResponses) GetModelWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, reqEditors ...RequestEditorFn) (*GetModelResp, error) {
	rsp, err := c.GetModel(ctx, organizationId, modelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModelResp(rsp)
}

// ListModelAPIKeysWithResponse request returning *ListModelAPIKeysResp
func (c *ClientWithResponses) ListModelAPIKeysWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, params *ListModelAPIKeysParams, reqEditors ...RequestEditorFn) (*ListModelAPIKeysResp, error) {
	rsp, err := c.ListModelAPIKeys(ctx, organizationId, modelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModelAPIKeysResp(rsp)
}

// CreateModelAPIKeyWithBodyWithResponse request with arbitrary body returning *CreateModelAPIKeyResp
func (c *ClientWithResponses) CreateModelAPIKeyWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModelAPIKeyResp, error) {
	rsp, err := c.CreateModelAPIKeyWithBody(ctx, organizationId, modelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModelAPIKeyResp(rsp)
}

func (c *ClientWithResponses) CreateModelAPIKeyWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, body CreateModelAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModelAPIKeyResp, error) {
	rsp, err := c.CreateModelAPIKey(ctx, organizationId, modelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModelAPIKeyResp(rsp)
}

// DeleteModelAPIKeyWithResponse request returning *DeleteModelAPIKeyResp
func (c *ClientWithResponses) DeleteModelAPIKeyWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, apiKeyId ModelAPIKeyId, reqEditors ...RequestEditorFn) (*DeleteModelAPIKeyResp, error) {
	rsp, err := c.DeleteModelAPIKey(ctx, organizationId, modelId, apiKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModelAPIKeyResp(rsp)
}

// GetModelAPIKeyWithResponse request returning *GetModelAPIKeyResp
func (c *ClientWithResponses) GetModelAPIKeyWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, apiKeyId ModelAPIKeyId, reqEditors ...RequestEditorFn) (*GetModelAPIKeyResp, error) {
	rsp, err := c.GetModelAPIKey(ctx, organizationId, modelId, apiKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModelAPIKeyResp(rsp)
}

// GetConnectionStringWithResponse request returning *GetConnectionStringResp
func (c *ClientWithResponses) GetConnectionStringWithResponse(ctx context.Context, organizationId OrganizationId, modelId ModelId, reqEditors ...RequestEditorFn) (*GetConnectionStringResp, error) {
	rsp, err := c.GetConnectionString(ctx, organizationId, modelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectionStringResp(rsp)
}

// ListProvidersWithResponse request returning *ListProvidersResp
func (c *ClientWithResponses) ListProvidersWithResponse(ctx context.Context, organizationId OrganizationId, params *ListProvidersParams, reqEditors ...RequestEditorFn) (*ListProvidersResp, error) {
	rsp, err := c.ListProviders(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProvidersResp(rsp)
}

// CreateProviderWithBodyWithResponse request with arbitrary body returning *CreateProviderResp
func (c *ClientWithResponses) CreateProviderWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProviderResp, error) {
	rsp, err := c.CreateProviderWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProviderResp(rsp)
}

func (c *ClientWithResponses) CreateProviderWithResponse(ctx context.Context, organizationId OrganizationId, body CreateProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProviderResp, error) {
	rsp, err := c.CreateProvider(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProviderResp(rsp)
}

// DeleteProviderWithResponse request returning *DeleteProviderResp
func (c *ClientWithResponses) DeleteProviderWithResponse(ctx context.Context, organizationId OrganizationId, providerId ProviderId, reqEditors ...RequestEditorFn) (*DeleteProviderResp, error) {
	rsp, err := c.DeleteProvider(ctx, organizationId, providerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProviderResp(rsp)
}

// GetProviderWithResponse request returning *GetProviderResp
func (c *ClientWithResponses) GetProviderWithResponse(ctx context.Context, organizationId OrganizationId, providerId ProviderId, reqEditors ...RequestEditorFn) (*GetProviderResp, error) {
	rsp, err := c.GetProvider(ctx, organizationId, providerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProviderResp(rsp)
}

// UpdateProviderWithBodyWithResponse request with arbitrary body returning *UpdateProviderResp
func (c *ClientWithResponses) UpdateProviderWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, providerId ProviderId, params *UpdateProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProviderResp, error) {
	rsp, err := c.UpdateProviderWithBody(ctx, organizationId, providerId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProviderResp(rsp)
}

func (c *ClientWithResponses) UpdateProviderWithResponse(ctx context.Context, organizationId OrganizationId, providerId ProviderId, params *UpdateProviderParams, body UpdateProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProviderResp, error) {
	rsp, err := c.UpdateProvider(ctx, organizationId, providerId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProviderResp(rsp)
}

// ListOrganizationLevelAnalyticsClustersWithResponse request returning *ListOrganizationLevelAnalyticsClustersResp
func (c *ClientWithResponses) ListOrganizationLevelAnalyticsClustersWithResponse(ctx context.Context, organizationId OrganizationId, params *ListOrganizationLevelAnalyticsClustersParams, reqEditors ...RequestEditorFn) (*ListOrganizationLevelAnalyticsClustersResp, error) {
	rsp, err := c.ListOrganizationLevelAnalyticsClusters(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrganizationLevelAnalyticsClustersResp(rsp)
}

// ListOrganizationAPIKeysWithResponse request returning *ListOrganizationAPIKeysResp
func (c *ClientWithResponses) ListOrganizationAPIKeysWithResponse(ctx context.Context, organizationId OrganizationId, params *ListOrganizationAPIKeysParams, reqEditors ...RequestEditorFn) (*ListOrganizationAPIKeysResp, error) {
	rsp, err := c.ListOrganizationAPIKeys(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrganizationAPIKeysResp(rsp)
}

// PostOrganizationAPIKeysWithBodyWithResponse request with arbitrary body returning *PostOrganizationAPIKeysResp
func (c *ClientWithResponses) PostOrganizationAPIKeysWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrganizationAPIKeysResp, error) {
	rsp, err := c.PostOrganizationAPIKeysWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrganizationAPIKeysResp(rsp)
}

func (c *ClientWithResponses) PostOrganizationAPIKeysWithResponse(ctx context.Context, organizationId OrganizationId, body PostOrganizationAPIKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrganizationAPIKeysResp, error) {
	rsp, err := c.PostOrganizationAPIKeys(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrganizationAPIKeysResp(rsp)
}

// DeleteOrganizationAPIKeyWithResponse request returning *DeleteOrganizationAPIKeyResp
func (c *ClientWithResponses) DeleteOrganizationAPIKeyWithResponse(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, reqEditors ...RequestEditorFn) (*DeleteOrganizationAPIKeyResp, error) {
	rsp, err := c.DeleteOrganizationAPIKey(ctx, organizationId, apiKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationAPIKeyResp(rsp)
}

// GetOrganizationAPIKeyByAccessKeyWithResponse request returning *GetOrganizationAPIKeyByAccessKeyResp
func (c *ClientWithResponses) GetOrganizationAPIKeyByAccessKeyWithResponse(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, reqEditors ...RequestEditorFn) (*GetOrganizationAPIKeyByAccessKeyResp, error) {
	rsp, err := c.GetOrganizationAPIKeyByAccessKey(ctx, organizationId, apiKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationAPIKeyByAccessKeyResp(rsp)
}

// PostOrganizationAPIKeyRotateWithBodyWithResponse request with arbitrary body returning *PostOrganizationAPIKeyRotateResp
func (c *ClientWithResponses) PostOrganizationAPIKeyRotateWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrganizationAPIKeyRotateResp, error) {
	rsp, err := c.PostOrganizationAPIKeyRotateWithBody(ctx, organizationId, apiKeyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrganizationAPIKeyRotateResp(rsp)
}

func (c *ClientWithResponses) PostOrganizationAPIKeyRotateWithResponse(ctx context.Context, organizationId OrganizationId, apiKeyId AccessKey, body PostOrganizationAPIKeyRotateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrganizationAPIKeyRotateResp, error) {
	rsp, err := c.PostOrganizationAPIKeyRotate(ctx, organizationId, apiKeyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrganizationAPIKeyRotateResp(rsp)
}

// ListAppServicesWithResponse request returning *ListAppServicesResp
func (c *ClientWithResponses) ListAppServicesWithResponse(ctx context.Context, organizationId OrganizationId, params *ListAppServicesParams, reqEditors ...RequestEditorFn) (*ListAppServicesResp, error) {
	rsp, err := c.ListAppServices(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppServicesResp(rsp)
}

// GetCloudAccountsWithResponse request returning *GetCloudAccountsResp
func (c *ClientWithResponses) GetCloudAccountsWithResponse(ctx context.Context, organizationId OrganizationId, reqEditors ...RequestEditorFn) (*GetCloudAccountsResp, error) {
	rsp, err := c.GetCloudAccounts(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCloudAccountsResp(rsp)
}

// GetKeyMetadataListWithResponse request returning *GetKeyMetadataListResp
func (c *ClientWithResponses) GetKeyMetadataListWithResponse(ctx context.Context, organizationId OrganizationId, params *GetKeyMetadataListParams, reqEditors ...RequestEditorFn) (*GetKeyMetadataListResp, error) {
	rsp, err := c.GetKeyMetadataList(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeyMetadataListResp(rsp)
}

// PostCMEKMetadataWithBodyWithResponse request with arbitrary body returning *PostCMEKMetadataResp
func (c *ClientWithResponses) PostCMEKMetadataWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCMEKMetadataResp, error) {
	rsp, err := c.PostCMEKMetadataWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCMEKMetadataResp(rsp)
}

func (c *ClientWithResponses) PostCMEKMetadataWithResponse(ctx context.Context, organizationId OrganizationId, body PostCMEKMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCMEKMetadataResp, error) {
	rsp, err := c.PostCMEKMetadata(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCMEKMetadataResp(rsp)
}

// DeleteKeyMetadataWithResponse request returning *DeleteKeyMetadataResp
func (c *ClientWithResponses) DeleteKeyMetadataWithResponse(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*DeleteKeyMetadataResp, error) {
	rsp, err := c.DeleteKeyMetadata(ctx, organizationId, cmekId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeyMetadataResp(rsp)
}

// GetKeyMetadataWithResponse request returning *GetKeyMetadataResp
func (c *ClientWithResponses) GetKeyMetadataWithResponse(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*GetKeyMetadataResp, error) {
	rsp, err := c.GetKeyMetadata(ctx, organizationId, cmekId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeyMetadataResp(rsp)
}

// RotateCMEKKeyWithBodyWithResponse request with arbitrary body returning *RotateCMEKKeyResp
func (c *ClientWithResponses) RotateCMEKKeyWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RotateCMEKKeyResp, error) {
	rsp, err := c.RotateCMEKKeyWithBody(ctx, organizationId, cmekId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRotateCMEKKeyResp(rsp)
}

func (c *ClientWithResponses) RotateCMEKKeyWithResponse(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, body RotateCMEKKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*RotateCMEKKeyResp, error) {
	rsp, err := c.RotateCMEKKey(ctx, organizationId, cmekId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRotateCMEKKeyResp(rsp)
}

// ListCMEKHistoryWithResponse request returning *ListCMEKHistoryResp
func (c *ClientWithResponses) ListCMEKHistoryWithResponse(ctx context.Context, organizationId OrganizationId, cmekId CMEKId, params *ListCMEKHistoryParams, reqEditors ...RequestEditorFn) (*ListCMEKHistoryResp, error) {
	rsp, err := c.ListCMEKHistory(ctx, organizationId, cmekId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCMEKHistoryResp(rsp)
}

// PutOrganizationConfigurationWithBodyWithResponse request with arbitrary body returning *PutOrganizationConfigurationResp
func (c *ClientWithResponses) PutOrganizationConfigurationWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, params *PutOrganizationConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutOrganizationConfigurationResp, error) {
	rsp, err := c.PutOrganizationConfigurationWithBody(ctx, organizationId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutOrganizationConfigurationResp(rsp)
}

func (c *ClientWithResponses) PutOrganizationConfigurationWithResponse(ctx context.Context, organizationId OrganizationId, params *PutOrganizationConfigurationParams, body PutOrganizationConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*PutOrganizationConfigurationResp, error) {
	rsp, err := c.PutOrganizationConfiguration(ctx, organizationId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutOrganizationConfigurationResp(rsp)
}

// ListEventsWithResponse request returning *ListEventsResp
func (c *ClientWithResponses) ListEventsWithResponse(ctx context.Context, organizationId OrganizationId, params *ListEventsParams, reqEditors ...RequestEditorFn) (*ListEventsResp, error) {
	rsp, err := c.ListEvents(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventsResp(rsp)
}

// GetEventByIDWithResponse request returning *GetEventByIDResp
func (c *ClientWithResponses) GetEventByIDWithResponse(ctx context.Context, organizationId OrganizationId, eventId EventId, reqEditors ...RequestEditorFn) (*GetEventByIDResp, error) {
	rsp, err := c.GetEventByID(ctx, organizationId, eventId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventByIDResp(rsp)
}

// ListProjectsWithResponse request returning *ListProjectsResp
func (c *ClientWithResponses) ListProjectsWithResponse(ctx context.Context, organizationId OrganizationId, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResp, error) {
	rsp, err := c.ListProjects(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectsResp(rsp)
}

// PostProjectWithBodyWithResponse request with arbitrary body returning *PostProjectResp
func (c *ClientWithResponses) PostProjectWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProjectResp, error) {
	rsp, err := c.PostProjectWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProjectResp(rsp)
}

func (c *ClientWithResponses) PostProjectWithResponse(ctx context.Context, organizationId OrganizationId, body PostProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProjectResp, error) {
	rsp, err := c.PostProject(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProjectResp(rsp)
}

// DeleteProjectByIDWithResponse request returning *DeleteProjectByIDResp
func (c *ClientWithResponses) DeleteProjectByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, reqEditors ...RequestEditorFn) (*DeleteProjectByIDResp, error) {
	rsp, err := c.DeleteProjectByID(ctx, organizationId, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectByIDResp(rsp)
}

// GetProjectByIDWithResponse request returning *GetProjectByIDResp
func (c *ClientWithResponses) GetProjectByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, reqEditors ...RequestEditorFn) (*GetProjectByIDResp, error) {
	rsp, err := c.GetProjectByID(ctx, organizationId, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectByIDResp(rsp)
}

// PutProjectWithBodyWithResponse request with arbitrary body returning *PutProjectResp
func (c *ClientWithResponses) PutProjectWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *PutProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutProjectResp, error) {
	rsp, err := c.PutProjectWithBody(ctx, organizationId, projectId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutProjectResp(rsp)
}

func (c *ClientWithResponses) PutProjectWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *PutProjectParams, body PutProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*PutProjectResp, error) {
	rsp, err := c.PutProject(ctx, organizationId, projectId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutProjectResp(rsp)
}

// PostTestAlertIntegrationWithBodyWithResponse request with arbitrary body returning *PostTestAlertIntegrationResp
func (c *ClientWithResponses) PostTestAlertIntegrationWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTestAlertIntegrationResp, error) {
	rsp, err := c.PostTestAlertIntegrationWithBody(ctx, organizationId, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTestAlertIntegrationResp(rsp)
}

func (c *ClientWithResponses) PostTestAlertIntegrationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body PostTestAlertIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTestAlertIntegrationResp, error) {
	rsp, err := c.PostTestAlertIntegration(ctx, organizationId, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTestAlertIntegrationResp(rsp)
}

// ListAlertIntegrationsWithResponse request returning *ListAlertIntegrationsResp
func (c *ClientWithResponses) ListAlertIntegrationsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListAlertIntegrationsParams, reqEditors ...RequestEditorFn) (*ListAlertIntegrationsResp, error) {
	rsp, err := c.ListAlertIntegrations(ctx, organizationId, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAlertIntegrationsResp(rsp)
}

// PostAlertIntegrationWithBodyWithResponse request with arbitrary body returning *PostAlertIntegrationResp
func (c *ClientWithResponses) PostAlertIntegrationWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAlertIntegrationResp, error) {
	rsp, err := c.PostAlertIntegrationWithBody(ctx, organizationId, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAlertIntegrationResp(rsp)
}

func (c *ClientWithResponses) PostAlertIntegrationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body PostAlertIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAlertIntegrationResp, error) {
	rsp, err := c.PostAlertIntegration(ctx, organizationId, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAlertIntegrationResp(rsp)
}

// DeleteAlertIntegrationByIDWithResponse request returning *DeleteAlertIntegrationByIDResp
func (c *ClientWithResponses) DeleteAlertIntegrationByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, reqEditors ...RequestEditorFn) (*DeleteAlertIntegrationByIDResp, error) {
	rsp, err := c.DeleteAlertIntegrationByID(ctx, organizationId, projectId, alertIntegrationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAlertIntegrationByIDResp(rsp)
}

// GetAlertIntegrationByIDWithResponse request returning *GetAlertIntegrationByIDResp
func (c *ClientWithResponses) GetAlertIntegrationByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, reqEditors ...RequestEditorFn) (*GetAlertIntegrationByIDResp, error) {
	rsp, err := c.GetAlertIntegrationByID(ctx, organizationId, projectId, alertIntegrationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlertIntegrationByIDResp(rsp)
}

// PutAlertIntegrationWithBodyWithResponse request with arbitrary body returning *PutAlertIntegrationResp
func (c *ClientWithResponses) PutAlertIntegrationWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAlertIntegrationResp, error) {
	rsp, err := c.PutAlertIntegrationWithBody(ctx, organizationId, projectId, alertIntegrationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAlertIntegrationResp(rsp)
}

func (c *ClientWithResponses) PutAlertIntegrationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, alertIntegrationId AlertIntegrationId, body PutAlertIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAlertIntegrationResp, error) {
	rsp, err := c.PutAlertIntegration(ctx, organizationId, projectId, alertIntegrationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAlertIntegrationResp(rsp)
}

// ListProjectLevelAnalyticsClustersWithResponse request returning *ListProjectLevelAnalyticsClustersResp
func (c *ClientWithResponses) ListProjectLevelAnalyticsClustersWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectLevelAnalyticsClustersParams, reqEditors ...RequestEditorFn) (*ListProjectLevelAnalyticsClustersResp, error) {
	rsp, err := c.ListProjectLevelAnalyticsClusters(ctx, organizationId, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectLevelAnalyticsClustersResp(rsp)
}

// CreateAnalyticsClusterWithBodyWithResponse request with arbitrary body returning *CreateAnalyticsClusterResp
func (c *ClientWithResponses) CreateAnalyticsClusterWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAnalyticsClusterResp, error) {
	rsp, err := c.CreateAnalyticsClusterWithBody(ctx, organizationId, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAnalyticsClusterResp(rsp)
}

func (c *ClientWithResponses) CreateAnalyticsClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body CreateAnalyticsClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAnalyticsClusterResp, error) {
	rsp, err := c.CreateAnalyticsCluster(ctx, organizationId, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAnalyticsClusterResp(rsp)
}

// DeleteAnalyticsClusterWithResponse request returning *DeleteAnalyticsClusterResp
func (c *ClientWithResponses) DeleteAnalyticsClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*DeleteAnalyticsClusterResp, error) {
	rsp, err := c.DeleteAnalyticsCluster(ctx, organizationId, projectId, analyticsClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAnalyticsClusterResp(rsp)
}

// GetAnalyticsClusterWithResponse request returning *GetAnalyticsClusterResp
func (c *ClientWithResponses) GetAnalyticsClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*GetAnalyticsClusterResp, error) {
	rsp, err := c.GetAnalyticsCluster(ctx, organizationId, projectId, analyticsClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnalyticsClusterResp(rsp)
}

// PutAnalyticsClusterWithBodyWithResponse request with arbitrary body returning *PutAnalyticsClusterResp
func (c *ClientWithResponses) PutAnalyticsClusterWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *PutAnalyticsClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAnalyticsClusterResp, error) {
	rsp, err := c.PutAnalyticsClusterWithBody(ctx, organizationId, projectId, analyticsClusterId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAnalyticsClusterResp(rsp)
}

func (c *ClientWithResponses) PutAnalyticsClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *PutAnalyticsClusterParams, body PutAnalyticsClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAnalyticsClusterResp, error) {
	rsp, err := c.PutAnalyticsCluster(ctx, organizationId, projectId, analyticsClusterId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAnalyticsClusterResp(rsp)
}

// AnalyticsClusterOffWithResponse request returning *AnalyticsClusterOffResp
func (c *ClientWithResponses) AnalyticsClusterOffWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*AnalyticsClusterOffResp, error) {
	rsp, err := c.AnalyticsClusterOff(ctx, organizationId, projectId, analyticsClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnalyticsClusterOffResp(rsp)
}

// AnalyticsClusterOnWithResponse request returning *AnalyticsClusterOnResp
func (c *ClientWithResponses) AnalyticsClusterOnWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*AnalyticsClusterOnResp, error) {
	rsp, err := c.AnalyticsClusterOn(ctx, organizationId, projectId, analyticsClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnalyticsClusterOnResp(rsp)
}

// ListAnalyticsAllowedCidrsWithResponse request returning *ListAnalyticsAllowedCidrsResp
func (c *ClientWithResponses) ListAnalyticsAllowedCidrsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListAnalyticsAllowedCidrsParams, reqEditors ...RequestEditorFn) (*ListAnalyticsAllowedCidrsResp, error) {
	rsp, err := c.ListAnalyticsAllowedCidrs(ctx, organizationId, projectId, analyticsClusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAnalyticsAllowedCidrsResp(rsp)
}

// PostAnalyticsAllowedCidrWithBodyWithResponse request with arbitrary body returning *PostAnalyticsAllowedCidrResp
func (c *ClientWithResponses) PostAnalyticsAllowedCidrWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnalyticsAllowedCidrResp, error) {
	rsp, err := c.PostAnalyticsAllowedCidrWithBody(ctx, organizationId, projectId, analyticsClusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnalyticsAllowedCidrResp(rsp)
}

func (c *ClientWithResponses) PostAnalyticsAllowedCidrWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PostAnalyticsAllowedCidrJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnalyticsAllowedCidrResp, error) {
	rsp, err := c.PostAnalyticsAllowedCidr(ctx, organizationId, projectId, analyticsClusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnalyticsAllowedCidrResp(rsp)
}

// DeleteColumnarAllowedCidrByIDWithResponse request returning *DeleteColumnarAllowedCidrByIDResp
func (c *ClientWithResponses) DeleteColumnarAllowedCidrByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*DeleteColumnarAllowedCidrByIDResp, error) {
	rsp, err := c.DeleteColumnarAllowedCidrByID(ctx, organizationId, projectId, analyticsClusterId, allowedCidrId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteColumnarAllowedCidrByIDResp(rsp)
}

// GetColumnarAllowedCidrByIDWithResponse request returning *GetColumnarAllowedCidrByIDResp
func (c *ClientWithResponses) GetColumnarAllowedCidrByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*GetColumnarAllowedCidrByIDResp, error) {
	rsp, err := c.GetColumnarAllowedCidrByID(ctx, organizationId, projectId, analyticsClusterId, allowedCidrId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetColumnarAllowedCidrByIDResp(rsp)
}

// DeleteColumnarAnalyticsBackupScheduleWithResponse request returning *DeleteColumnarAnalyticsBackupScheduleResp
func (c *ClientWithResponses) DeleteColumnarAnalyticsBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*DeleteColumnarAnalyticsBackupScheduleResp, error) {
	rsp, err := c.DeleteColumnarAnalyticsBackupSchedule(ctx, organizationId, projectId, analyticsClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteColumnarAnalyticsBackupScheduleResp(rsp)
}

// GetColumnarAnalyticsBackupScheduleWithResponse request returning *GetColumnarAnalyticsBackupScheduleResp
func (c *ClientWithResponses) GetColumnarAnalyticsBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*GetColumnarAnalyticsBackupScheduleResp, error) {
	rsp, err := c.GetColumnarAnalyticsBackupSchedule(ctx, organizationId, projectId, analyticsClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetColumnarAnalyticsBackupScheduleResp(rsp)
}

// UpsertColumnarAnalyticsBackupScheduleWithBodyWithResponse request with arbitrary body returning *UpsertColumnarAnalyticsBackupScheduleResp
func (c *ClientWithResponses) UpsertColumnarAnalyticsBackupScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertColumnarAnalyticsBackupScheduleResp, error) {
	rsp, err := c.UpsertColumnarAnalyticsBackupScheduleWithBody(ctx, organizationId, projectId, analyticsClusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertColumnarAnalyticsBackupScheduleResp(rsp)
}

func (c *ClientWithResponses) UpsertColumnarAnalyticsBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body UpsertColumnarAnalyticsBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertColumnarAnalyticsBackupScheduleResp, error) {
	rsp, err := c.UpsertColumnarAnalyticsBackupSchedule(ctx, organizationId, projectId, analyticsClusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertColumnarAnalyticsBackupScheduleResp(rsp)
}

// ListColumnarAnalyticsBackupsWithResponse request returning *ListColumnarAnalyticsBackupsResp
func (c *ClientWithResponses) ListColumnarAnalyticsBackupsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListColumnarAnalyticsBackupsParams, reqEditors ...RequestEditorFn) (*ListColumnarAnalyticsBackupsResp, error) {
	rsp, err := c.ListColumnarAnalyticsBackups(ctx, organizationId, projectId, analyticsClusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListColumnarAnalyticsBackupsResp(rsp)
}

// CreateColumnarAnalyticsBackupWithBodyWithResponse request with arbitrary body returning *CreateColumnarAnalyticsBackupResp
func (c *ClientWithResponses) CreateColumnarAnalyticsBackupWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateColumnarAnalyticsBackupResp, error) {
	rsp, err := c.CreateColumnarAnalyticsBackupWithBody(ctx, organizationId, projectId, analyticsClusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateColumnarAnalyticsBackupResp(rsp)
}

func (c *ClientWithResponses) CreateColumnarAnalyticsBackupWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body CreateColumnarAnalyticsBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateColumnarAnalyticsBackupResp, error) {
	rsp, err := c.CreateColumnarAnalyticsBackup(ctx, organizationId, projectId, analyticsClusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateColumnarAnalyticsBackupResp(rsp)
}

// ListColumnarAnalyticsRestoresWithResponse request returning *ListColumnarAnalyticsRestoresResp
func (c *ClientWithResponses) ListColumnarAnalyticsRestoresWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, params *ListColumnarAnalyticsRestoresParams, reqEditors ...RequestEditorFn) (*ListColumnarAnalyticsRestoresResp, error) {
	rsp, err := c.ListColumnarAnalyticsRestores(ctx, organizationId, projectId, analyticsClusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListColumnarAnalyticsRestoresResp(rsp)
}

// DeleteColumnarAnalyticsBackupWithResponse request returning *DeleteColumnarAnalyticsBackupResp
func (c *ClientWithResponses) DeleteColumnarAnalyticsBackupWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*DeleteColumnarAnalyticsBackupResp, error) {
	rsp, err := c.DeleteColumnarAnalyticsBackup(ctx, organizationId, projectId, analyticsClusterId, backupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteColumnarAnalyticsBackupResp(rsp)
}

// UpdateColumnarAnalyticsBackupRetentionWithBodyWithResponse request with arbitrary body returning *UpdateColumnarAnalyticsBackupRetentionResp
func (c *ClientWithResponses) UpdateColumnarAnalyticsBackupRetentionWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateColumnarAnalyticsBackupRetentionResp, error) {
	rsp, err := c.UpdateColumnarAnalyticsBackupRetentionWithBody(ctx, organizationId, projectId, analyticsClusterId, backupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateColumnarAnalyticsBackupRetentionResp(rsp)
}

func (c *ClientWithResponses) UpdateColumnarAnalyticsBackupRetentionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, body UpdateColumnarAnalyticsBackupRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateColumnarAnalyticsBackupRetentionResp, error) {
	rsp, err := c.UpdateColumnarAnalyticsBackupRetention(ctx, organizationId, projectId, analyticsClusterId, backupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateColumnarAnalyticsBackupRetentionResp(rsp)
}

// RestoreColumnarAnalyticsClusterWithResponse request returning *RestoreColumnarAnalyticsClusterResp
func (c *ClientWithResponses) RestoreColumnarAnalyticsClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*RestoreColumnarAnalyticsClusterResp, error) {
	rsp, err := c.RestoreColumnarAnalyticsCluster(ctx, organizationId, projectId, analyticsClusterId, backupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreColumnarAnalyticsClusterResp(rsp)
}

// DeleteAnalyticsOnOffScheduleWithResponse request returning *DeleteAnalyticsOnOffScheduleResp
func (c *ClientWithResponses) DeleteAnalyticsOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*DeleteAnalyticsOnOffScheduleResp, error) {
	rsp, err := c.DeleteAnalyticsOnOffSchedule(ctx, organizationId, projectId, analyticsClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAnalyticsOnOffScheduleResp(rsp)
}

// GetAnalyticsOnOffScheduleWithResponse request returning *GetAnalyticsOnOffScheduleResp
func (c *ClientWithResponses) GetAnalyticsOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*GetAnalyticsOnOffScheduleResp, error) {
	rsp, err := c.GetAnalyticsOnOffSchedule(ctx, organizationId, projectId, analyticsClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnalyticsOnOffScheduleResp(rsp)
}

// PostAnalyticsOnOffScheduleWithBodyWithResponse request with arbitrary body returning *PostAnalyticsOnOffScheduleResp
func (c *ClientWithResponses) PostAnalyticsOnOffScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnalyticsOnOffScheduleResp, error) {
	rsp, err := c.PostAnalyticsOnOffScheduleWithBody(ctx, organizationId, projectId, analyticsClusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnalyticsOnOffScheduleResp(rsp)
}

func (c *ClientWithResponses) PostAnalyticsOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PostAnalyticsOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnalyticsOnOffScheduleResp, error) {
	rsp, err := c.PostAnalyticsOnOffSchedule(ctx, organizationId, projectId, analyticsClusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnalyticsOnOffScheduleResp(rsp)
}

// PutAnalyticsOnOffScheduleWithBodyWithResponse request with arbitrary body returning *PutAnalyticsOnOffScheduleResp
func (c *ClientWithResponses) PutAnalyticsOnOffScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAnalyticsOnOffScheduleResp, error) {
	rsp, err := c.PutAnalyticsOnOffScheduleWithBody(ctx, organizationId, projectId, analyticsClusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAnalyticsOnOffScheduleResp(rsp)
}

func (c *ClientWithResponses) PutAnalyticsOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body PutAnalyticsOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAnalyticsOnOffScheduleResp, error) {
	rsp, err := c.PutAnalyticsOnOffSchedule(ctx, organizationId, projectId, analyticsClusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAnalyticsOnOffScheduleResp(rsp)
}

// DisableColumnarPrivateEndpointServiceWithResponse request returning *DisableColumnarPrivateEndpointServiceResp
func (c *ClientWithResponses) DisableColumnarPrivateEndpointServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*DisableColumnarPrivateEndpointServiceResp, error) {
	rsp, err := c.DisableColumnarPrivateEndpointService(ctx, organizationId, projectId, analyticsClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableColumnarPrivateEndpointServiceResp(rsp)
}

// GetColumnarPrivateEndpointServiceStatusWithResponse request returning *GetColumnarPrivateEndpointServiceStatusResp
func (c *ClientWithResponses) GetColumnarPrivateEndpointServiceStatusWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*GetColumnarPrivateEndpointServiceStatusResp, error) {
	rsp, err := c.GetColumnarPrivateEndpointServiceStatus(ctx, organizationId, projectId, analyticsClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetColumnarPrivateEndpointServiceStatusResp(rsp)
}

// EnableColumnarPrivateEndpointServiceWithResponse request returning *EnableColumnarPrivateEndpointServiceResp
func (c *ClientWithResponses) EnableColumnarPrivateEndpointServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*EnableColumnarPrivateEndpointServiceResp, error) {
	rsp, err := c.EnableColumnarPrivateEndpointService(ctx, organizationId, projectId, analyticsClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableColumnarPrivateEndpointServiceResp(rsp)
}

// GetColumnarPrivateEndpointServiceCommandWithBodyWithResponse request with arbitrary body returning *GetColumnarPrivateEndpointServiceCommandResp
func (c *ClientWithResponses) GetColumnarPrivateEndpointServiceCommandWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetColumnarPrivateEndpointServiceCommandResp, error) {
	rsp, err := c.GetColumnarPrivateEndpointServiceCommandWithBody(ctx, organizationId, projectId, analyticsClusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetColumnarPrivateEndpointServiceCommandResp(rsp)
}

func (c *ClientWithResponses) GetColumnarPrivateEndpointServiceCommandWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, body GetColumnarPrivateEndpointServiceCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*GetColumnarPrivateEndpointServiceCommandResp, error) {
	rsp, err := c.GetColumnarPrivateEndpointServiceCommand(ctx, organizationId, projectId, analyticsClusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetColumnarPrivateEndpointServiceCommandResp(rsp)
}

// ListColumnarPrivateEndpointServiceConnectionWithResponse request returning *ListColumnarPrivateEndpointServiceConnectionResp
func (c *ClientWithResponses) ListColumnarPrivateEndpointServiceConnectionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, reqEditors ...RequestEditorFn) (*ListColumnarPrivateEndpointServiceConnectionResp, error) {
	rsp, err := c.ListColumnarPrivateEndpointServiceConnection(ctx, organizationId, projectId, analyticsClusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListColumnarPrivateEndpointServiceConnectionResp(rsp)
}

// AcceptColumnarPrivateEndpointServiceConnectionWithResponse request returning *AcceptColumnarPrivateEndpointServiceConnectionResp
func (c *ClientWithResponses) AcceptColumnarPrivateEndpointServiceConnectionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*AcceptColumnarPrivateEndpointServiceConnectionResp, error) {
	rsp, err := c.AcceptColumnarPrivateEndpointServiceConnection(ctx, organizationId, projectId, analyticsClusterId, endpointId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptColumnarPrivateEndpointServiceConnectionResp(rsp)
}

// RejectColumnarPrivateEndpointServiceConnectionWithResponse request returning *RejectColumnarPrivateEndpointServiceConnectionResp
func (c *ClientWithResponses) RejectColumnarPrivateEndpointServiceConnectionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, analyticsClusterId AnalyticsClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*RejectColumnarPrivateEndpointServiceConnectionResp, error) {
	rsp, err := c.RejectColumnarPrivateEndpointServiceConnection(ctx, organizationId, projectId, analyticsClusterId, endpointId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRejectColumnarPrivateEndpointServiceConnectionResp(rsp)
}

// ListProjectLevelCloudSnapshotBackupsWithResponse request returning *ListProjectLevelCloudSnapshotBackupsResp
func (c *ClientWithResponses) ListProjectLevelCloudSnapshotBackupsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectLevelCloudSnapshotBackupsParams, reqEditors ...RequestEditorFn) (*ListProjectLevelCloudSnapshotBackupsResp, error) {
	rsp, err := c.ListProjectLevelCloudSnapshotBackups(ctx, organizationId, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectLevelCloudSnapshotBackupsResp(rsp)
}

// CloneWithBodyWithResponse request with arbitrary body returning *CloneResp
func (c *ClientWithResponses) CloneWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloneResp, error) {
	rsp, err := c.CloneWithBody(ctx, organizationId, projectId, backupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloneResp(rsp)
}

func (c *ClientWithResponses) CloneWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, backupId BackupId, body CloneJSONRequestBody, reqEditors ...RequestEditorFn) (*CloneResp, error) {
	rsp, err := c.Clone(ctx, organizationId, projectId, backupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloneResp(rsp)
}

// ListClustersWithResponse request returning *ListClustersResp
func (c *ClientWithResponses) ListClustersWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResp, error) {
	rsp, err := c.ListClusters(ctx, organizationId, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClustersResp(rsp)
}

// PostClusterWithBodyWithResponse request with arbitrary body returning *PostClusterResp
func (c *ClientWithResponses) PostClusterWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClusterResp, error) {
	rsp, err := c.PostClusterWithBody(ctx, organizationId, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClusterResp(rsp)
}

func (c *ClientWithResponses) PostClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClusterResp, error) {
	rsp, err := c.PostCluster(ctx, organizationId, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClusterResp(rsp)
}

// CreateFreeTierClusterWithBodyWithResponse request with arbitrary body returning *CreateFreeTierClusterResp
func (c *ClientWithResponses) CreateFreeTierClusterWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFreeTierClusterResp, error) {
	rsp, err := c.CreateFreeTierClusterWithBody(ctx, organizationId, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFreeTierClusterResp(rsp)
}

func (c *ClientWithResponses) CreateFreeTierClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, body CreateFreeTierClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFreeTierClusterResp, error) {
	rsp, err := c.CreateFreeTierCluster(ctx, organizationId, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFreeTierClusterResp(rsp)
}

// DeleteFreeTierClusterWithResponse request returning *DeleteFreeTierClusterResp
func (c *ClientWithResponses) DeleteFreeTierClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*DeleteFreeTierClusterResp, error) {
	rsp, err := c.DeleteFreeTierCluster(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFreeTierClusterResp(rsp)
}

// GetFreeTierClusterWithResponse request returning *GetFreeTierClusterResp
func (c *ClientWithResponses) GetFreeTierClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetFreeTierClusterResp, error) {
	rsp, err := c.GetFreeTierCluster(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFreeTierClusterResp(rsp)
}

// UpdateFreeTierClusterWithBodyWithResponse request with arbitrary body returning *UpdateFreeTierClusterResp
func (c *ClientWithResponses) UpdateFreeTierClusterWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *UpdateFreeTierClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFreeTierClusterResp, error) {
	rsp, err := c.UpdateFreeTierClusterWithBody(ctx, organizationId, projectId, clusterId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFreeTierClusterResp(rsp)
}

func (c *ClientWithResponses) UpdateFreeTierClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *UpdateFreeTierClusterParams, body UpdateFreeTierClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFreeTierClusterResp, error) {
	rsp, err := c.UpdateFreeTierCluster(ctx, organizationId, projectId, clusterId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFreeTierClusterResp(rsp)
}

// FreeTierClusterOffWithResponse request returning *FreeTierClusterOffResp
func (c *ClientWithResponses) FreeTierClusterOffWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*FreeTierClusterOffResp, error) {
	rsp, err := c.FreeTierClusterOff(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFreeTierClusterOffResp(rsp)
}

// FreeTierClusterOnWithResponse request returning *FreeTierClusterOnResp
func (c *ClientWithResponses) FreeTierClusterOnWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*FreeTierClusterOnResp, error) {
	rsp, err := c.FreeTierClusterOn(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFreeTierClusterOnResp(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResp
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResp, error) {
	rsp, err := c.DeleteCluster(ctx, organizationId, projectId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResp(rsp)
}

// GetClusterWithResponse request returning *GetClusterResp
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetClusterResp, error) {
	rsp, err := c.GetCluster(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResp(rsp)
}

// PutClusterWithBodyWithResponse request with arbitrary body returning *PutClusterResp
func (c *ClientWithResponses) PutClusterWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *PutClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutClusterResp, error) {
	rsp, err := c.PutClusterWithBody(ctx, organizationId, projectId, clusterId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutClusterResp(rsp)
}

func (c *ClientWithResponses) PutClusterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *PutClusterParams, body PutClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PutClusterResp, error) {
	rsp, err := c.PutCluster(ctx, organizationId, projectId, clusterId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutClusterResp(rsp)
}

// ClusterOffWithResponse request returning *ClusterOffResp
func (c *ClientWithResponses) ClusterOffWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ClusterOffResp, error) {
	rsp, err := c.ClusterOff(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClusterOffResp(rsp)
}

// ClusterOnWithBodyWithResponse request with arbitrary body returning *ClusterOnResp
func (c *ClientWithResponses) ClusterOnWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClusterOnResp, error) {
	rsp, err := c.ClusterOnWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClusterOnResp(rsp)
}

func (c *ClientWithResponses) ClusterOnWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body ClusterOnJSONRequestBody, reqEditors ...RequestEditorFn) (*ClusterOnResp, error) {
	rsp, err := c.ClusterOn(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClusterOnResp(rsp)
}

// ListAiWorkflowsWithResponse request returning *ListAiWorkflowsResp
func (c *ClientWithResponses) ListAiWorkflowsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAiWorkflowsParams, reqEditors ...RequestEditorFn) (*ListAiWorkflowsResp, error) {
	rsp, err := c.ListAiWorkflows(ctx, organizationId, projectId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAiWorkflowsResp(rsp)
}

// CreateAiWorkflowWithBodyWithResponse request with arbitrary body returning *CreateAiWorkflowResp
func (c *ClientWithResponses) CreateAiWorkflowWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAiWorkflowResp, error) {
	rsp, err := c.CreateAiWorkflowWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAiWorkflowResp(rsp)
}

func (c *ClientWithResponses) CreateAiWorkflowWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateAiWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAiWorkflowResp, error) {
	rsp, err := c.CreateAiWorkflow(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAiWorkflowResp(rsp)
}

// DeleteAiWorkflowWithResponse request returning *DeleteAiWorkflowResp
func (c *ClientWithResponses) DeleteAiWorkflowWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*DeleteAiWorkflowResp, error) {
	rsp, err := c.DeleteAiWorkflow(ctx, organizationId, projectId, clusterId, workflowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAiWorkflowResp(rsp)
}

// GetAiWorkflowWithResponse request returning *GetAiWorkflowResp
func (c *ClientWithResponses) GetAiWorkflowWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*GetAiWorkflowResp, error) {
	rsp, err := c.GetAiWorkflow(ctx, organizationId, projectId, clusterId, workflowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAiWorkflowResp(rsp)
}

// StopAiWorkflowRunWithResponse request returning *StopAiWorkflowRunResp
func (c *ClientWithResponses) StopAiWorkflowRunWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*StopAiWorkflowRunResp, error) {
	rsp, err := c.StopAiWorkflowRun(ctx, organizationId, projectId, clusterId, workflowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopAiWorkflowRunResp(rsp)
}

// ListAiWorkflowRunsWithResponse request returning *ListAiWorkflowRunsResp
func (c *ClientWithResponses) ListAiWorkflowRunsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, params *ListAiWorkflowRunsParams, reqEditors ...RequestEditorFn) (*ListAiWorkflowRunsResp, error) {
	rsp, err := c.ListAiWorkflowRuns(ctx, organizationId, projectId, clusterId, workflowId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAiWorkflowRunsResp(rsp)
}

// CreateAiWorkflowRunWithResponse request returning *CreateAiWorkflowRunResp
func (c *ClientWithResponses) CreateAiWorkflowRunWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*CreateAiWorkflowRunResp, error) {
	rsp, err := c.CreateAiWorkflowRun(ctx, organizationId, projectId, clusterId, workflowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAiWorkflowRunResp(rsp)
}

// GetAiWorkflowRunWithResponse request returning *GetAiWorkflowRunResp
func (c *ClientWithResponses) GetAiWorkflowRunWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, runId WorkflowRunId, reqEditors ...RequestEditorFn) (*GetAiWorkflowRunResp, error) {
	rsp, err := c.GetAiWorkflowRun(ctx, organizationId, projectId, clusterId, workflowId, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAiWorkflowRunResp(rsp)
}

// GetAiWorkflowRunProcessedFilesWithResponse request returning *GetAiWorkflowRunProcessedFilesResp
func (c *ClientWithResponses) GetAiWorkflowRunProcessedFilesWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, workflowId WorkflowId, runId WorkflowRunId, params *GetAiWorkflowRunProcessedFilesParams, reqEditors ...RequestEditorFn) (*GetAiWorkflowRunProcessedFilesResp, error) {
	rsp, err := c.GetAiWorkflowRunProcessedFiles(ctx, organizationId, projectId, clusterId, workflowId, runId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAiWorkflowRunProcessedFilesResp(rsp)
}

// ListAllowedCidrsWithResponse request returning *ListAllowedCidrsResp
func (c *ClientWithResponses) ListAllowedCidrsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAllowedCidrsParams, reqEditors ...RequestEditorFn) (*ListAllowedCidrsResp, error) {
	rsp, err := c.ListAllowedCidrs(ctx, organizationId, projectId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllowedCidrsResp(rsp)
}

// PostAllowedCidrsWithBodyWithResponse request with arbitrary body returning *PostAllowedCidrsResp
func (c *ClientWithResponses) PostAllowedCidrsWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAllowedCidrsResp, error) {
	rsp, err := c.PostAllowedCidrsWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAllowedCidrsResp(rsp)
}

func (c *ClientWithResponses) PostAllowedCidrsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAllowedCidrsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAllowedCidrsResp, error) {
	rsp, err := c.PostAllowedCidrs(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAllowedCidrsResp(rsp)
}

// DeleteAllowedCidrByIDWithResponse request returning *DeleteAllowedCidrByIDResp
func (c *ClientWithResponses) DeleteAllowedCidrByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*DeleteAllowedCidrByIDResp, error) {
	rsp, err := c.DeleteAllowedCidrByID(ctx, organizationId, projectId, clusterId, allowedCidrId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAllowedCidrByIDResp(rsp)
}

// GetAllowedCidrByIDWithResponse request returning *GetAllowedCidrByIDResp
func (c *ClientWithResponses) GetAllowedCidrByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*GetAllowedCidrByIDResp, error) {
	rsp, err := c.GetAllowedCidrByID(ctx, organizationId, projectId, clusterId, allowedCidrId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllowedCidrByIDResp(rsp)
}

// PostAppServiceWithBodyWithResponse request with arbitrary body returning *PostAppServiceResp
func (c *ClientWithResponses) PostAppServiceWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppServiceResp, error) {
	rsp, err := c.PostAppServiceWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppServiceResp(rsp)
}

func (c *ClientWithResponses) PostAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppServiceResp, error) {
	rsp, err := c.PostAppService(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppServiceResp(rsp)
}

// CreateFreeTierAppServiceWithBodyWithResponse request with arbitrary body returning *CreateFreeTierAppServiceResp
func (c *ClientWithResponses) CreateFreeTierAppServiceWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFreeTierAppServiceResp, error) {
	rsp, err := c.CreateFreeTierAppServiceWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFreeTierAppServiceResp(rsp)
}

func (c *ClientWithResponses) CreateFreeTierAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateFreeTierAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFreeTierAppServiceResp, error) {
	rsp, err := c.CreateFreeTierAppService(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFreeTierAppServiceResp(rsp)
}

// DeleteFreeTierAppServiceWithResponse request returning *DeleteFreeTierAppServiceResp
func (c *ClientWithResponses) DeleteFreeTierAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*DeleteFreeTierAppServiceResp, error) {
	rsp, err := c.DeleteFreeTierAppService(ctx, organizationId, projectId, clusterId, appServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFreeTierAppServiceResp(rsp)
}

// GetFreeTierAppServiceWithResponse request returning *GetFreeTierAppServiceResp
func (c *ClientWithResponses) GetFreeTierAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*GetFreeTierAppServiceResp, error) {
	rsp, err := c.GetFreeTierAppService(ctx, organizationId, projectId, clusterId, appServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFreeTierAppServiceResp(rsp)
}

// UpdateFreeTierAppServiceWithBodyWithResponse request with arbitrary body returning *UpdateFreeTierAppServiceResp
func (c *ClientWithResponses) UpdateFreeTierAppServiceWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *UpdateFreeTierAppServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFreeTierAppServiceResp, error) {
	rsp, err := c.UpdateFreeTierAppServiceWithBody(ctx, organizationId, projectId, clusterId, appServiceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFreeTierAppServiceResp(rsp)
}

func (c *ClientWithResponses) UpdateFreeTierAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *UpdateFreeTierAppServiceParams, body UpdateFreeTierAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFreeTierAppServiceResp, error) {
	rsp, err := c.UpdateFreeTierAppService(ctx, organizationId, projectId, clusterId, appServiceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFreeTierAppServiceResp(rsp)
}

// DeleteAppServiceWithResponse request returning *DeleteAppServiceResp
func (c *ClientWithResponses) DeleteAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*DeleteAppServiceResp, error) {
	rsp, err := c.DeleteAppService(ctx, organizationId, projectId, clusterId, appServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppServiceResp(rsp)
}

// GetAppServiceWithResponse request returning *GetAppServiceResp
func (c *ClientWithResponses) GetAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*GetAppServiceResp, error) {
	rsp, err := c.GetAppService(ctx, organizationId, projectId, clusterId, appServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppServiceResp(rsp)
}

// PutAppServiceWithBodyWithResponse request with arbitrary body returning *PutAppServiceResp
func (c *ClientWithResponses) PutAppServiceWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *PutAppServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAppServiceResp, error) {
	rsp, err := c.PutAppServiceWithBody(ctx, organizationId, projectId, clusterId, appServiceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAppServiceResp(rsp)
}

func (c *ClientWithResponses) PutAppServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *PutAppServiceParams, body PutAppServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAppServiceResp, error) {
	rsp, err := c.PutAppService(ctx, organizationId, projectId, clusterId, appServiceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAppServiceResp(rsp)
}

// AppServiceOffWithResponse request returning *AppServiceOffResp
func (c *ClientWithResponses) AppServiceOffWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*AppServiceOffResp, error) {
	rsp, err := c.AppServiceOff(ctx, organizationId, projectId, clusterId, appServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppServiceOffResp(rsp)
}

// AppServiceOnWithResponse request returning *AppServiceOnResp
func (c *ClientWithResponses) AppServiceOnWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*AppServiceOnResp, error) {
	rsp, err := c.AppServiceOn(ctx, organizationId, projectId, clusterId, appServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppServiceOnResp(rsp)
}

// ListAppServiceAdminUsersWithResponse request returning *ListAppServiceAdminUsersResp
func (c *ClientWithResponses) ListAppServiceAdminUsersWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAdminUsersParams, reqEditors ...RequestEditorFn) (*ListAppServiceAdminUsersResp, error) {
	rsp, err := c.ListAppServiceAdminUsers(ctx, organizationId, projectId, clusterId, appServiceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppServiceAdminUsersResp(rsp)
}

// AddAppServiceAdminUserWithBodyWithResponse request with arbitrary body returning *AddAppServiceAdminUserResp
func (c *ClientWithResponses) AddAppServiceAdminUserWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAppServiceAdminUserResp, error) {
	rsp, err := c.AddAppServiceAdminUserWithBody(ctx, organizationId, projectId, clusterId, appServiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAppServiceAdminUserResp(rsp)
}

func (c *ClientWithResponses) AddAppServiceAdminUserWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body AddAppServiceAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAppServiceAdminUserResp, error) {
	rsp, err := c.AddAppServiceAdminUser(ctx, organizationId, projectId, clusterId, appServiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAppServiceAdminUserResp(rsp)
}

// DeleteAppServiceAdminUserWithResponse request returning *DeleteAppServiceAdminUserResp
func (c *ClientWithResponses) DeleteAppServiceAdminUserWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, reqEditors ...RequestEditorFn) (*DeleteAppServiceAdminUserResp, error) {
	rsp, err := c.DeleteAppServiceAdminUser(ctx, organizationId, projectId, clusterId, appServiceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppServiceAdminUserResp(rsp)
}

// GetAppServiceAdminUserWithResponse request returning *GetAppServiceAdminUserResp
func (c *ClientWithResponses) GetAppServiceAdminUserWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, reqEditors ...RequestEditorFn) (*GetAppServiceAdminUserResp, error) {
	rsp, err := c.GetAppServiceAdminUser(ctx, organizationId, projectId, clusterId, appServiceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppServiceAdminUserResp(rsp)
}

// UpdateAppServiceAdminUserWithBodyWithResponse request with arbitrary body returning *UpdateAppServiceAdminUserResp
func (c *ClientWithResponses) UpdateAppServiceAdminUserWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppServiceAdminUserResp, error) {
	rsp, err := c.UpdateAppServiceAdminUserWithBody(ctx, organizationId, projectId, clusterId, appServiceId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppServiceAdminUserResp(rsp)
}

func (c *ClientWithResponses) UpdateAppServiceAdminUserWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, userId UserId, body UpdateAppServiceAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppServiceAdminUserResp, error) {
	rsp, err := c.UpdateAppServiceAdminUser(ctx, organizationId, projectId, clusterId, appServiceId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppServiceAdminUserResp(rsp)
}

// ListAppServiceAllowedCidrsWithResponse request returning *ListAppServiceAllowedCidrsResp
func (c *ClientWithResponses) ListAppServiceAllowedCidrsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAllowedCidrsParams, reqEditors ...RequestEditorFn) (*ListAppServiceAllowedCidrsResp, error) {
	rsp, err := c.ListAppServiceAllowedCidrs(ctx, organizationId, projectId, clusterId, appServiceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppServiceAllowedCidrsResp(rsp)
}

// PostAppServiceAllowedCidrWithBodyWithResponse request with arbitrary body returning *PostAppServiceAllowedCidrResp
func (c *ClientWithResponses) PostAppServiceAllowedCidrWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppServiceAllowedCidrResp, error) {
	rsp, err := c.PostAppServiceAllowedCidrWithBody(ctx, organizationId, projectId, clusterId, appServiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppServiceAllowedCidrResp(rsp)
}

func (c *ClientWithResponses) PostAppServiceAllowedCidrWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppServiceAllowedCidrJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppServiceAllowedCidrResp, error) {
	rsp, err := c.PostAppServiceAllowedCidr(ctx, organizationId, projectId, clusterId, appServiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppServiceAllowedCidrResp(rsp)
}

// DeleteAppServiceAllowedCidrWithResponse request returning *DeleteAppServiceAllowedCidrResp
func (c *ClientWithResponses) DeleteAppServiceAllowedCidrWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, allowedCidrId AllowedCidrId, reqEditors ...RequestEditorFn) (*DeleteAppServiceAllowedCidrResp, error) {
	rsp, err := c.DeleteAppServiceAllowedCidr(ctx, organizationId, projectId, clusterId, appServiceId, allowedCidrId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppServiceAllowedCidrResp(rsp)
}

// ListAppEndpointsWithResponse request returning *ListAppEndpointsResp
func (c *ClientWithResponses) ListAppEndpointsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppEndpointsParams, reqEditors ...RequestEditorFn) (*ListAppEndpointsResp, error) {
	rsp, err := c.ListAppEndpoints(ctx, organizationId, projectId, clusterId, appServiceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppEndpointsResp(rsp)
}

// PostAppEndpointWithBodyWithResponse request with arbitrary body returning *PostAppEndpointResp
func (c *ClientWithResponses) PostAppEndpointWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppEndpointResp, error) {
	rsp, err := c.PostAppEndpointWithBody(ctx, organizationId, projectId, clusterId, appServiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppEndpointResp(rsp)
}

func (c *ClientWithResponses) PostAppEndpointWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppEndpointResp, error) {
	rsp, err := c.PostAppEndpoint(ctx, organizationId, projectId, clusterId, appServiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppEndpointResp(rsp)
}

// DeleteAccessFunctionWithResponse request returning *DeleteAccessFunctionResp
func (c *ClientWithResponses) DeleteAccessFunctionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*DeleteAccessFunctionResp, error) {
	rsp, err := c.DeleteAccessFunction(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointKeyspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccessFunctionResp(rsp)
}

// GetAccessFunctionWithResponse request returning *GetAccessFunctionResp
func (c *ClientWithResponses) GetAccessFunctionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*GetAccessFunctionResp, error) {
	rsp, err := c.GetAccessFunction(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointKeyspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessFunctionResp(rsp)
}

// PutAccessFunctionWithBodyWithResponse request with arbitrary body returning *PutAccessFunctionResp
func (c *ClientWithResponses) PutAccessFunctionWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAccessFunctionResp, error) {
	rsp, err := c.PutAccessFunctionWithBody(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointKeyspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAccessFunctionResp(rsp)
}

// DeleteImportFilterWithResponse request returning *DeleteImportFilterResp
func (c *ClientWithResponses) DeleteImportFilterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*DeleteImportFilterResp, error) {
	rsp, err := c.DeleteImportFilter(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointKeyspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImportFilterResp(rsp)
}

// GetImportFilterWithResponse request returning *GetImportFilterResp
func (c *ClientWithResponses) GetImportFilterWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, reqEditors ...RequestEditorFn) (*GetImportFilterResp, error) {
	rsp, err := c.GetImportFilter(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointKeyspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImportFilterResp(rsp)
}

// PutImportFilterWithBodyWithResponse request with arbitrary body returning *PutImportFilterResp
func (c *ClientWithResponses) PutImportFilterWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointKeyspace AppEndpointKeyspace, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutImportFilterResp, error) {
	rsp, err := c.PutImportFilterWithBody(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointKeyspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutImportFilterResp(rsp)
}

// DeleteAppEndpointWithResponse request returning *DeleteAppEndpointResp
func (c *ClientWithResponses) DeleteAppEndpointWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*DeleteAppEndpointResp, error) {
	rsp, err := c.DeleteAppEndpoint(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppEndpointResp(rsp)
}

// GetAppEndpointWithResponse request returning *GetAppEndpointResp
func (c *ClientWithResponses) GetAppEndpointWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*GetAppEndpointResp, error) {
	rsp, err := c.GetAppEndpoint(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppEndpointResp(rsp)
}

// PutAppEndpointWithBodyWithResponse request with arbitrary body returning *PutAppEndpointResp
func (c *ClientWithResponses) PutAppEndpointWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAppEndpointResp, error) {
	rsp, err := c.PutAppEndpointWithBody(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAppEndpointResp(rsp)
}

func (c *ClientWithResponses) PutAppEndpointWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAppEndpointResp, error) {
	rsp, err := c.PutAppEndpoint(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAppEndpointResp(rsp)
}

// DeleteAppEndpointActivationStatusWithResponse request returning *DeleteAppEndpointActivationStatusResp
func (c *ClientWithResponses) DeleteAppEndpointActivationStatusWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*DeleteAppEndpointActivationStatusResp, error) {
	rsp, err := c.DeleteAppEndpointActivationStatus(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppEndpointActivationStatusResp(rsp)
}

// PostAppEndpointActivationStatusWithResponse request returning *PostAppEndpointActivationStatusResp
func (c *ClientWithResponses) PostAppEndpointActivationStatusWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*PostAppEndpointActivationStatusResp, error) {
	rsp, err := c.PostAppEndpointActivationStatus(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppEndpointActivationStatusResp(rsp)
}

// ListAppEndpointAdminUsersWithResponse request returning *ListAppEndpointAdminUsersResp
func (c *ClientWithResponses) ListAppEndpointAdminUsersWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointAdminUsersParams, reqEditors ...RequestEditorFn) (*ListAppEndpointAdminUsersResp, error) {
	rsp, err := c.ListAppEndpointAdminUsers(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppEndpointAdminUsersResp(rsp)
}

// GetAppEndpointAuditLogConfigWithResponse request returning *GetAppEndpointAuditLogConfigResp
func (c *ClientWithResponses) GetAppEndpointAuditLogConfigWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*GetAppEndpointAuditLogConfigResp, error) {
	rsp, err := c.GetAppEndpointAuditLogConfig(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppEndpointAuditLogConfigResp(rsp)
}

// PutAppEndpointAuditLogConfigWithBodyWithResponse request with arbitrary body returning *PutAppEndpointAuditLogConfigResp
func (c *ClientWithResponses) PutAppEndpointAuditLogConfigWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAppEndpointAuditLogConfigResp, error) {
	rsp, err := c.PutAppEndpointAuditLogConfigWithBody(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAppEndpointAuditLogConfigResp(rsp)
}

func (c *ClientWithResponses) PutAppEndpointAuditLogConfigWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointAuditLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAppEndpointAuditLogConfigResp, error) {
	rsp, err := c.PutAppEndpointAuditLogConfig(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAppEndpointAuditLogConfigResp(rsp)
}

// GetAppServiceAuditLogEventsWithResponse request returning *GetAppServiceAuditLogEventsResp
func (c *ClientWithResponses) GetAppServiceAuditLogEventsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*GetAppServiceAuditLogEventsResp, error) {
	rsp, err := c.GetAppServiceAuditLogEvents(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppServiceAuditLogEventsResp(rsp)
}

// ListAppEndpointCollectionsWithResponse request returning *ListAppEndpointCollectionsResp
func (c *ClientWithResponses) ListAppEndpointCollectionsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointCollectionsParams, reqEditors ...RequestEditorFn) (*ListAppEndpointCollectionsResp, error) {
	rsp, err := c.ListAppEndpointCollections(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppEndpointCollectionsResp(rsp)
}

// GetAppEndpointCORSWithResponse request returning *GetAppEndpointCORSResp
func (c *ClientWithResponses) GetAppEndpointCORSWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*GetAppEndpointCORSResp, error) {
	rsp, err := c.GetAppEndpointCORS(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppEndpointCORSResp(rsp)
}

// PutAppEndpointCORSWithBodyWithResponse request with arbitrary body returning *PutAppEndpointCORSResp
func (c *ClientWithResponses) PutAppEndpointCORSWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAppEndpointCORSResp, error) {
	rsp, err := c.PutAppEndpointCORSWithBody(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAppEndpointCORSResp(rsp)
}

func (c *ClientWithResponses) PutAppEndpointCORSWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PutAppEndpointCORSJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAppEndpointCORSResp, error) {
	rsp, err := c.PutAppEndpointCORS(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAppEndpointCORSResp(rsp)
}

// ListAppEndpointOIDCProvidersWithResponse request returning *ListAppEndpointOIDCProvidersResp
func (c *ClientWithResponses) ListAppEndpointOIDCProvidersWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, params *ListAppEndpointOIDCProvidersParams, reqEditors ...RequestEditorFn) (*ListAppEndpointOIDCProvidersResp, error) {
	rsp, err := c.ListAppEndpointOIDCProviders(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppEndpointOIDCProvidersResp(rsp)
}

// CreateAppEndpointOIDCProviderWithBodyWithResponse request with arbitrary body returning *CreateAppEndpointOIDCProviderResp
func (c *ClientWithResponses) CreateAppEndpointOIDCProviderWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppEndpointOIDCProviderResp, error) {
	rsp, err := c.CreateAppEndpointOIDCProviderWithBody(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppEndpointOIDCProviderResp(rsp)
}

func (c *ClientWithResponses) CreateAppEndpointOIDCProviderWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body CreateAppEndpointOIDCProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppEndpointOIDCProviderResp, error) {
	rsp, err := c.CreateAppEndpointOIDCProvider(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppEndpointOIDCProviderResp(rsp)
}

// UpdateAppEndpointOIDCDefaultProviderWithBodyWithResponse request with arbitrary body returning *UpdateAppEndpointOIDCDefaultProviderResp
func (c *ClientWithResponses) UpdateAppEndpointOIDCDefaultProviderWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppEndpointOIDCDefaultProviderResp, error) {
	rsp, err := c.UpdateAppEndpointOIDCDefaultProviderWithBody(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppEndpointOIDCDefaultProviderResp(rsp)
}

func (c *ClientWithResponses) UpdateAppEndpointOIDCDefaultProviderWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body UpdateAppEndpointOIDCDefaultProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppEndpointOIDCDefaultProviderResp, error) {
	rsp, err := c.UpdateAppEndpointOIDCDefaultProvider(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppEndpointOIDCDefaultProviderResp(rsp)
}

// DeleteAppEndpointOIDCProviderWithResponse request returning *DeleteAppEndpointOIDCProviderResp
func (c *ClientWithResponses) DeleteAppEndpointOIDCProviderWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, reqEditors ...RequestEditorFn) (*DeleteAppEndpointOIDCProviderResp, error) {
	rsp, err := c.DeleteAppEndpointOIDCProvider(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, oidcProviderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppEndpointOIDCProviderResp(rsp)
}

// GetAppEndpointOIDCProviderWithResponse request returning *GetAppEndpointOIDCProviderResp
func (c *ClientWithResponses) GetAppEndpointOIDCProviderWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, reqEditors ...RequestEditorFn) (*GetAppEndpointOIDCProviderResp, error) {
	rsp, err := c.GetAppEndpointOIDCProvider(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, oidcProviderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppEndpointOIDCProviderResp(rsp)
}

// UpdateAppEndpointOIDCProviderWithBodyWithResponse request with arbitrary body returning *UpdateAppEndpointOIDCProviderResp
func (c *ClientWithResponses) UpdateAppEndpointOIDCProviderWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppEndpointOIDCProviderResp, error) {
	rsp, err := c.UpdateAppEndpointOIDCProviderWithBody(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, oidcProviderId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppEndpointOIDCProviderResp(rsp)
}

func (c *ClientWithResponses) UpdateAppEndpointOIDCProviderWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, oidcProviderId OIDCProviderId, body UpdateAppEndpointOIDCProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppEndpointOIDCProviderResp, error) {
	rsp, err := c.UpdateAppEndpointOIDCProvider(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, oidcProviderId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppEndpointOIDCProviderResp(rsp)
}

// DeleteAppEndpointResyncWithResponse request returning *DeleteAppEndpointResyncResp
func (c *ClientWithResponses) DeleteAppEndpointResyncWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*DeleteAppEndpointResyncResp, error) {
	rsp, err := c.DeleteAppEndpointResync(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppEndpointResyncResp(rsp)
}

// GetAppEndpointResyncWithResponse request returning *GetAppEndpointResyncResp
func (c *ClientWithResponses) GetAppEndpointResyncWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, reqEditors ...RequestEditorFn) (*GetAppEndpointResyncResp, error) {
	rsp, err := c.GetAppEndpointResync(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppEndpointResyncResp(rsp)
}

// PostAppEndpointResyncWithBodyWithResponse request with arbitrary body returning *PostAppEndpointResyncResp
func (c *ClientWithResponses) PostAppEndpointResyncWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppEndpointResyncResp, error) {
	rsp, err := c.PostAppEndpointResyncWithBody(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppEndpointResyncResp(rsp)
}

func (c *ClientWithResponses) PostAppEndpointResyncWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, appEndpointName AppEndpointId, body PostAppEndpointResyncJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppEndpointResyncResp, error) {
	rsp, err := c.PostAppEndpointResync(ctx, organizationId, projectId, clusterId, appServiceId, appEndpointName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppEndpointResyncResp(rsp)
}

// GetAppServiceAuditLogStateWithResponse request returning *GetAppServiceAuditLogStateResp
func (c *ClientWithResponses) GetAppServiceAuditLogStateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*GetAppServiceAuditLogStateResp, error) {
	rsp, err := c.GetAppServiceAuditLogState(ctx, organizationId, projectId, clusterId, appServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppServiceAuditLogStateResp(rsp)
}

// PutAppServiceAuditLogStateWithBodyWithResponse request with arbitrary body returning *PutAppServiceAuditLogStateResp
func (c *ClientWithResponses) PutAppServiceAuditLogStateWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAppServiceAuditLogStateResp, error) {
	rsp, err := c.PutAppServiceAuditLogStateWithBody(ctx, organizationId, projectId, clusterId, appServiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAppServiceAuditLogStateResp(rsp)
}

func (c *ClientWithResponses) PutAppServiceAuditLogStateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PutAppServiceAuditLogStateJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAppServiceAuditLogStateResp, error) {
	rsp, err := c.PutAppServiceAuditLogState(ctx, organizationId, projectId, clusterId, appServiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAppServiceAuditLogStateResp(rsp)
}

// ListAppServiceAuditLogExportsWithResponse request returning *ListAppServiceAuditLogExportsResp
func (c *ClientWithResponses) ListAppServiceAuditLogExportsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, params *ListAppServiceAuditLogExportsParams, reqEditors ...RequestEditorFn) (*ListAppServiceAuditLogExportsResp, error) {
	rsp, err := c.ListAppServiceAuditLogExports(ctx, organizationId, projectId, clusterId, appServiceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppServiceAuditLogExportsResp(rsp)
}

// PostAppServiceAuditLogExportWithBodyWithResponse request with arbitrary body returning *PostAppServiceAuditLogExportResp
func (c *ClientWithResponses) PostAppServiceAuditLogExportWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppServiceAuditLogExportResp, error) {
	rsp, err := c.PostAppServiceAuditLogExportWithBody(ctx, organizationId, projectId, clusterId, appServiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppServiceAuditLogExportResp(rsp)
}

func (c *ClientWithResponses) PostAppServiceAuditLogExportWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PostAppServiceAuditLogExportJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppServiceAuditLogExportResp, error) {
	rsp, err := c.PostAppServiceAuditLogExport(ctx, organizationId, projectId, clusterId, appServiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppServiceAuditLogExportResp(rsp)
}

// GetAppServiceAuditLogExportByIdWithResponse request returning *GetAppServiceAuditLogExportByIdResp
func (c *ClientWithResponses) GetAppServiceAuditLogExportByIdWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, auditLogExportId AuditLogExportId, reqEditors ...RequestEditorFn) (*GetAppServiceAuditLogExportByIdResp, error) {
	rsp, err := c.GetAppServiceAuditLogExportById(ctx, organizationId, projectId, clusterId, appServiceId, auditLogExportId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppServiceAuditLogExportByIdResp(rsp)
}

// GetAppServiceAuditLogStreamingWithResponse request returning *GetAppServiceAuditLogStreamingResp
func (c *ClientWithResponses) GetAppServiceAuditLogStreamingWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*GetAppServiceAuditLogStreamingResp, error) {
	rsp, err := c.GetAppServiceAuditLogStreaming(ctx, organizationId, projectId, clusterId, appServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppServiceAuditLogStreamingResp(rsp)
}

// PatchAppServiceAuditLogStreamingWithBodyWithResponse request with arbitrary body returning *PatchAppServiceAuditLogStreamingResp
func (c *ClientWithResponses) PatchAppServiceAuditLogStreamingWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAppServiceAuditLogStreamingResp, error) {
	rsp, err := c.PatchAppServiceAuditLogStreamingWithBody(ctx, organizationId, projectId, clusterId, appServiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAppServiceAuditLogStreamingResp(rsp)
}

func (c *ClientWithResponses) PatchAppServiceAuditLogStreamingWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PatchAppServiceAuditLogStreamingJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAppServiceAuditLogStreamingResp, error) {
	rsp, err := c.PatchAppServiceAuditLogStreaming(ctx, organizationId, projectId, clusterId, appServiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAppServiceAuditLogStreamingResp(rsp)
}

// PutAppServiceAuditLogStreamingWithBodyWithResponse request with arbitrary body returning *PutAppServiceAuditLogStreamingResp
func (c *ClientWithResponses) PutAppServiceAuditLogStreamingWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAppServiceAuditLogStreamingResp, error) {
	rsp, err := c.PutAppServiceAuditLogStreamingWithBody(ctx, organizationId, projectId, clusterId, appServiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAppServiceAuditLogStreamingResp(rsp)
}

func (c *ClientWithResponses) PutAppServiceAuditLogStreamingWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body PutAppServiceAuditLogStreamingJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAppServiceAuditLogStreamingResp, error) {
	rsp, err := c.PutAppServiceAuditLogStreaming(ctx, organizationId, projectId, clusterId, appServiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAppServiceAuditLogStreamingResp(rsp)
}

// GetAppServiceCertificateWithResponse request returning *GetAppServiceCertificateResp
func (c *ClientWithResponses) GetAppServiceCertificateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*GetAppServiceCertificateResp, error) {
	rsp, err := c.GetAppServiceCertificate(ctx, organizationId, projectId, clusterId, appServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppServiceCertificateResp(rsp)
}

// DeleteAppServicePrivateEndpointsWithResponse request returning *DeleteAppServicePrivateEndpointsResp
func (c *ClientWithResponses) DeleteAppServicePrivateEndpointsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*DeleteAppServicePrivateEndpointsResp, error) {
	rsp, err := c.DeleteAppServicePrivateEndpoints(ctx, organizationId, projectId, clusterId, appServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppServicePrivateEndpointsResp(rsp)
}

// GetAppServicePrivateEndpointsWithResponse request returning *GetAppServicePrivateEndpointsResp
func (c *ClientWithResponses) GetAppServicePrivateEndpointsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*GetAppServicePrivateEndpointsResp, error) {
	rsp, err := c.GetAppServicePrivateEndpoints(ctx, organizationId, projectId, clusterId, appServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppServicePrivateEndpointsResp(rsp)
}

// PostAppServicePrivateEndpointsWithResponse request returning *PostAppServicePrivateEndpointsResp
func (c *ClientWithResponses) PostAppServicePrivateEndpointsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*PostAppServicePrivateEndpointsResp, error) {
	rsp, err := c.PostAppServicePrivateEndpoints(ctx, organizationId, projectId, clusterId, appServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppServicePrivateEndpointsResp(rsp)
}

// ListAppServicePrivateEndpointsWithResponse request returning *ListAppServicePrivateEndpointsResp
func (c *ClientWithResponses) ListAppServicePrivateEndpointsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, reqEditors ...RequestEditorFn) (*ListAppServicePrivateEndpointsResp, error) {
	rsp, err := c.ListAppServicePrivateEndpoints(ctx, organizationId, projectId, clusterId, appServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppServicePrivateEndpointsResp(rsp)
}

// DeletePrivateEndpointRequestWithResponse request returning *DeletePrivateEndpointRequestResp
func (c *ClientWithResponses) DeletePrivateEndpointRequestWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*DeletePrivateEndpointRequestResp, error) {
	rsp, err := c.DeletePrivateEndpointRequest(ctx, organizationId, projectId, clusterId, appServiceId, endpointId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePrivateEndpointRequestResp(rsp)
}

// AcceptPrivateEndpointRequestWithResponse request returning *AcceptPrivateEndpointRequestResp
func (c *ClientWithResponses) AcceptPrivateEndpointRequestWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*AcceptPrivateEndpointRequestResp, error) {
	rsp, err := c.AcceptPrivateEndpointRequest(ctx, organizationId, projectId, clusterId, appServiceId, endpointId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptPrivateEndpointRequestResp(rsp)
}

// GetAppServicePrivateEndpointsCommandWithBodyWithResponse request with arbitrary body returning *GetAppServicePrivateEndpointsCommandResp
func (c *ClientWithResponses) GetAppServicePrivateEndpointsCommandWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetAppServicePrivateEndpointsCommandResp, error) {
	rsp, err := c.GetAppServicePrivateEndpointsCommandWithBody(ctx, organizationId, projectId, clusterId, appServiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppServicePrivateEndpointsCommandResp(rsp)
}

func (c *ClientWithResponses) GetAppServicePrivateEndpointsCommandWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, appServiceId AppServiceId, body GetAppServicePrivateEndpointsCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*GetAppServicePrivateEndpointsCommandResp, error) {
	rsp, err := c.GetAppServicePrivateEndpointsCommand(ctx, organizationId, projectId, clusterId, appServiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppServicePrivateEndpointsCommandResp(rsp)
}

// GetClusterAuditSettingsWithResponse request returning *GetClusterAuditSettingsResp
func (c *ClientWithResponses) GetClusterAuditSettingsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetClusterAuditSettingsResp, error) {
	rsp, err := c.GetClusterAuditSettings(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterAuditSettingsResp(rsp)
}

// PutClusterAuditSettingsWithBodyWithResponse request with arbitrary body returning *PutClusterAuditSettingsResp
func (c *ClientWithResponses) PutClusterAuditSettingsWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutClusterAuditSettingsResp, error) {
	rsp, err := c.PutClusterAuditSettingsWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutClusterAuditSettingsResp(rsp)
}

func (c *ClientWithResponses) PutClusterAuditSettingsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutClusterAuditSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PutClusterAuditSettingsResp, error) {
	rsp, err := c.PutClusterAuditSettings(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutClusterAuditSettingsResp(rsp)
}

// GetAuditLogEventIDsWithResponse request returning *GetAuditLogEventIDsResp
func (c *ClientWithResponses) GetAuditLogEventIDsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetAuditLogEventIDsResp, error) {
	rsp, err := c.GetAuditLogEventIDs(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuditLogEventIDsResp(rsp)
}

// ListAuditLogExportsWithResponse request returning *ListAuditLogExportsResp
func (c *ClientWithResponses) ListAuditLogExportsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListAuditLogExportsParams, reqEditors ...RequestEditorFn) (*ListAuditLogExportsResp, error) {
	rsp, err := c.ListAuditLogExports(ctx, organizationId, projectId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuditLogExportsResp(rsp)
}

// PostAuditLogExportWithBodyWithResponse request with arbitrary body returning *PostAuditLogExportResp
func (c *ClientWithResponses) PostAuditLogExportWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuditLogExportResp, error) {
	rsp, err := c.PostAuditLogExportWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuditLogExportResp(rsp)
}

func (c *ClientWithResponses) PostAuditLogExportWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostAuditLogExportJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuditLogExportResp, error) {
	rsp, err := c.PostAuditLogExport(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuditLogExportResp(rsp)
}

// GetAuditLogExportWithResponse request returning *GetAuditLogExportResp
func (c *ClientWithResponses) GetAuditLogExportWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, auditLogExportId AuditLogExportId, reqEditors ...RequestEditorFn) (*GetAuditLogExportResp, error) {
	rsp, err := c.GetAuditLogExport(ctx, organizationId, projectId, clusterId, auditLogExportId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuditLogExportResp(rsp)
}

// ListClusterBackupsWithResponse request returning *ListClusterBackupsResp
func (c *ClientWithResponses) ListClusterBackupsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListClusterBackupsResp, error) {
	rsp, err := c.ListClusterBackups(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClusterBackupsResp(rsp)
}

// DeleteBackupCycleByIDWithResponse request returning *DeleteBackupCycleByIDResp
func (c *ClientWithResponses) DeleteBackupCycleByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*DeleteBackupCycleByIDResp, error) {
	rsp, err := c.DeleteBackupCycleByID(ctx, organizationId, projectId, clusterId, backupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackupCycleByIDResp(rsp)
}

// GetBackupByIDWithResponse request returning *GetBackupByIDResp
func (c *ClientWithResponses) GetBackupByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*GetBackupByIDResp, error) {
	rsp, err := c.GetBackupByID(ctx, organizationId, projectId, clusterId, backupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupByIDResp(rsp)
}

// PostRestoreWithBodyWithResponse request with arbitrary body returning *PostRestoreResp
func (c *ClientWithResponses) PostRestoreWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRestoreResp, error) {
	rsp, err := c.PostRestoreWithBody(ctx, organizationId, projectId, clusterId, backupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRestoreResp(rsp)
}

func (c *ClientWithResponses) PostRestoreWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body PostRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRestoreResp, error) {
	rsp, err := c.PostRestore(ctx, organizationId, projectId, clusterId, backupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRestoreResp(rsp)
}

// PutBucketStorageBackendWithBodyWithResponse request with arbitrary body returning *PutBucketStorageBackendResp
func (c *ClientWithResponses) PutBucketStorageBackendWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutBucketStorageBackendResp, error) {
	rsp, err := c.PutBucketStorageBackendWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutBucketStorageBackendResp(rsp)
}

func (c *ClientWithResponses) PutBucketStorageBackendWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutBucketStorageBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*PutBucketStorageBackendResp, error) {
	rsp, err := c.PutBucketStorageBackend(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutBucketStorageBackendResp(rsp)
}

// ListBucketsWithResponse request returning *ListBucketsResp
func (c *ClientWithResponses) ListBucketsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListBucketsResp, error) {
	rsp, err := c.ListBuckets(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBucketsResp(rsp)
}

// PostBucketWithBodyWithResponse request with arbitrary body returning *PostBucketResp
func (c *ClientWithResponses) PostBucketWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBucketResp, error) {
	rsp, err := c.PostBucketWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBucketResp(rsp)
}

func (c *ClientWithResponses) PostBucketWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBucketResp, error) {
	rsp, err := c.PostBucket(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBucketResp(rsp)
}

// ListFreeTierBucketsWithResponse request returning *ListFreeTierBucketsResp
func (c *ClientWithResponses) ListFreeTierBucketsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListFreeTierBucketsResp, error) {
	rsp, err := c.ListFreeTierBuckets(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFreeTierBucketsResp(rsp)
}

// CreateFreeTierBucketWithBodyWithResponse request with arbitrary body returning *CreateFreeTierBucketResp
func (c *ClientWithResponses) CreateFreeTierBucketWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFreeTierBucketResp, error) {
	rsp, err := c.CreateFreeTierBucketWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFreeTierBucketResp(rsp)
}

func (c *ClientWithResponses) CreateFreeTierBucketWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateFreeTierBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFreeTierBucketResp, error) {
	rsp, err := c.CreateFreeTierBucket(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFreeTierBucketResp(rsp)
}

// DeleteFreeTierBucketByIDWithResponse request returning *DeleteFreeTierBucketByIDResp
func (c *ClientWithResponses) DeleteFreeTierBucketByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*DeleteFreeTierBucketByIDResp, error) {
	rsp, err := c.DeleteFreeTierBucketByID(ctx, organizationId, projectId, clusterId, bucketId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFreeTierBucketByIDResp(rsp)
}

// GetFreeTierBucketByIDWithResponse request returning *GetFreeTierBucketByIDResp
func (c *ClientWithResponses) GetFreeTierBucketByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*GetFreeTierBucketByIDResp, error) {
	rsp, err := c.GetFreeTierBucketByID(ctx, organizationId, projectId, clusterId, bucketId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFreeTierBucketByIDResp(rsp)
}

// UpdateFreeTierBucketWithBodyWithResponse request with arbitrary body returning *UpdateFreeTierBucketResp
func (c *ClientWithResponses) UpdateFreeTierBucketWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFreeTierBucketResp, error) {
	rsp, err := c.UpdateFreeTierBucketWithBody(ctx, organizationId, projectId, clusterId, bucketId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFreeTierBucketResp(rsp)
}

func (c *ClientWithResponses) UpdateFreeTierBucketWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body UpdateFreeTierBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFreeTierBucketResp, error) {
	rsp, err := c.UpdateFreeTierBucket(ctx, organizationId, projectId, clusterId, bucketId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFreeTierBucketResp(rsp)
}

// DeleteBucketByIDWithResponse request returning *DeleteBucketByIDResp
func (c *ClientWithResponses) DeleteBucketByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*DeleteBucketByIDResp, error) {
	rsp, err := c.DeleteBucketByID(ctx, organizationId, projectId, clusterId, bucketId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBucketByIDResp(rsp)
}

// GetBucketByIDWithResponse request returning *GetBucketByIDResp
func (c *ClientWithResponses) GetBucketByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*GetBucketByIDResp, error) {
	rsp, err := c.GetBucketByID(ctx, organizationId, projectId, clusterId, bucketId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBucketByIDResp(rsp)
}

// PutBucketWithBodyWithResponse request with arbitrary body returning *PutBucketResp
func (c *ClientWithResponses) PutBucketWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutBucketResp, error) {
	rsp, err := c.PutBucketWithBody(ctx, organizationId, projectId, clusterId, bucketId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutBucketResp(rsp)
}

func (c *ClientWithResponses) PutBucketWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PutBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*PutBucketResp, error) {
	rsp, err := c.PutBucket(ctx, organizationId, projectId, clusterId, bucketId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutBucketResp(rsp)
}

// ListCyclesWithResponse request returning *ListCyclesResp
func (c *ClientWithResponses) ListCyclesWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, params *ListCyclesParams, reqEditors ...RequestEditorFn) (*ListCyclesResp, error) {
	rsp, err := c.ListCycles(ctx, organizationId, projectId, clusterId, bucketId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCyclesResp(rsp)
}

// ListBackupsWithResponse request returning *ListBackupsResp
func (c *ClientWithResponses) ListBackupsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, cycleId CycleId, reqEditors ...RequestEditorFn) (*ListBackupsResp, error) {
	rsp, err := c.ListBackups(ctx, organizationId, projectId, clusterId, bucketId, cycleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBackupsResp(rsp)
}

// DeleteBackupScheduleWithResponse request returning *DeleteBackupScheduleResp
func (c *ClientWithResponses) DeleteBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*DeleteBackupScheduleResp, error) {
	rsp, err := c.DeleteBackupSchedule(ctx, organizationId, projectId, clusterId, bucketId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackupScheduleResp(rsp)
}

// GetBackupScheduleWithResponse request returning *GetBackupScheduleResp
func (c *ClientWithResponses) GetBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*GetBackupScheduleResp, error) {
	rsp, err := c.GetBackupSchedule(ctx, organizationId, projectId, clusterId, bucketId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupScheduleResp(rsp)
}

// PostBackupScheduleWithBodyWithResponse request with arbitrary body returning *PostBackupScheduleResp
func (c *ClientWithResponses) PostBackupScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBackupScheduleResp, error) {
	rsp, err := c.PostBackupScheduleWithBody(ctx, organizationId, projectId, clusterId, bucketId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBackupScheduleResp(rsp)
}

func (c *ClientWithResponses) PostBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PostBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBackupScheduleResp, error) {
	rsp, err := c.PostBackupSchedule(ctx, organizationId, projectId, clusterId, bucketId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBackupScheduleResp(rsp)
}

// PutBackupScheduleWithBodyWithResponse request with arbitrary body returning *PutBackupScheduleResp
func (c *ClientWithResponses) PutBackupScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutBackupScheduleResp, error) {
	rsp, err := c.PutBackupScheduleWithBody(ctx, organizationId, projectId, clusterId, bucketId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutBackupScheduleResp(rsp)
}

func (c *ClientWithResponses) PutBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PutBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PutBackupScheduleResp, error) {
	rsp, err := c.PutBackupSchedule(ctx, organizationId, projectId, clusterId, bucketId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutBackupScheduleResp(rsp)
}

// PostBackupWithResponse request returning *PostBackupResp
func (c *ClientWithResponses) PostBackupWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*PostBackupResp, error) {
	rsp, err := c.PostBackup(ctx, organizationId, projectId, clusterId, bucketId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBackupResp(rsp)
}

// FlushBucketWithResponse request returning *FlushBucketResp
func (c *ClientWithResponses) FlushBucketWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*FlushBucketResp, error) {
	rsp, err := c.FlushBucket(ctx, organizationId, projectId, clusterId, bucketId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFlushBucketResp(rsp)
}

// GetScopesWithResponse request returning *GetScopesResp
func (c *ClientWithResponses) GetScopesWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*GetScopesResp, error) {
	rsp, err := c.GetScopes(ctx, organizationId, projectId, clusterId, bucketId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScopesResp(rsp)
}

// PostScopeWithBodyWithResponse request with arbitrary body returning *PostScopeResp
func (c *ClientWithResponses) PostScopeWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostScopeResp, error) {
	rsp, err := c.PostScopeWithBody(ctx, organizationId, projectId, clusterId, bucketId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostScopeResp(rsp)
}

func (c *ClientWithResponses) PostScopeWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, body PostScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostScopeResp, error) {
	rsp, err := c.PostScope(ctx, organizationId, projectId, clusterId, bucketId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostScopeResp(rsp)
}

// DeleteScopeByNameWithResponse request returning *DeleteScopeByNameResp
func (c *ClientWithResponses) DeleteScopeByNameWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, reqEditors ...RequestEditorFn) (*DeleteScopeByNameResp, error) {
	rsp, err := c.DeleteScopeByName(ctx, organizationId, projectId, clusterId, bucketId, scopeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScopeByNameResp(rsp)
}

// GetScopeByNameWithResponse request returning *GetScopeByNameResp
func (c *ClientWithResponses) GetScopeByNameWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, reqEditors ...RequestEditorFn) (*GetScopeByNameResp, error) {
	rsp, err := c.GetScopeByName(ctx, organizationId, projectId, clusterId, bucketId, scopeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScopeByNameResp(rsp)
}

// GetCollectionsWithResponse request returning *GetCollectionsResp
func (c *ClientWithResponses) GetCollectionsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, reqEditors ...RequestEditorFn) (*GetCollectionsResp, error) {
	rsp, err := c.GetCollections(ctx, organizationId, projectId, clusterId, bucketId, scopeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionsResp(rsp)
}

// PostCollectionWithBodyWithResponse request with arbitrary body returning *PostCollectionResp
func (c *ClientWithResponses) PostCollectionWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCollectionResp, error) {
	rsp, err := c.PostCollectionWithBody(ctx, organizationId, projectId, clusterId, bucketId, scopeName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCollectionResp(rsp)
}

func (c *ClientWithResponses) PostCollectionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, body PostCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCollectionResp, error) {
	rsp, err := c.PostCollection(ctx, organizationId, projectId, clusterId, bucketId, scopeName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCollectionResp(rsp)
}

// DeleteCollectionByNameWithResponse request returning *DeleteCollectionByNameResp
func (c *ClientWithResponses) DeleteCollectionByNameWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, reqEditors ...RequestEditorFn) (*DeleteCollectionByNameResp, error) {
	rsp, err := c.DeleteCollectionByName(ctx, organizationId, projectId, clusterId, bucketId, scopeName, collectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCollectionByNameResp(rsp)
}

// GetCollectionByNameWithResponse request returning *GetCollectionByNameResp
func (c *ClientWithResponses) GetCollectionByNameWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, reqEditors ...RequestEditorFn) (*GetCollectionByNameResp, error) {
	rsp, err := c.GetCollectionByName(ctx, organizationId, projectId, clusterId, bucketId, scopeName, collectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionByNameResp(rsp)
}

// PutCollectionWithBodyWithResponse request with arbitrary body returning *PutCollectionResp
func (c *ClientWithResponses) PutCollectionWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutCollectionResp, error) {
	rsp, err := c.PutCollectionWithBody(ctx, organizationId, projectId, clusterId, bucketId, scopeName, collectionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutCollectionResp(rsp)
}

func (c *ClientWithResponses) PutCollectionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, scopeName ScopeName, collectionName CollectionName, body PutCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PutCollectionResp, error) {
	rsp, err := c.PutCollection(ctx, organizationId, projectId, clusterId, bucketId, scopeName, collectionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutCollectionResp(rsp)
}

// GetCertificateWithResponse request returning *GetCertificateResp
func (c *ClientWithResponses) GetCertificateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetCertificateResp, error) {
	rsp, err := c.GetCertificate(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertificateResp(rsp)
}

// ListCloudSnapshotBackupsWithResponse request returning *ListCloudSnapshotBackupsResp
func (c *ClientWithResponses) ListCloudSnapshotBackupsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListCloudSnapshotBackupsParams, reqEditors ...RequestEditorFn) (*ListCloudSnapshotBackupsResp, error) {
	rsp, err := c.ListCloudSnapshotBackups(ctx, organizationId, projectId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCloudSnapshotBackupsResp(rsp)
}

// CreateCloudSnapshotBackupWithBodyWithResponse request with arbitrary body returning *CreateCloudSnapshotBackupResp
func (c *ClientWithResponses) CreateCloudSnapshotBackupWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCloudSnapshotBackupResp, error) {
	rsp, err := c.CreateCloudSnapshotBackupWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCloudSnapshotBackupResp(rsp)
}

func (c *ClientWithResponses) CreateCloudSnapshotBackupWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateCloudSnapshotBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCloudSnapshotBackupResp, error) {
	rsp, err := c.CreateCloudSnapshotBackup(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCloudSnapshotBackupResp(rsp)
}

// ListGeographicRegionsWithResponse request returning *ListGeographicRegionsResp
func (c *ClientWithResponses) ListGeographicRegionsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListGeographicRegionsResp, error) {
	rsp, err := c.ListGeographicRegions(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGeographicRegionsResp(rsp)
}

// ListCloudSnapshotRestoresWithResponse request returning *ListCloudSnapshotRestoresResp
func (c *ClientWithResponses) ListCloudSnapshotRestoresWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListCloudSnapshotRestoresParams, reqEditors ...RequestEditorFn) (*ListCloudSnapshotRestoresResp, error) {
	rsp, err := c.ListCloudSnapshotRestores(ctx, organizationId, projectId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCloudSnapshotRestoresResp(rsp)
}

// DeleteCloudSnapshotBackupWithResponse request returning *DeleteCloudSnapshotBackupResp
func (c *ClientWithResponses) DeleteCloudSnapshotBackupWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, reqEditors ...RequestEditorFn) (*DeleteCloudSnapshotBackupResp, error) {
	rsp, err := c.DeleteCloudSnapshotBackup(ctx, organizationId, projectId, clusterId, backupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCloudSnapshotBackupResp(rsp)
}

// EditCloudSnapshotBackupRetentionWithBodyWithResponse request with arbitrary body returning *EditCloudSnapshotBackupRetentionResp
func (c *ClientWithResponses) EditCloudSnapshotBackupRetentionWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCloudSnapshotBackupRetentionResp, error) {
	rsp, err := c.EditCloudSnapshotBackupRetentionWithBody(ctx, organizationId, projectId, clusterId, backupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCloudSnapshotBackupRetentionResp(rsp)
}

func (c *ClientWithResponses) EditCloudSnapshotBackupRetentionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body EditCloudSnapshotBackupRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCloudSnapshotBackupRetentionResp, error) {
	rsp, err := c.EditCloudSnapshotBackupRetention(ctx, organizationId, projectId, clusterId, backupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCloudSnapshotBackupRetentionResp(rsp)
}

// RestoreWithBodyWithResponse request with arbitrary body returning *RestoreResp
func (c *ClientWithResponses) RestoreWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreResp, error) {
	rsp, err := c.RestoreWithBody(ctx, organizationId, projectId, clusterId, backupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreResp(rsp)
}

func (c *ClientWithResponses) RestoreWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, backupId BackupId, body RestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreResp, error) {
	rsp, err := c.Restore(ctx, organizationId, projectId, clusterId, backupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreResp(rsp)
}

// DeleteCloudSnapshotBackupScheduleWithResponse request returning *DeleteCloudSnapshotBackupScheduleResp
func (c *ClientWithResponses) DeleteCloudSnapshotBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*DeleteCloudSnapshotBackupScheduleResp, error) {
	rsp, err := c.DeleteCloudSnapshotBackupSchedule(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCloudSnapshotBackupScheduleResp(rsp)
}

// GetCloudSnapshotBackupScheduleWithResponse request returning *GetCloudSnapshotBackupScheduleResp
func (c *ClientWithResponses) GetCloudSnapshotBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetCloudSnapshotBackupScheduleResp, error) {
	rsp, err := c.GetCloudSnapshotBackupSchedule(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCloudSnapshotBackupScheduleResp(rsp)
}

// UpsertCloudSnapshotBackupScheduleWithBodyWithResponse request with arbitrary body returning *UpsertCloudSnapshotBackupScheduleResp
func (c *ClientWithResponses) UpsertCloudSnapshotBackupScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertCloudSnapshotBackupScheduleResp, error) {
	rsp, err := c.UpsertCloudSnapshotBackupScheduleWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertCloudSnapshotBackupScheduleResp(rsp)
}

func (c *ClientWithResponses) UpsertCloudSnapshotBackupScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpsertCloudSnapshotBackupScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertCloudSnapshotBackupScheduleResp, error) {
	rsp, err := c.UpsertCloudSnapshotBackupSchedule(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertCloudSnapshotBackupScheduleResp(rsp)
}

// AssociateCMEKWithResponse request returning *AssociateCMEKResp
func (c *ClientWithResponses) AssociateCMEKWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*AssociateCMEKResp, error) {
	rsp, err := c.AssociateCMEK(ctx, organizationId, projectId, clusterId, cmekId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssociateCMEKResp(rsp)
}

// UnassociateCMEKWithResponse request returning *UnassociateCMEKResp
func (c *ClientWithResponses) UnassociateCMEKWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, cmekId CMEKId, reqEditors ...RequestEditorFn) (*UnassociateCMEKResp, error) {
	rsp, err := c.UnassociateCMEK(ctx, organizationId, projectId, clusterId, cmekId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassociateCMEKResp(rsp)
}

// GetDataAPIStatusWithResponse request returning *GetDataAPIStatusResp
func (c *ClientWithResponses) GetDataAPIStatusWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetDataAPIStatusResp, error) {
	rsp, err := c.GetDataAPIStatus(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataAPIStatusResp(rsp)
}

// UpdateDataApiAndPeeringWithBodyWithResponse request with arbitrary body returning *UpdateDataApiAndPeeringResp
func (c *ClientWithResponses) UpdateDataApiAndPeeringWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDataApiAndPeeringResp, error) {
	rsp, err := c.UpdateDataApiAndPeeringWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDataApiAndPeeringResp(rsp)
}

func (c *ClientWithResponses) UpdateDataApiAndPeeringWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpdateDataApiAndPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDataApiAndPeeringResp, error) {
	rsp, err := c.UpdateDataApiAndPeering(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDataApiAndPeeringResp(rsp)
}

// GetDataAPIPrivateEndpointCommandWithBodyWithResponse request with arbitrary body returning *GetDataAPIPrivateEndpointCommandResp
func (c *ClientWithResponses) GetDataAPIPrivateEndpointCommandWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetDataAPIPrivateEndpointCommandResp, error) {
	rsp, err := c.GetDataAPIPrivateEndpointCommandWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataAPIPrivateEndpointCommandResp(rsp)
}

func (c *ClientWithResponses) GetDataAPIPrivateEndpointCommandWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetDataAPIPrivateEndpointCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*GetDataAPIPrivateEndpointCommandResp, error) {
	rsp, err := c.GetDataAPIPrivateEndpointCommand(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataAPIPrivateEndpointCommandResp(rsp)
}

// ListDataAPIPrivateEndpointsWithResponse request returning *ListDataAPIPrivateEndpointsResp
func (c *ClientWithResponses) ListDataAPIPrivateEndpointsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListDataAPIPrivateEndpointsResp, error) {
	rsp, err := c.ListDataAPIPrivateEndpoints(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDataAPIPrivateEndpointsResp(rsp)
}

// AssociateDataAPIPrivateEndpointRequestWithResponse request returning *AssociateDataAPIPrivateEndpointRequestResp
func (c *ClientWithResponses) AssociateDataAPIPrivateEndpointRequestWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*AssociateDataAPIPrivateEndpointRequestResp, error) {
	rsp, err := c.AssociateDataAPIPrivateEndpointRequest(ctx, organizationId, projectId, clusterId, endpointId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssociateDataAPIPrivateEndpointRequestResp(rsp)
}

// DisassociateDataAPIPrivateEndpointWithResponse request returning *DisassociateDataAPIPrivateEndpointResp
func (c *ClientWithResponses) DisassociateDataAPIPrivateEndpointWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*DisassociateDataAPIPrivateEndpointResp, error) {
	rsp, err := c.DisassociateDataAPIPrivateEndpoint(ctx, organizationId, projectId, clusterId, endpointId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisassociateDataAPIPrivateEndpointResp(rsp)
}

// ListMtlsCertificatesWithResponse request returning *ListMtlsCertificatesResp
func (c *ClientWithResponses) ListMtlsCertificatesWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListMtlsCertificatesParams, reqEditors ...RequestEditorFn) (*ListMtlsCertificatesResp, error) {
	rsp, err := c.ListMtlsCertificates(ctx, organizationId, projectId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMtlsCertificatesResp(rsp)
}

// AddMtlsCertificateWithBodyWithResponse request with arbitrary body returning *AddMtlsCertificateResp
func (c *ClientWithResponses) AddMtlsCertificateWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMtlsCertificateResp, error) {
	rsp, err := c.AddMtlsCertificateWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMtlsCertificateResp(rsp)
}

func (c *ClientWithResponses) AddMtlsCertificateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body AddMtlsCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMtlsCertificateResp, error) {
	rsp, err := c.AddMtlsCertificate(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMtlsCertificateResp(rsp)
}

// DeleteMtlsCertificateWithResponse request returning *DeleteMtlsCertificateResp
func (c *ClientWithResponses) DeleteMtlsCertificateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, reqEditors ...RequestEditorFn) (*DeleteMtlsCertificateResp, error) {
	rsp, err := c.DeleteMtlsCertificate(ctx, organizationId, projectId, clusterId, certId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMtlsCertificateResp(rsp)
}

// GetMtlsCertificateWithResponse request returning *GetMtlsCertificateResp
func (c *ClientWithResponses) GetMtlsCertificateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, reqEditors ...RequestEditorFn) (*GetMtlsCertificateResp, error) {
	rsp, err := c.GetMtlsCertificate(ctx, organizationId, projectId, clusterId, certId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMtlsCertificateResp(rsp)
}

// PutMtlsCertificateWithBodyWithResponse request with arbitrary body returning *PutMtlsCertificateResp
func (c *ClientWithResponses) PutMtlsCertificateWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutMtlsCertificateResp, error) {
	rsp, err := c.PutMtlsCertificateWithBody(ctx, organizationId, projectId, clusterId, certId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutMtlsCertificateResp(rsp)
}

func (c *ClientWithResponses) PutMtlsCertificateWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, certId CertificateId, body PutMtlsCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*PutMtlsCertificateResp, error) {
	rsp, err := c.PutMtlsCertificate(ctx, organizationId, projectId, clusterId, certId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutMtlsCertificateResp(rsp)
}

// GetMtlsConfigurationWithResponse request returning *GetMtlsConfigurationResp
func (c *ClientWithResponses) GetMtlsConfigurationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetMtlsConfigurationResp, error) {
	rsp, err := c.GetMtlsConfiguration(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMtlsConfigurationResp(rsp)
}

// UpdateMtlsConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateMtlsConfigurationResp
func (c *ClientWithResponses) UpdateMtlsConfigurationWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMtlsConfigurationResp, error) {
	rsp, err := c.UpdateMtlsConfigurationWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMtlsConfigurationResp(rsp)
}

func (c *ClientWithResponses) UpdateMtlsConfigurationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body UpdateMtlsConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMtlsConfigurationResp, error) {
	rsp, err := c.UpdateMtlsConfiguration(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMtlsConfigurationResp(rsp)
}

// ListNetworkPeeringRecordsWithResponse request returning *ListNetworkPeeringRecordsResp
func (c *ClientWithResponses) ListNetworkPeeringRecordsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListNetworkPeeringRecordsParams, reqEditors ...RequestEditorFn) (*ListNetworkPeeringRecordsResp, error) {
	rsp, err := c.ListNetworkPeeringRecords(ctx, organizationId, projectId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNetworkPeeringRecordsResp(rsp)
}

// PostNetworkPeeringWithBodyWithResponse request with arbitrary body returning *PostNetworkPeeringResp
func (c *ClientWithResponses) PostNetworkPeeringWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNetworkPeeringResp, error) {
	rsp, err := c.PostNetworkPeeringWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNetworkPeeringResp(rsp)
}

func (c *ClientWithResponses) PostNetworkPeeringWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostNetworkPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNetworkPeeringResp, error) {
	rsp, err := c.PostNetworkPeering(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNetworkPeeringResp(rsp)
}

// GetAzureVnetPeeringCommandWithBodyWithResponse request with arbitrary body returning *GetAzureVnetPeeringCommandResp
func (c *ClientWithResponses) GetAzureVnetPeeringCommandWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetAzureVnetPeeringCommandResp, error) {
	rsp, err := c.GetAzureVnetPeeringCommandWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAzureVnetPeeringCommandResp(rsp)
}

func (c *ClientWithResponses) GetAzureVnetPeeringCommandWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetAzureVnetPeeringCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*GetAzureVnetPeeringCommandResp, error) {
	rsp, err := c.GetAzureVnetPeeringCommand(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAzureVnetPeeringCommandResp(rsp)
}

// DeleteNetworkPeeringWithResponse request returning *DeleteNetworkPeeringResp
func (c *ClientWithResponses) DeleteNetworkPeeringWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, peerId PeerId, reqEditors ...RequestEditorFn) (*DeleteNetworkPeeringResp, error) {
	rsp, err := c.DeleteNetworkPeering(ctx, organizationId, projectId, clusterId, peerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNetworkPeeringResp(rsp)
}

// GetNetworkPeeringRecordWithResponse request returning *GetNetworkPeeringRecordResp
func (c *ClientWithResponses) GetNetworkPeeringRecordWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, peerId PeerId, reqEditors ...RequestEditorFn) (*GetNetworkPeeringRecordResp, error) {
	rsp, err := c.GetNetworkPeeringRecord(ctx, organizationId, projectId, clusterId, peerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkPeeringRecordResp(rsp)
}

// DeleteOnOffScheduleWithResponse request returning *DeleteOnOffScheduleResp
func (c *ClientWithResponses) DeleteOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*DeleteOnOffScheduleResp, error) {
	rsp, err := c.DeleteOnOffSchedule(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOnOffScheduleResp(rsp)
}

// GetOnOffScheduleWithResponse request returning *GetOnOffScheduleResp
func (c *ClientWithResponses) GetOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetOnOffScheduleResp, error) {
	rsp, err := c.GetOnOffSchedule(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOnOffScheduleResp(rsp)
}

// PostOnOffScheduleWithBodyWithResponse request with arbitrary body returning *PostOnOffScheduleResp
func (c *ClientWithResponses) PostOnOffScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOnOffScheduleResp, error) {
	rsp, err := c.PostOnOffScheduleWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOnOffScheduleResp(rsp)
}

func (c *ClientWithResponses) PostOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOnOffScheduleResp, error) {
	rsp, err := c.PostOnOffSchedule(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOnOffScheduleResp(rsp)
}

// PutOnOffScheduleWithBodyWithResponse request with arbitrary body returning *PutOnOffScheduleResp
func (c *ClientWithResponses) PutOnOffScheduleWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutOnOffScheduleResp, error) {
	rsp, err := c.PutOnOffScheduleWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutOnOffScheduleResp(rsp)
}

func (c *ClientWithResponses) PutOnOffScheduleWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PutOnOffScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PutOnOffScheduleResp, error) {
	rsp, err := c.PutOnOffSchedule(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutOnOffScheduleResp(rsp)
}

// DisablePrivateEndpointServiceWithResponse request returning *DisablePrivateEndpointServiceResp
func (c *ClientWithResponses) DisablePrivateEndpointServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*DisablePrivateEndpointServiceResp, error) {
	rsp, err := c.DisablePrivateEndpointService(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisablePrivateEndpointServiceResp(rsp)
}

// GetPrivateEndpointServiceStatusWithResponse request returning *GetPrivateEndpointServiceStatusResp
func (c *ClientWithResponses) GetPrivateEndpointServiceStatusWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetPrivateEndpointServiceStatusResp, error) {
	rsp, err := c.GetPrivateEndpointServiceStatus(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPrivateEndpointServiceStatusResp(rsp)
}

// EnablePrivateEndpointServiceWithResponse request returning *EnablePrivateEndpointServiceResp
func (c *ClientWithResponses) EnablePrivateEndpointServiceWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*EnablePrivateEndpointServiceResp, error) {
	rsp, err := c.EnablePrivateEndpointService(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnablePrivateEndpointServiceResp(rsp)
}

// GetPrivateEndpointCommandWithBodyWithResponse request with arbitrary body returning *GetPrivateEndpointCommandResp
func (c *ClientWithResponses) GetPrivateEndpointCommandWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPrivateEndpointCommandResp, error) {
	rsp, err := c.GetPrivateEndpointCommandWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPrivateEndpointCommandResp(rsp)
}

func (c *ClientWithResponses) GetPrivateEndpointCommandWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body GetPrivateEndpointCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPrivateEndpointCommandResp, error) {
	rsp, err := c.GetPrivateEndpointCommand(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPrivateEndpointCommandResp(rsp)
}

// ListPrivateEndpointsWithResponse request returning *ListPrivateEndpointsResp
func (c *ClientWithResponses) ListPrivateEndpointsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListPrivateEndpointsResp, error) {
	rsp, err := c.ListPrivateEndpoints(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPrivateEndpointsResp(rsp)
}

// AcceptPrivateEndpointWithResponse request returning *AcceptPrivateEndpointResp
func (c *ClientWithResponses) AcceptPrivateEndpointWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*AcceptPrivateEndpointResp, error) {
	rsp, err := c.AcceptPrivateEndpoint(ctx, organizationId, projectId, clusterId, endpointId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptPrivateEndpointResp(rsp)
}

// DeletePrivateEndpointWithResponse request returning *DeletePrivateEndpointResp
func (c *ClientWithResponses) DeletePrivateEndpointWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, endpointId EndpointID, reqEditors ...RequestEditorFn) (*DeletePrivateEndpointResp, error) {
	rsp, err := c.DeletePrivateEndpoint(ctx, organizationId, projectId, clusterId, endpointId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePrivateEndpointResp(rsp)
}

// IndexBuildStatusWithResponse request returning *IndexBuildStatusResp
func (c *ClientWithResponses) IndexBuildStatusWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, indexName IndexName, params *IndexBuildStatusParams, reqEditors ...RequestEditorFn) (*IndexBuildStatusResp, error) {
	rsp, err := c.IndexBuildStatus(ctx, organizationId, projectId, clusterId, indexName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIndexBuildStatusResp(rsp)
}

// ListIndexDefinitionsWithResponse request returning *ListIndexDefinitionsResp
func (c *ClientWithResponses) ListIndexDefinitionsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListIndexDefinitionsParams, reqEditors ...RequestEditorFn) (*ListIndexDefinitionsResp, error) {
	rsp, err := c.ListIndexDefinitions(ctx, organizationId, projectId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIndexDefinitionsResp(rsp)
}

// ManageQueryIndexesWithBodyWithResponse request with arbitrary body returning *ManageQueryIndexesResp
func (c *ClientWithResponses) ManageQueryIndexesWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManageQueryIndexesResp, error) {
	rsp, err := c.ManageQueryIndexesWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManageQueryIndexesResp(rsp)
}

func (c *ClientWithResponses) ManageQueryIndexesWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body ManageQueryIndexesJSONRequestBody, reqEditors ...RequestEditorFn) (*ManageQueryIndexesResp, error) {
	rsp, err := c.ManageQueryIndexes(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManageQueryIndexesResp(rsp)
}

// IndexDefinitionWithResponse request returning *IndexDefinitionResp
func (c *ClientWithResponses) IndexDefinitionWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, indexName IndexName, params *IndexDefinitionParams, reqEditors ...RequestEditorFn) (*IndexDefinitionResp, error) {
	rsp, err := c.IndexDefinition(ctx, organizationId, projectId, clusterId, indexName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIndexDefinitionResp(rsp)
}

// ListClusterReplicationsWithResponse request returning *ListClusterReplicationsResp
func (c *ClientWithResponses) ListClusterReplicationsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListClusterReplicationsParams, reqEditors ...RequestEditorFn) (*ListClusterReplicationsResp, error) {
	rsp, err := c.ListClusterReplications(ctx, organizationId, projectId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClusterReplicationsResp(rsp)
}

// CreateReplicationWithBodyWithResponse request with arbitrary body returning *CreateReplicationResp
func (c *ClientWithResponses) CreateReplicationWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReplicationResp, error) {
	rsp, err := c.CreateReplicationWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReplicationResp(rsp)
}

func (c *ClientWithResponses) CreateReplicationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body CreateReplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReplicationResp, error) {
	rsp, err := c.CreateReplication(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReplicationResp(rsp)
}

// DeleteReplicationWithResponse request returning *DeleteReplicationResp
func (c *ClientWithResponses) DeleteReplicationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*DeleteReplicationResp, error) {
	rsp, err := c.DeleteReplication(ctx, organizationId, projectId, clusterId, replicationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReplicationResp(rsp)
}

// GetReplicationWithResponse request returning *GetReplicationResp
func (c *ClientWithResponses) GetReplicationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*GetReplicationResp, error) {
	rsp, err := c.GetReplication(ctx, organizationId, projectId, clusterId, replicationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReplicationResp(rsp)
}

// UpdateReplicationWithBodyWithResponse request with arbitrary body returning *UpdateReplicationResp
func (c *ClientWithResponses) UpdateReplicationWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateReplicationResp, error) {
	rsp, err := c.UpdateReplicationWithBody(ctx, organizationId, projectId, clusterId, replicationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateReplicationResp(rsp)
}

func (c *ClientWithResponses) UpdateReplicationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, body UpdateReplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateReplicationResp, error) {
	rsp, err := c.UpdateReplication(ctx, organizationId, projectId, clusterId, replicationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateReplicationResp(rsp)
}

// PauseReplicationWithResponse request returning *PauseReplicationResp
func (c *ClientWithResponses) PauseReplicationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*PauseReplicationResp, error) {
	rsp, err := c.PauseReplication(ctx, organizationId, projectId, clusterId, replicationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePauseReplicationResp(rsp)
}

// ResumeReplicationWithResponse request returning *ResumeReplicationResp
func (c *ClientWithResponses) ResumeReplicationWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, replicationId ReplicationId, reqEditors ...RequestEditorFn) (*ResumeReplicationResp, error) {
	rsp, err := c.ResumeReplication(ctx, organizationId, projectId, clusterId, replicationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeReplicationResp(rsp)
}

// ListSampleBucketsWithResponse request returning *ListSampleBucketsResp
func (c *ClientWithResponses) ListSampleBucketsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListSampleBucketsResp, error) {
	rsp, err := c.ListSampleBuckets(ctx, organizationId, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSampleBucketsResp(rsp)
}

// PostSampleBucketWithBodyWithResponse request with arbitrary body returning *PostSampleBucketResp
func (c *ClientWithResponses) PostSampleBucketWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSampleBucketResp, error) {
	rsp, err := c.PostSampleBucketWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSampleBucketResp(rsp)
}

func (c *ClientWithResponses) PostSampleBucketWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostSampleBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSampleBucketResp, error) {
	rsp, err := c.PostSampleBucket(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSampleBucketResp(rsp)
}

// DeleteSampleDataByBucketIDWithResponse request returning *DeleteSampleDataByBucketIDResp
func (c *ClientWithResponses) DeleteSampleDataByBucketIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*DeleteSampleDataByBucketIDResp, error) {
	rsp, err := c.DeleteSampleDataByBucketID(ctx, organizationId, projectId, clusterId, bucketId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSampleDataByBucketIDResp(rsp)
}

// GetSampleBucketByIdWithResponse request returning *GetSampleBucketByIdResp
func (c *ClientWithResponses) GetSampleBucketByIdWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, bucketId BucketId, reqEditors ...RequestEditorFn) (*GetSampleBucketByIdResp, error) {
	rsp, err := c.GetSampleBucketById(ctx, organizationId, projectId, clusterId, bucketId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSampleBucketByIdResp(rsp)
}

// ListDatabaseCredentialsWithResponse request returning *ListDatabaseCredentialsResp
func (c *ClientWithResponses) ListDatabaseCredentialsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, params *ListDatabaseCredentialsParams, reqEditors ...RequestEditorFn) (*ListDatabaseCredentialsResp, error) {
	rsp, err := c.ListDatabaseCredentials(ctx, organizationId, projectId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDatabaseCredentialsResp(rsp)
}

// PostDatabaseCredentialWithBodyWithResponse request with arbitrary body returning *PostDatabaseCredentialResp
func (c *ClientWithResponses) PostDatabaseCredentialWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDatabaseCredentialResp, error) {
	rsp, err := c.PostDatabaseCredentialWithBody(ctx, organizationId, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDatabaseCredentialResp(rsp)
}

func (c *ClientWithResponses) PostDatabaseCredentialWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, body PostDatabaseCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDatabaseCredentialResp, error) {
	rsp, err := c.PostDatabaseCredential(ctx, organizationId, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDatabaseCredentialResp(rsp)
}

// DeleteDatabaseCredentialWithResponse request returning *DeleteDatabaseCredentialResp
func (c *ClientWithResponses) DeleteDatabaseCredentialWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, reqEditors ...RequestEditorFn) (*DeleteDatabaseCredentialResp, error) {
	rsp, err := c.DeleteDatabaseCredential(ctx, organizationId, projectId, clusterId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDatabaseCredentialResp(rsp)
}

// GetDatabaseCredentialWithResponse request returning *GetDatabaseCredentialResp
func (c *ClientWithResponses) GetDatabaseCredentialWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, reqEditors ...RequestEditorFn) (*GetDatabaseCredentialResp, error) {
	rsp, err := c.GetDatabaseCredential(ctx, organizationId, projectId, clusterId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseCredentialResp(rsp)
}

// PutDatabaseCredentialWithBodyWithResponse request with arbitrary body returning *PutDatabaseCredentialResp
func (c *ClientWithResponses) PutDatabaseCredentialWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, params *PutDatabaseCredentialParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutDatabaseCredentialResp, error) {
	rsp, err := c.PutDatabaseCredentialWithBody(ctx, organizationId, projectId, clusterId, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutDatabaseCredentialResp(rsp)
}

func (c *ClientWithResponses) PutDatabaseCredentialWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, clusterId ClusterId, userId UserId, params *PutDatabaseCredentialParams, body PutDatabaseCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*PutDatabaseCredentialResp, error) {
	rsp, err := c.PutDatabaseCredential(ctx, organizationId, projectId, clusterId, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutDatabaseCredentialResp(rsp)
}

// ListProjectEventsWithResponse request returning *ListProjectEventsResp
func (c *ClientWithResponses) ListProjectEventsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectEventsParams, reqEditors ...RequestEditorFn) (*ListProjectEventsResp, error) {
	rsp, err := c.ListProjectEvents(ctx, organizationId, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectEventsResp(rsp)
}

// GetProjectEventByIDWithResponse request returning *GetProjectEventByIDResp
func (c *ClientWithResponses) GetProjectEventByIDWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, eventId EventId, reqEditors ...RequestEditorFn) (*GetProjectEventByIDResp, error) {
	rsp, err := c.GetProjectEventByID(ctx, organizationId, projectId, eventId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectEventByIDResp(rsp)
}

// ListProjectReplicationsWithResponse request returning *ListProjectReplicationsResp
func (c *ClientWithResponses) ListProjectReplicationsWithResponse(ctx context.Context, organizationId OrganizationId, projectId ProjectId, params *ListProjectReplicationsParams, reqEditors ...RequestEditorFn) (*ListProjectReplicationsResp, error) {
	rsp, err := c.ListProjectReplications(ctx, organizationId, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectReplicationsResp(rsp)
}

// ListUsersWithResponse request returning *ListUsersResp
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, organizationId OrganizationId, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResp, error) {
	rsp, err := c.ListUsers(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResp(rsp)
}

// PostUserWithBodyWithResponse request with arbitrary body returning *PostUserResp
func (c *ClientWithResponses) PostUserWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserResp, error) {
	rsp, err := c.PostUserWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserResp(rsp)
}

func (c *ClientWithResponses) PostUserWithResponse(ctx context.Context, organizationId OrganizationId, body PostUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUserResp, error) {
	rsp, err := c.PostUser(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserResp(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResp
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, organizationId OrganizationId, userId CPUserId, reqEditors ...RequestEditorFn) (*DeleteUserResp, error) {
	rsp, err := c.DeleteUser(ctx, organizationId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResp(rsp)
}

// GetUserWithResponse request returning *GetUserResp
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, organizationId OrganizationId, userId CPUserId, reqEditors ...RequestEditorFn) (*GetUserResp, error) {
	rsp, err := c.GetUser(ctx, organizationId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResp(rsp)
}

// PatchUserWithBodyWithResponse request with arbitrary body returning *PatchUserResp
func (c *ClientWithResponses) PatchUserWithBodyWithResponse(ctx context.Context, organizationId OrganizationId, userId CPUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserResp, error) {
	rsp, err := c.PatchUserWithBody(ctx, organizationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserResp(rsp)
}

func (c *ClientWithResponses) PatchUserWithResponse(ctx context.Context, organizationId OrganizationId, userId CPUserId, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserResp, error) {
	rsp, err := c.PatchUser(ctx, organizationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserResp(rsp)
}

// ParseListOrganizationsResp parses an HTTP response from a ListOrganizationsWithResponse call
func ParseListOrganizationsResp(rsp *http.Response) (*ListOrganizationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrganizationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrganizationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationByIDResp parses an HTTP response from a GetOrganizationByIDWithResponse call
func ParseGetOrganizationByIDResp(rsp *http.Response) (*GetOrganizationByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrganizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListModelsResp parses an HTTP response from a ListModelsWithResponse call
func ParseListModelsResp(rsp *http.Response) (*ListModelsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModelsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetLanguageModelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateModelResp parses an HTTP response from a CreateModelWithResponse call
func ParseCreateModelResp(rsp *http.Response) (*CreateModelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateModelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateLanguageModelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDestroyModelResp parses an HTTP response from a DestroyModelWithResponse call
func ParseDestroyModelResp(rsp *http.Response) (*DestroyModelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DestroyModelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetModelResp parses an HTTP response from a GetModelWithResponse call
func ParseGetModelResp(rsp *http.Response) (*GetModelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetLanguageModelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListModelAPIKeysResp parses an HTTP response from a ListModelAPIKeysWithResponse call
func ParseListModelAPIKeysResp(rsp *http.Response) (*ListModelAPIKeysResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModelAPIKeysResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListLanguageModelAPIKeysResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateModelAPIKeyResp parses an HTTP response from a CreateModelAPIKeyWithResponse call
func ParseCreateModelAPIKeyResp(rsp *http.Response) (*CreateModelAPIKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateModelAPIKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateLanguageModelAPIKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteModelAPIKeyResp parses an HTTP response from a DeleteModelAPIKeyWithResponse call
func ParseDeleteModelAPIKeyResp(rsp *http.Response) (*DeleteModelAPIKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteModelAPIKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetModelAPIKeyResp parses an HTTP response from a GetModelAPIKeyWithResponse call
func ParseGetModelAPIKeyResp(rsp *http.Response) (*GetModelAPIKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModelAPIKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetLanguageModelAPIKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetConnectionStringResp parses an HTTP response from a GetConnectionStringWithResponse call
func ParseGetConnectionStringResp(rsp *http.Response) (*GetConnectionStringResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectionStringResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetConnectionStringResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProvidersResp parses an HTTP response from a ListProvidersWithResponse call
func ParseListProvidersResp(rsp *http.Response) (*ListProvidersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProvidersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListProvidersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProviderResp parses an HTTP response from a CreateProviderWithResponse call
func ParseCreateProviderResp(rsp *http.Response) (*CreateProviderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProviderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateProviderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProviderResp parses an HTTP response from a DeleteProviderWithResponse call
func ParseDeleteProviderResp(rsp *http.Response) (*DeleteProviderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProviderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProviderResp parses an HTTP response from a GetProviderWithResponse call
func ParseGetProviderResp(rsp *http.Response) (*GetProviderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProviderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetProviderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProviderResp parses an HTTP response from a UpdateProviderWithResponse call
func ParseUpdateProviderResp(rsp *http.Response) (*UpdateProviderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProviderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListOrganizationLevelAnalyticsClustersResp parses an HTTP response from a ListOrganizationLevelAnalyticsClustersWithResponse call
func ParseListOrganizationLevelAnalyticsClustersResp(rsp *http.Response) (*ListOrganizationLevelAnalyticsClustersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrganizationLevelAnalyticsClustersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetColumnarAnalyticsClustersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListOrganizationAPIKeysResp parses an HTTP response from a ListOrganizationAPIKeysWithResponse call
func ParseListOrganizationAPIKeysResp(rsp *http.Response) (*ListOrganizationAPIKeysResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrganizationAPIKeysResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAPIKeys
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrganizationAPIKeysResp parses an HTTP response from a PostOrganizationAPIKeysWithResponse call
func ParsePostOrganizationAPIKeysResp(rsp *http.Response) (*PostOrganizationAPIKeysResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrganizationAPIKeysResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateAPIKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationAPIKeyResp parses an HTTP response from a DeleteOrganizationAPIKeyWithResponse call
func ParseDeleteOrganizationAPIKeyResp(rsp *http.Response) (*DeleteOrganizationAPIKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationAPIKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationAPIKeyByAccessKeyResp parses an HTTP response from a GetOrganizationAPIKeyByAccessKeyWithResponse call
func ParseGetOrganizationAPIKeyByAccessKeyResp(rsp *http.Response) (*GetOrganizationAPIKeyByAccessKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationAPIKeyByAccessKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAPIKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrganizationAPIKeyRotateResp parses an HTTP response from a PostOrganizationAPIKeyRotateWithResponse call
func ParsePostOrganizationAPIKeyRotateResp(rsp *http.Response) (*PostOrganizationAPIKeyRotateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrganizationAPIKeyRotateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RotateAPIKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAppServicesResp parses an HTTP response from a ListAppServicesWithResponse call
func ParseListAppServicesResp(rsp *http.Response) (*ListAppServicesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppServicesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAppServicesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCloudAccountsResp parses an HTTP response from a GetCloudAccountsWithResponse call
func ParseGetCloudAccountsResp(rsp *http.Response) (*GetCloudAccountsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCloudAccountsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloudAccounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKeyMetadataListResp parses an HTTP response from a GetKeyMetadataListWithResponse call
func ParseGetKeyMetadataListResp(rsp *http.Response) (*GetKeyMetadataListResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeyMetadataListResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCMEKMetadataListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCMEKMetadataResp parses an HTTP response from a PostCMEKMetadataWithResponse call
func ParsePostCMEKMetadataResp(rsp *http.Response) (*PostCMEKMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCMEKMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateCMEKMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteKeyMetadataResp parses an HTTP response from a DeleteKeyMetadataWithResponse call
func ParseDeleteKeyMetadataResp(rsp *http.Response) (*DeleteKeyMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeyMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKeyMetadataResp parses an HTTP response from a GetKeyMetadataWithResponse call
func ParseGetKeyMetadataResp(rsp *http.Response) (*GetKeyMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeyMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCMEKMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRotateCMEKKeyResp parses an HTTP response from a RotateCMEKKeyWithResponse call
func ParseRotateCMEKKeyResp(rsp *http.Response) (*RotateCMEKKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RotateCMEKKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCMEKHistoryResp parses an HTTP response from a ListCMEKHistoryWithResponse call
func ParseListCMEKHistoryResp(rsp *http.Response) (*ListCMEKHistoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCMEKHistoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCMEKHistoryMetadataListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutOrganizationConfigurationResp parses an HTTP response from a PutOrganizationConfigurationWithResponse call
func ParsePutOrganizationConfigurationResp(rsp *http.Response) (*PutOrganizationConfigurationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutOrganizationConfigurationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEventsResp parses an HTTP response from a ListEventsWithResponse call
func ParseListEventsResp(rsp *http.Response) (*ListEventsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEventByIDResp parses an HTTP response from a GetEventByIDWithResponse call
func ParseGetEventByIDResp(rsp *http.Response) (*GetEventByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEventResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectsResp parses an HTTP response from a ListProjectsWithResponse call
func ParseListProjectsResp(rsp *http.Response) (*ListProjectsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetProjectsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProjectResp parses an HTTP response from a PostProjectWithResponse call
func ParsePostProjectResp(rsp *http.Response) (*PostProjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectByIDResp parses an HTTP response from a DeleteProjectByIDWithResponse call
func ParseDeleteProjectByIDResp(rsp *http.Response) (*DeleteProjectByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProjectByIDResp parses an HTTP response from a GetProjectByIDWithResponse call
func ParseGetProjectByIDResp(rsp *http.Response) (*GetProjectByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutProjectResp parses an HTTP response from a PutProjectWithResponse call
func ParsePutProjectResp(rsp *http.Response) (*PutProjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutProjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTestAlertIntegrationResp parses an HTTP response from a PostTestAlertIntegrationWithResponse call
func ParsePostTestAlertIntegrationResp(rsp *http.Response) (*PostTestAlertIntegrationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTestAlertIntegrationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAlertIntegrationsResp parses an HTTP response from a ListAlertIntegrationsWithResponse call
func ParseListAlertIntegrationsResp(rsp *http.Response) (*ListAlertIntegrationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAlertIntegrationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAlertsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAlertIntegrationResp parses an HTTP response from a PostAlertIntegrationWithResponse call
func ParsePostAlertIntegrationResp(rsp *http.Response) (*PostAlertIntegrationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAlertIntegrationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateAlertResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAlertIntegrationByIDResp parses an HTTP response from a DeleteAlertIntegrationByIDWithResponse call
func ParseDeleteAlertIntegrationByIDResp(rsp *http.Response) (*DeleteAlertIntegrationByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAlertIntegrationByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAlertIntegrationByIDResp parses an HTTP response from a GetAlertIntegrationByIDWithResponse call
func ParseGetAlertIntegrationByIDResp(rsp *http.Response) (*GetAlertIntegrationByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlertIntegrationByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAlertResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutAlertIntegrationResp parses an HTTP response from a PutAlertIntegrationWithResponse call
func ParsePutAlertIntegrationResp(rsp *http.Response) (*PutAlertIntegrationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAlertIntegrationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectLevelAnalyticsClustersResp parses an HTTP response from a ListProjectLevelAnalyticsClustersWithResponse call
func ParseListProjectLevelAnalyticsClustersResp(rsp *http.Response) (*ListProjectLevelAnalyticsClustersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectLevelAnalyticsClustersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetColumnarAnalyticsClustersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAnalyticsClusterResp parses an HTTP response from a CreateAnalyticsClusterWithResponse call
func ParseCreateAnalyticsClusterResp(rsp *http.Response) (*CreateAnalyticsClusterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAnalyticsClusterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateColumnarAnalyticsClusterResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAnalyticsClusterResp parses an HTTP response from a DeleteAnalyticsClusterWithResponse call
func ParseDeleteAnalyticsClusterResp(rsp *http.Response) (*DeleteAnalyticsClusterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAnalyticsClusterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAnalyticsClusterResp parses an HTTP response from a GetAnalyticsClusterWithResponse call
func ParseGetAnalyticsClusterResp(rsp *http.Response) (*GetAnalyticsClusterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnalyticsClusterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetColumnarAnalyticsClusterResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutAnalyticsClusterResp parses an HTTP response from a PutAnalyticsClusterWithResponse call
func ParsePutAnalyticsClusterResp(rsp *http.Response) (*PutAnalyticsClusterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAnalyticsClusterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAnalyticsClusterOffResp parses an HTTP response from a AnalyticsClusterOffWithResponse call
func ParseAnalyticsClusterOffResp(rsp *http.Response) (*AnalyticsClusterOffResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnalyticsClusterOffResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAnalyticsClusterOnResp parses an HTTP response from a AnalyticsClusterOnWithResponse call
func ParseAnalyticsClusterOnResp(rsp *http.Response) (*AnalyticsClusterOnResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnalyticsClusterOnResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAnalyticsAllowedCidrsResp parses an HTTP response from a ListAnalyticsAllowedCidrsWithResponse call
func ParseListAnalyticsAllowedCidrsResp(rsp *http.Response) (*ListAnalyticsAllowedCidrsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAnalyticsAllowedCidrsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAllowedCidrsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAnalyticsAllowedCidrResp parses an HTTP response from a PostAnalyticsAllowedCidrWithResponse call
func ParsePostAnalyticsAllowedCidrResp(rsp *http.Response) (*PostAnalyticsAllowedCidrResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAnalyticsAllowedCidrResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateAllowedCidrResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteColumnarAllowedCidrByIDResp parses an HTTP response from a DeleteColumnarAllowedCidrByIDWithResponse call
func ParseDeleteColumnarAllowedCidrByIDResp(rsp *http.Response) (*DeleteColumnarAllowedCidrByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteColumnarAllowedCidrByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetColumnarAllowedCidrByIDResp parses an HTTP response from a GetColumnarAllowedCidrByIDWithResponse call
func ParseGetColumnarAllowedCidrByIDResp(rsp *http.Response) (*GetColumnarAllowedCidrByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetColumnarAllowedCidrByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllowedCidr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteColumnarAnalyticsBackupScheduleResp parses an HTTP response from a DeleteColumnarAnalyticsBackupScheduleWithResponse call
func ParseDeleteColumnarAnalyticsBackupScheduleResp(rsp *http.Response) (*DeleteColumnarAnalyticsBackupScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteColumnarAnalyticsBackupScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetColumnarAnalyticsBackupScheduleResp parses an HTTP response from a GetColumnarAnalyticsBackupScheduleWithResponse call
func ParseGetColumnarAnalyticsBackupScheduleResp(rsp *http.Response) (*GetColumnarAnalyticsBackupScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetColumnarAnalyticsBackupScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetColumnarAnalyticsBackupScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpsertColumnarAnalyticsBackupScheduleResp parses an HTTP response from a UpsertColumnarAnalyticsBackupScheduleWithResponse call
func ParseUpsertColumnarAnalyticsBackupScheduleResp(rsp *http.Response) (*UpsertColumnarAnalyticsBackupScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertColumnarAnalyticsBackupScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListColumnarAnalyticsBackupsResp parses an HTTP response from a ListColumnarAnalyticsBackupsWithResponse call
func ParseListColumnarAnalyticsBackupsResp(rsp *http.Response) (*ListColumnarAnalyticsBackupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListColumnarAnalyticsBackupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListColumnarAnalyticsBackupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateColumnarAnalyticsBackupResp parses an HTTP response from a CreateColumnarAnalyticsBackupWithResponse call
func ParseCreateColumnarAnalyticsBackupResp(rsp *http.Response) (*CreateColumnarAnalyticsBackupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateColumnarAnalyticsBackupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateColumnarAnalyticsBackupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListColumnarAnalyticsRestoresResp parses an HTTP response from a ListColumnarAnalyticsRestoresWithResponse call
func ParseListColumnarAnalyticsRestoresResp(rsp *http.Response) (*ListColumnarAnalyticsRestoresResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListColumnarAnalyticsRestoresResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListColumnarAnalyticsRestoresResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteColumnarAnalyticsBackupResp parses an HTTP response from a DeleteColumnarAnalyticsBackupWithResponse call
func ParseDeleteColumnarAnalyticsBackupResp(rsp *http.Response) (*DeleteColumnarAnalyticsBackupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteColumnarAnalyticsBackupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateColumnarAnalyticsBackupRetentionResp parses an HTTP response from a UpdateColumnarAnalyticsBackupRetentionWithResponse call
func ParseUpdateColumnarAnalyticsBackupRetentionResp(rsp *http.Response) (*UpdateColumnarAnalyticsBackupRetentionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateColumnarAnalyticsBackupRetentionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRestoreColumnarAnalyticsClusterResp parses an HTTP response from a RestoreColumnarAnalyticsClusterWithResponse call
func ParseRestoreColumnarAnalyticsClusterResp(rsp *http.Response) (*RestoreColumnarAnalyticsClusterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreColumnarAnalyticsClusterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateColumnarAnalyticsRestoreResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAnalyticsOnOffScheduleResp parses an HTTP response from a DeleteAnalyticsOnOffScheduleWithResponse call
func ParseDeleteAnalyticsOnOffScheduleResp(rsp *http.Response) (*DeleteAnalyticsOnOffScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAnalyticsOnOffScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAnalyticsOnOffScheduleResp parses an HTTP response from a GetAnalyticsOnOffScheduleWithResponse call
func ParseGetAnalyticsOnOffScheduleResp(rsp *http.Response) (*GetAnalyticsOnOffScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnalyticsOnOffScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ColumnarAnalyticsOnOffSchedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAnalyticsOnOffScheduleResp parses an HTTP response from a PostAnalyticsOnOffScheduleWithResponse call
func ParsePostAnalyticsOnOffScheduleResp(rsp *http.Response) (*PostAnalyticsOnOffScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAnalyticsOnOffScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutAnalyticsOnOffScheduleResp parses an HTTP response from a PutAnalyticsOnOffScheduleWithResponse call
func ParsePutAnalyticsOnOffScheduleResp(rsp *http.Response) (*PutAnalyticsOnOffScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAnalyticsOnOffScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDisableColumnarPrivateEndpointServiceResp parses an HTTP response from a DisableColumnarPrivateEndpointServiceWithResponse call
func ParseDisableColumnarPrivateEndpointServiceResp(rsp *http.Response) (*DisableColumnarPrivateEndpointServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableColumnarPrivateEndpointServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetColumnarPrivateEndpointServiceStatusResp parses an HTTP response from a GetColumnarPrivateEndpointServiceStatusWithResponse call
func ParseGetColumnarPrivateEndpointServiceStatusResp(rsp *http.Response) (*GetColumnarPrivateEndpointServiceStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetColumnarPrivateEndpointServiceStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPrivateEndpointServiceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEnableColumnarPrivateEndpointServiceResp parses an HTTP response from a EnableColumnarPrivateEndpointServiceWithResponse call
func ParseEnableColumnarPrivateEndpointServiceResp(rsp *http.Response) (*EnableColumnarPrivateEndpointServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableColumnarPrivateEndpointServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetColumnarPrivateEndpointServiceCommandResp parses an HTTP response from a GetColumnarPrivateEndpointServiceCommandWithResponse call
func ParseGetColumnarPrivateEndpointServiceCommandResp(rsp *http.Response) (*GetColumnarPrivateEndpointServiceCommandResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetColumnarPrivateEndpointServiceCommandResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePrivateEndpointServiceCommandResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListColumnarPrivateEndpointServiceConnectionResp parses an HTTP response from a ListColumnarPrivateEndpointServiceConnectionWithResponse call
func ParseListColumnarPrivateEndpointServiceConnectionResp(rsp *http.Response) (*ListColumnarPrivateEndpointServiceConnectionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListColumnarPrivateEndpointServiceConnectionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPrivateEndpointServiceConnectionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAcceptColumnarPrivateEndpointServiceConnectionResp parses an HTTP response from a AcceptColumnarPrivateEndpointServiceConnectionWithResponse call
func ParseAcceptColumnarPrivateEndpointServiceConnectionResp(rsp *http.Response) (*AcceptColumnarPrivateEndpointServiceConnectionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptColumnarPrivateEndpointServiceConnectionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRejectColumnarPrivateEndpointServiceConnectionResp parses an HTTP response from a RejectColumnarPrivateEndpointServiceConnectionWithResponse call
func ParseRejectColumnarPrivateEndpointServiceConnectionResp(rsp *http.Response) (*RejectColumnarPrivateEndpointServiceConnectionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RejectColumnarPrivateEndpointServiceConnectionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectLevelCloudSnapshotBackupsResp parses an HTTP response from a ListProjectLevelCloudSnapshotBackupsWithResponse call
func ParseListProjectLevelCloudSnapshotBackupsResp(rsp *http.Response) (*ListProjectLevelCloudSnapshotBackupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectLevelCloudSnapshotBackupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListProjectLevelCloudSnapshotResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCloneResp parses an HTTP response from a CloneWithResponse call
func ParseCloneResp(rsp *http.Response) (*CloneResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloneResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateCloudSnapshotCloneResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClustersResp parses an HTTP response from a ListClustersWithResponse call
func ParseListClustersResp(rsp *http.Response) (*ListClustersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClustersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetClustersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClusterResp parses an HTTP response from a PostClusterWithResponse call
func ParsePostClusterResp(rsp *http.Response) (*PostClusterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClusterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateClusterResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateFreeTierClusterResp parses an HTTP response from a CreateFreeTierClusterWithResponse call
func ParseCreateFreeTierClusterResp(rsp *http.Response) (*CreateFreeTierClusterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFreeTierClusterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateClusterResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteFreeTierClusterResp parses an HTTP response from a DeleteFreeTierClusterWithResponse call
func ParseDeleteFreeTierClusterResp(rsp *http.Response) (*DeleteFreeTierClusterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFreeTierClusterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFreeTierClusterResp parses an HTTP response from a GetFreeTierClusterWithResponse call
func ParseGetFreeTierClusterResp(rsp *http.Response) (*GetFreeTierClusterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFreeTierClusterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AppServiceId The ID of the linked App Service.
			AppServiceId *openapi_types.UUID `json:"appServiceId,omitempty"`
			Audit        CouchbaseAuditData  `json:"audit"`
			Availability Availability        `json:"availability"`

			// CloudProvider The cloud provider where the cluster will be hosted.
			// For information about providers and supported regions, see:
			//
			// - [Amazon Web Services](https://docs.couchbase.com/cloud/reference/aws.html)
			//
			// - [Google Cloud Platform](https://docs.couchbase.com/cloud/reference/gcp.html)
			//
			// - [Microsoft Azure](https://docs.couchbase.com/cloud/reference/azure.html)
			CloudProvider CloudProvider `json:"cloudProvider"`

			// CmekId The ID of the CMEK Key.
			CmekId *string `json:"cmekId,omitempty"`

			// ConfigurationType - Multi-node databases are best for deployments that require high availability. If your app requires high performance and high availability, choose the Multi-node option.
			// - Single-node databases have resource limitations that make them a good choice for learning, prototyping, and non-production uses. They have limited availability.
			// - Single-node databases should contain only 1 node and 1 Service Group. Adding number of nodes or service groups > 1 is not allowed for such databases.
			// - By default the configurationType is multiNode.
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			ConfigurationType ConfigurationType `json:"configurationType"`

			// ConnectionString ConnectionString specifies the Capella database endpoint for your client connection.
			ConnectionString string          `json:"connectionString"`
			CouchbaseServer  CouchbaseServer `json:"couchbaseServer"`
			CurrentState     CurrentState    `json:"currentState"`

			// Description Description of the cluster (up to 1024 characters).
			Description                string `json:"description"`
			EnablePrivateDNSResolution *bool  `json:"enablePrivateDNSResolution,omitempty"`

			// Id The ID of the cluster created.
			Id openapi_types.UUID `json:"id"`

			// Name Name of the cluster (up to 256 characters).
			Name          string         `json:"name"`
			ServiceGroups []ServiceGroup `json:"serviceGroups"`
			Support       struct {
				Plan GetFreeTierCluster200SupportPlan `json:"plan"`

				// Timezone The standard timezone for the cluster. Should be the TZ identifier.
				Timezone SupportTimezone `json:"timezone"`
			} `json:"support"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateFreeTierClusterResp parses an HTTP response from a UpdateFreeTierClusterWithResponse call
func ParseUpdateFreeTierClusterResp(rsp *http.Response) (*UpdateFreeTierClusterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFreeTierClusterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFreeTierClusterOffResp parses an HTTP response from a FreeTierClusterOffWithResponse call
func ParseFreeTierClusterOffResp(rsp *http.Response) (*FreeTierClusterOffResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FreeTierClusterOffResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFreeTierClusterOnResp parses an HTTP response from a FreeTierClusterOnWithResponse call
func ParseFreeTierClusterOnResp(rsp *http.Response) (*FreeTierClusterOnResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FreeTierClusterOnResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClusterResp parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResp(rsp *http.Response) (*DeleteClusterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterResp parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResp(rsp *http.Response) (*GetClusterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetClusterResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutClusterResp parses an HTTP response from a PutClusterWithResponse call
func ParsePutClusterResp(rsp *http.Response) (*PutClusterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutClusterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseClusterOffResp parses an HTTP response from a ClusterOffWithResponse call
func ParseClusterOffResp(rsp *http.Response) (*ClusterOffResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClusterOffResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseClusterOnResp parses an HTTP response from a ClusterOnWithResponse call
func ParseClusterOnResp(rsp *http.Response) (*ClusterOnResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClusterOnResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAiWorkflowsResp parses an HTTP response from a ListAiWorkflowsWithResponse call
func ParseListAiWorkflowsResp(rsp *http.Response) (*ListAiWorkflowsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAiWorkflowsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListWorkflowsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAiWorkflowResp parses an HTTP response from a CreateAiWorkflowWithResponse call
func ParseCreateAiWorkflowResp(rsp *http.Response) (*CreateAiWorkflowResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAiWorkflowResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateWorkflowResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAiWorkflowResp parses an HTTP response from a DeleteAiWorkflowWithResponse call
func ParseDeleteAiWorkflowResp(rsp *http.Response) (*DeleteAiWorkflowResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAiWorkflowResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAiWorkflowResp parses an HTTP response from a GetAiWorkflowWithResponse call
func ParseGetAiWorkflowResp(rsp *http.Response) (*GetAiWorkflowResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAiWorkflowResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetWorkflowResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStopAiWorkflowRunResp parses an HTTP response from a StopAiWorkflowRunWithResponse call
func ParseStopAiWorkflowRunResp(rsp *http.Response) (*StopAiWorkflowRunResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopAiWorkflowRunResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAiWorkflowRunsResp parses an HTTP response from a ListAiWorkflowRunsWithResponse call
func ParseListAiWorkflowRunsResp(rsp *http.Response) (*ListAiWorkflowRunsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAiWorkflowRunsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetWorkflowRunsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAiWorkflowRunResp parses an HTTP response from a CreateAiWorkflowRunWithResponse call
func ParseCreateAiWorkflowRunResp(rsp *http.Response) (*CreateAiWorkflowRunResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAiWorkflowRunResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateWorkflowRunResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAiWorkflowRunResp parses an HTTP response from a GetAiWorkflowRunWithResponse call
func ParseGetAiWorkflowRunResp(rsp *http.Response) (*GetAiWorkflowRunResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAiWorkflowRunResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetWorkflowRunResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAiWorkflowRunProcessedFilesResp parses an HTTP response from a GetAiWorkflowRunProcessedFilesWithResponse call
func ParseGetAiWorkflowRunProcessedFilesResp(rsp *http.Response) (*GetAiWorkflowRunProcessedFilesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAiWorkflowRunProcessedFilesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetWorkflowRunProcessedFilesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAllowedCidrsResp parses an HTTP response from a ListAllowedCidrsWithResponse call
func ParseListAllowedCidrsResp(rsp *http.Response) (*ListAllowedCidrsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllowedCidrsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAllowedCidrsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAllowedCidrsResp parses an HTTP response from a PostAllowedCidrsWithResponse call
func ParsePostAllowedCidrsResp(rsp *http.Response) (*PostAllowedCidrsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAllowedCidrsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateAllowedCidrResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAllowedCidrByIDResp parses an HTTP response from a DeleteAllowedCidrByIDWithResponse call
func ParseDeleteAllowedCidrByIDResp(rsp *http.Response) (*DeleteAllowedCidrByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAllowedCidrByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllowedCidrByIDResp parses an HTTP response from a GetAllowedCidrByIDWithResponse call
func ParseGetAllowedCidrByIDResp(rsp *http.Response) (*GetAllowedCidrByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllowedCidrByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllowedCidr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAppServiceResp parses an HTTP response from a PostAppServiceWithResponse call
func ParsePostAppServiceResp(rsp *http.Response) (*PostAppServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAppServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateAppServicesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateFreeTierAppServiceResp parses an HTTP response from a CreateFreeTierAppServiceWithResponse call
func ParseCreateFreeTierAppServiceResp(rsp *http.Response) (*CreateFreeTierAppServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFreeTierAppServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateAppServicesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteFreeTierAppServiceResp parses an HTTP response from a DeleteFreeTierAppServiceWithResponse call
func ParseDeleteFreeTierAppServiceResp(rsp *http.Response) (*DeleteFreeTierAppServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFreeTierAppServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFreeTierAppServiceResp parses an HTTP response from a GetFreeTierAppServiceWithResponse call
func ParseGetFreeTierAppServiceResp(rsp *http.Response) (*GetFreeTierAppServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFreeTierAppServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Audit CouchbaseAuditData `json:"audit"`

			// CloudProvider Provider is the cloud service provider for the App Service.
			CloudProvider string `json:"cloudProvider"`

			// ClusterId The ID of the cluster linked to the App Service.
			ClusterId openapi_types.UUID `json:"clusterId"`

			// Compute The CPU and RAM configuration of the App Service. The supported combinations are:
			// | CPU (cores)| RAM  (GB)   |
			// | --------   |   -------   |
			// | 2          | 4           |
			// | 4          | 8           |
			// | 8          | 16          |
			// | 16         | 32          |
			// | 36         | 72          |
			Compute      AppServiceCompute `json:"compute"`
			CurrentState AppServiceStates  `json:"currentState"`

			// Description Description of the App Service (up to 1024 characters).
			Description string `json:"description"`

			// Id The ID of the App Service created.
			Id openapi_types.UUID `json:"id"`

			// Name Name of the App Service (up to 256 characters).
			Name string `json:"name"`

			// Nodes Number of nodes configured for the App Service.
			Nodes int                          `json:"nodes"`
			Plan  GetFreeTierAppService200Plan `json:"plan"`

			// Version The version of the App Service server. If left empty, it will be defaulted to the latest available version.
			Version string `json:"version"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateFreeTierAppServiceResp parses an HTTP response from a UpdateFreeTierAppServiceWithResponse call
func ParseUpdateFreeTierAppServiceResp(rsp *http.Response) (*UpdateFreeTierAppServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFreeTierAppServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAppServiceResp parses an HTTP response from a DeleteAppServiceWithResponse call
func ParseDeleteAppServiceResp(rsp *http.Response) (*DeleteAppServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAppServiceResp parses an HTTP response from a GetAppServiceWithResponse call
func ParseGetAppServiceResp(rsp *http.Response) (*GetAppServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAppServiceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutAppServiceResp parses an HTTP response from a PutAppServiceWithResponse call
func ParsePutAppServiceResp(rsp *http.Response) (*PutAppServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAppServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppServiceOffResp parses an HTTP response from a AppServiceOffWithResponse call
func ParseAppServiceOffResp(rsp *http.Response) (*AppServiceOffResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppServiceOffResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppServiceOnResp parses an HTTP response from a AppServiceOnWithResponse call
func ParseAppServiceOnResp(rsp *http.Response) (*AppServiceOnResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppServiceOnResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAppServiceAdminUsersResp parses an HTTP response from a ListAppServiceAdminUsersWithResponse call
func ParseListAppServiceAdminUsersResp(rsp *http.Response) (*ListAppServiceAdminUsersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppServiceAdminUsersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAdminUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAddAppServiceAdminUserResp parses an HTTP response from a AddAppServiceAdminUserWithResponse call
func ParseAddAppServiceAdminUserResp(rsp *http.Response) (*AddAppServiceAdminUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddAppServiceAdminUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateAppServiceAdminUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAppServiceAdminUserResp parses an HTTP response from a DeleteAppServiceAdminUserWithResponse call
func ParseDeleteAppServiceAdminUserResp(rsp *http.Response) (*DeleteAppServiceAdminUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppServiceAdminUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAppServiceAdminUserResp parses an HTTP response from a GetAppServiceAdminUserWithResponse call
func ParseGetAppServiceAdminUserResp(rsp *http.Response) (*GetAppServiceAdminUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppServiceAdminUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppServiceAdminUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateAppServiceAdminUserResp parses an HTTP response from a UpdateAppServiceAdminUserWithResponse call
func ParseUpdateAppServiceAdminUserResp(rsp *http.Response) (*UpdateAppServiceAdminUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppServiceAdminUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListAppServiceAllowedCidrsResp parses an HTTP response from a ListAppServiceAllowedCidrsWithResponse call
func ParseListAppServiceAllowedCidrsResp(rsp *http.Response) (*ListAppServiceAllowedCidrsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppServiceAllowedCidrsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAppServiceAllowedCidrsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAppServiceAllowedCidrResp parses an HTTP response from a PostAppServiceAllowedCidrWithResponse call
func ParsePostAppServiceAllowedCidrResp(rsp *http.Response) (*PostAppServiceAllowedCidrResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAppServiceAllowedCidrResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateAllowedCidrResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAppServiceAllowedCidrResp parses an HTTP response from a DeleteAppServiceAllowedCidrWithResponse call
func ParseDeleteAppServiceAllowedCidrResp(rsp *http.Response) (*DeleteAppServiceAllowedCidrResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppServiceAllowedCidrResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAppEndpointsResp parses an HTTP response from a ListAppEndpointsWithResponse call
func ParseListAppEndpointsResp(rsp *http.Response) (*ListAppEndpointsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppEndpointsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAppEndpointsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePostAppEndpointResp parses an HTTP response from a PostAppEndpointWithResponse call
func ParsePostAppEndpointResp(rsp *http.Response) (*PostAppEndpointResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAppEndpointResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteAccessFunctionResp parses an HTTP response from a DeleteAccessFunctionWithResponse call
func ParseDeleteAccessFunctionResp(rsp *http.Response) (*DeleteAccessFunctionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccessFunctionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetAccessFunctionResp parses an HTTP response from a GetAccessFunctionWithResponse call
func ParseGetAccessFunctionResp(rsp *http.Response) (*GetAccessFunctionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessFunctionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePutAccessFunctionResp parses an HTTP response from a PutAccessFunctionWithResponse call
func ParsePutAccessFunctionResp(rsp *http.Response) (*PutAccessFunctionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAccessFunctionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteImportFilterResp parses an HTTP response from a DeleteImportFilterWithResponse call
func ParseDeleteImportFilterResp(rsp *http.Response) (*DeleteImportFilterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImportFilterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetImportFilterResp parses an HTTP response from a GetImportFilterWithResponse call
func ParseGetImportFilterResp(rsp *http.Response) (*GetImportFilterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImportFilterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePutImportFilterResp parses an HTTP response from a PutImportFilterWithResponse call
func ParsePutImportFilterResp(rsp *http.Response) (*PutImportFilterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutImportFilterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteAppEndpointResp parses an HTTP response from a DeleteAppEndpointWithResponse call
func ParseDeleteAppEndpointResp(rsp *http.Response) (*DeleteAppEndpointResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppEndpointResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetAppEndpointResp parses an HTTP response from a GetAppEndpointWithResponse call
func ParseGetAppEndpointResp(rsp *http.Response) (*GetAppEndpointResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppEndpointResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAppEndpointResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePutAppEndpointResp parses an HTTP response from a PutAppEndpointWithResponse call
func ParsePutAppEndpointResp(rsp *http.Response) (*PutAppEndpointResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAppEndpointResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteAppEndpointActivationStatusResp parses an HTTP response from a DeleteAppEndpointActivationStatusWithResponse call
func ParseDeleteAppEndpointActivationStatusResp(rsp *http.Response) (*DeleteAppEndpointActivationStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppEndpointActivationStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePostAppEndpointActivationStatusResp parses an HTTP response from a PostAppEndpointActivationStatusWithResponse call
func ParsePostAppEndpointActivationStatusResp(rsp *http.Response) (*PostAppEndpointActivationStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAppEndpointActivationStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListAppEndpointAdminUsersResp parses an HTTP response from a ListAppEndpointAdminUsersWithResponse call
func ParseListAppEndpointAdminUsersResp(rsp *http.Response) (*ListAppEndpointAdminUsersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppEndpointAdminUsersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAdminUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetAppEndpointAuditLogConfigResp parses an HTTP response from a GetAppEndpointAuditLogConfigWithResponse call
func ParseGetAppEndpointAuditLogConfigResp(rsp *http.Response) (*GetAppEndpointAuditLogConfigResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppEndpointAuditLogConfigResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAppEndpointAuditLogResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePutAppEndpointAuditLogConfigResp parses an HTTP response from a PutAppEndpointAuditLogConfigWithResponse call
func ParsePutAppEndpointAuditLogConfigResp(rsp *http.Response) (*PutAppEndpointAuditLogConfigResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAppEndpointAuditLogConfigResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetAppServiceAuditLogEventsResp parses an HTTP response from a GetAppServiceAuditLogEventsWithResponse call
func ParseGetAppServiceAuditLogEventsResp(rsp *http.Response) (*GetAppServiceAuditLogEventsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppServiceAuditLogEventsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditLogEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListAppEndpointCollectionsResp parses an HTTP response from a ListAppEndpointCollectionsWithResponse call
func ParseListAppEndpointCollectionsResp(rsp *http.Response) (*ListAppEndpointCollectionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppEndpointCollectionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScopesConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetAppEndpointCORSResp parses an HTTP response from a GetAppEndpointCORSWithResponse call
func ParseGetAppEndpointCORSResp(rsp *http.Response) (*GetAppEndpointCORSResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppEndpointCORSResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CORSConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParsePutAppEndpointCORSResp parses an HTTP response from a PutAppEndpointCORSWithResponse call
func ParsePutAppEndpointCORSResp(rsp *http.Response) (*PutAppEndpointCORSResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAppEndpointCORSResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseListAppEndpointOIDCProvidersResp parses an HTTP response from a ListAppEndpointOIDCProvidersWithResponse call
func ParseListAppEndpointOIDCProvidersResp(rsp *http.Response) (*ListAppEndpointOIDCProvidersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppEndpointOIDCProvidersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListOIDCProvidersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseCreateAppEndpointOIDCProviderResp parses an HTTP response from a CreateAppEndpointOIDCProviderWithResponse call
func ParseCreateAppEndpointOIDCProviderResp(rsp *http.Response) (*CreateAppEndpointOIDCProviderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppEndpointOIDCProviderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OIDCProviderID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseUpdateAppEndpointOIDCDefaultProviderResp parses an HTTP response from a UpdateAppEndpointOIDCDefaultProviderWithResponse call
func ParseUpdateAppEndpointOIDCDefaultProviderResp(rsp *http.Response) (*UpdateAppEndpointOIDCDefaultProviderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppEndpointOIDCDefaultProviderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseDeleteAppEndpointOIDCProviderResp parses an HTTP response from a DeleteAppEndpointOIDCProviderWithResponse call
func ParseDeleteAppEndpointOIDCProviderResp(rsp *http.Response) (*DeleteAppEndpointOIDCProviderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppEndpointOIDCProviderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetAppEndpointOIDCProviderResp parses an HTTP response from a GetAppEndpointOIDCProviderWithResponse call
func ParseGetAppEndpointOIDCProviderResp(rsp *http.Response) (*GetAppEndpointOIDCProviderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppEndpointOIDCProviderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OIDCProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseUpdateAppEndpointOIDCProviderResp parses an HTTP response from a UpdateAppEndpointOIDCProviderWithResponse call
func ParseUpdateAppEndpointOIDCProviderResp(rsp *http.Response) (*UpdateAppEndpointOIDCProviderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppEndpointOIDCProviderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseDeleteAppEndpointResyncResp parses an HTTP response from a DeleteAppEndpointResyncWithResponse call
func ParseDeleteAppEndpointResyncResp(rsp *http.Response) (*DeleteAppEndpointResyncResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppEndpointResyncResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetAppEndpointResyncResp parses an HTTP response from a GetAppEndpointResyncWithResponse call
func ParseGetAppEndpointResyncResp(rsp *http.Response) (*GetAppEndpointResyncResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppEndpointResyncResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResyncStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParsePostAppEndpointResyncResp parses an HTTP response from a PostAppEndpointResyncWithResponse call
func ParsePostAppEndpointResyncResp(rsp *http.Response) (*PostAppEndpointResyncResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAppEndpointResyncResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppEndpointAccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetAppServiceAuditLogStateResp parses an HTTP response from a GetAppServiceAuditLogStateWithResponse call
func ParseGetAppServiceAuditLogStateResp(rsp *http.Response) (*GetAppServiceAuditLogStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppServiceAuditLogStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateAppServiceAuditLogRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutAppServiceAuditLogStateResp parses an HTTP response from a PutAppServiceAuditLogStateWithResponse call
func ParsePutAppServiceAuditLogStateResp(rsp *http.Response) (*PutAppServiceAuditLogStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAppServiceAuditLogStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAppServiceAuditLogExportsResp parses an HTTP response from a ListAppServiceAuditLogExportsWithResponse call
func ParseListAppServiceAuditLogExportsResp(rsp *http.Response) (*ListAppServiceAuditLogExportsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppServiceAuditLogExportsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAuditExportDocs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAppServiceAuditLogExportResp parses an HTTP response from a PostAppServiceAuditLogExportWithResponse call
func ParsePostAppServiceAuditLogExportResp(rsp *http.Response) (*PostAppServiceAuditLogExportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAppServiceAuditLogExportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateClusterAuditLogExportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAppServiceAuditLogExportByIdResp parses an HTTP response from a GetAppServiceAuditLogExportByIdWithResponse call
func ParseGetAppServiceAuditLogExportByIdResp(rsp *http.Response) (*GetAppServiceAuditLogExportByIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppServiceAuditLogExportByIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAuditExportDocResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAppServiceAuditLogStreamingResp parses an HTTP response from a GetAppServiceAuditLogStreamingWithResponse call
func ParseGetAppServiceAuditLogStreamingResp(rsp *http.Response) (*GetAppServiceAuditLogStreamingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppServiceAuditLogStreamingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAuditLogStreamingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchAppServiceAuditLogStreamingResp parses an HTTP response from a PatchAppServiceAuditLogStreamingWithResponse call
func ParsePatchAppServiceAuditLogStreamingResp(rsp *http.Response) (*PatchAppServiceAuditLogStreamingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchAppServiceAuditLogStreamingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutAppServiceAuditLogStreamingResp parses an HTTP response from a PutAppServiceAuditLogStreamingWithResponse call
func ParsePutAppServiceAuditLogStreamingResp(rsp *http.Response) (*PutAppServiceAuditLogStreamingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAppServiceAuditLogStreamingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAppServiceCertificateResp parses an HTTP response from a GetAppServiceCertificateWithResponse call
func ParseGetAppServiceCertificateResp(rsp *http.Response) (*GetAppServiceCertificateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppServiceCertificateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCertificateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAppServicePrivateEndpointsResp parses an HTTP response from a DeleteAppServicePrivateEndpointsWithResponse call
func ParseDeleteAppServicePrivateEndpointsResp(rsp *http.Response) (*DeleteAppServicePrivateEndpointsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppServicePrivateEndpointsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAppServicePrivateEndpointsResp parses an HTTP response from a GetAppServicePrivateEndpointsWithResponse call
func ParseGetAppServicePrivateEndpointsResp(rsp *http.Response) (*GetAppServicePrivateEndpointsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppServicePrivateEndpointsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAppServicePrivateEndpointStateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAppServicePrivateEndpointsResp parses an HTTP response from a PostAppServicePrivateEndpointsWithResponse call
func ParsePostAppServicePrivateEndpointsResp(rsp *http.Response) (*PostAppServicePrivateEndpointsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAppServicePrivateEndpointsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAppServicePrivateEndpointsResp parses an HTTP response from a ListAppServicePrivateEndpointsWithResponse call
func ParseListAppServicePrivateEndpointsResp(rsp *http.Response) (*ListAppServicePrivateEndpointsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppServicePrivateEndpointsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPrivateEndpointsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePrivateEndpointRequestResp parses an HTTP response from a DeletePrivateEndpointRequestWithResponse call
func ParseDeletePrivateEndpointRequestResp(rsp *http.Response) (*DeletePrivateEndpointRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePrivateEndpointRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAcceptPrivateEndpointRequestResp parses an HTTP response from a AcceptPrivateEndpointRequestWithResponse call
func ParseAcceptPrivateEndpointRequestResp(rsp *http.Response) (*AcceptPrivateEndpointRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptPrivateEndpointRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAppServicePrivateEndpointsCommandResp parses an HTTP response from a GetAppServicePrivateEndpointsCommandWithResponse call
func ParseGetAppServicePrivateEndpointsCommandResp(rsp *http.Response) (*GetAppServicePrivateEndpointsCommandResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppServicePrivateEndpointsCommandResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePrivateEndpointCommandResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterAuditSettingsResp parses an HTTP response from a GetClusterAuditSettingsWithResponse call
func ParseGetClusterAuditSettingsResp(rsp *http.Response) (*GetClusterAuditSettingsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterAuditSettingsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetClusterAuditSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutClusterAuditSettingsResp parses an HTTP response from a PutClusterAuditSettingsWithResponse call
func ParsePutClusterAuditSettingsResp(rsp *http.Response) (*PutClusterAuditSettingsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutClusterAuditSettingsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuditLogEventIDsResp parses an HTTP response from a GetAuditLogEventIDsWithResponse call
func ParseGetAuditLogEventIDsResp(rsp *http.Response) (*GetAuditLogEventIDsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuditLogEventIDsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAuditLogEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAuditLogExportsResp parses an HTTP response from a ListAuditLogExportsWithResponse call
func ParseListAuditLogExportsResp(rsp *http.Response) (*ListAuditLogExportsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuditLogExportsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetClusterAuditLogExportsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuditLogExportResp parses an HTTP response from a PostAuditLogExportWithResponse call
func ParsePostAuditLogExportResp(rsp *http.Response) (*PostAuditLogExportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuditLogExportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateClusterAuditLogExportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuditLogExportResp parses an HTTP response from a GetAuditLogExportWithResponse call
func ParseGetAuditLogExportResp(rsp *http.Response) (*GetAuditLogExportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuditLogExportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetClusterAuditLogExportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClusterBackupsResp parses an HTTP response from a ListClusterBackupsWithResponse call
func ParseListClusterBackupsResp(rsp *http.Response) (*ListClusterBackupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClusterBackupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBackupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBackupCycleByIDResp parses an HTTP response from a DeleteBackupCycleByIDWithResponse call
func ParseDeleteBackupCycleByIDResp(rsp *http.Response) (*DeleteBackupCycleByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBackupCycleByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBackupByIDResp parses an HTTP response from a GetBackupByIDWithResponse call
func ParseGetBackupByIDResp(rsp *http.Response) (*GetBackupByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBackupByIDResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostRestoreResp parses an HTTP response from a PostRestoreWithResponse call
func ParsePostRestoreResp(rsp *http.Response) (*PostRestoreResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRestoreResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutBucketStorageBackendResp parses an HTTP response from a PutBucketStorageBackendWithResponse call
func ParsePutBucketStorageBackendResp(rsp *http.Response) (*PutBucketStorageBackendResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutBucketStorageBackendResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBucketsResp parses an HTTP response from a ListBucketsWithResponse call
func ParseListBucketsResp(rsp *http.Response) (*ListBucketsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBucketsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBucketsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostBucketResp parses an HTTP response from a PostBucketWithResponse call
func ParsePostBucketResp(rsp *http.Response) (*PostBucketResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBucketResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateBucketResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListFreeTierBucketsResp parses an HTTP response from a ListFreeTierBucketsWithResponse call
func ParseListFreeTierBucketsResp(rsp *http.Response) (*ListFreeTierBucketsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFreeTierBucketsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBucketsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateFreeTierBucketResp parses an HTTP response from a CreateFreeTierBucketWithResponse call
func ParseCreateFreeTierBucketResp(rsp *http.Response) (*CreateFreeTierBucketResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFreeTierBucketResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateBucketResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteFreeTierBucketByIDResp parses an HTTP response from a DeleteFreeTierBucketByIDWithResponse call
func ParseDeleteFreeTierBucketByIDResp(rsp *http.Response) (*DeleteFreeTierBucketByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFreeTierBucketByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFreeTierBucketByIDResp parses an HTTP response from a GetFreeTierBucketByIDWithResponse call
func ParseGetFreeTierBucketByIDResp(rsp *http.Response) (*GetFreeTierBucketByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFreeTierBucketByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBucketResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateFreeTierBucketResp parses an HTTP response from a UpdateFreeTierBucketWithResponse call
func ParseUpdateFreeTierBucketResp(rsp *http.Response) (*UpdateFreeTierBucketResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFreeTierBucketResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBucketByIDResp parses an HTTP response from a DeleteBucketByIDWithResponse call
func ParseDeleteBucketByIDResp(rsp *http.Response) (*DeleteBucketByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBucketByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBucketByIDResp parses an HTTP response from a GetBucketByIDWithResponse call
func ParseGetBucketByIDResp(rsp *http.Response) (*GetBucketByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBucketByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBucketResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutBucketResp parses an HTTP response from a PutBucketWithResponse call
func ParsePutBucketResp(rsp *http.Response) (*PutBucketResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutBucketResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCyclesResp parses an HTTP response from a ListCyclesWithResponse call
func ParseListCyclesResp(rsp *http.Response) (*ListCyclesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCyclesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCyclesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBackupsResp parses an HTTP response from a ListBackupsWithResponse call
func ParseListBackupsResp(rsp *http.Response) (*ListBackupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBackupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBackupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBackupScheduleResp parses an HTTP response from a DeleteBackupScheduleWithResponse call
func ParseDeleteBackupScheduleResp(rsp *http.Response) (*DeleteBackupScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBackupScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBackupScheduleResp parses an HTTP response from a GetBackupScheduleWithResponse call
func ParseGetBackupScheduleResp(rsp *http.Response) (*GetBackupScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetScheduledBackupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostBackupScheduleResp parses an HTTP response from a PostBackupScheduleWithResponse call
func ParsePostBackupScheduleResp(rsp *http.Response) (*PostBackupScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBackupScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutBackupScheduleResp parses an HTTP response from a PutBackupScheduleWithResponse call
func ParsePutBackupScheduleResp(rsp *http.Response) (*PutBackupScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutBackupScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostBackupResp parses an HTTP response from a PostBackupWithResponse call
func ParsePostBackupResp(rsp *http.Response) (*PostBackupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBackupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFlushBucketResp parses an HTTP response from a FlushBucketWithResponse call
func ParseFlushBucketResp(rsp *http.Response) (*FlushBucketResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FlushBucketResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetScopesResp parses an HTTP response from a GetScopesWithResponse call
func ParseGetScopesResp(rsp *http.Response) (*GetScopesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScopesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetScopesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostScopeResp parses an HTTP response from a PostScopeWithResponse call
func ParsePostScopeResp(rsp *http.Response) (*PostScopeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostScopeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteScopeByNameResp parses an HTTP response from a DeleteScopeByNameWithResponse call
func ParseDeleteScopeByNameResp(rsp *http.Response) (*DeleteScopeByNameResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScopeByNameResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetScopeByNameResp parses an HTTP response from a GetScopeByNameWithResponse call
func ParseGetScopeByNameResp(rsp *http.Response) (*GetScopeByNameResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScopeByNameResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetScopeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectionsResp parses an HTTP response from a GetCollectionsWithResponse call
func ParseGetCollectionsResp(rsp *http.Response) (*GetCollectionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCollectionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCollectionResp parses an HTTP response from a PostCollectionWithResponse call
func ParsePostCollectionResp(rsp *http.Response) (*PostCollectionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCollectionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCollectionByNameResp parses an HTTP response from a DeleteCollectionByNameWithResponse call
func ParseDeleteCollectionByNameResp(rsp *http.Response) (*DeleteCollectionByNameResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCollectionByNameResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectionByNameResp parses an HTTP response from a GetCollectionByNameWithResponse call
func ParseGetCollectionByNameResp(rsp *http.Response) (*GetCollectionByNameResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionByNameResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutCollectionResp parses an HTTP response from a PutCollectionWithResponse call
func ParsePutCollectionResp(rsp *http.Response) (*PutCollectionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutCollectionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertificateResp parses an HTTP response from a GetCertificateWithResponse call
func ParseGetCertificateResp(rsp *http.Response) (*GetCertificateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertificateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCertificateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCloudSnapshotBackupsResp parses an HTTP response from a ListCloudSnapshotBackupsWithResponse call
func ParseListCloudSnapshotBackupsResp(rsp *http.Response) (*ListCloudSnapshotBackupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCloudSnapshotBackupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCloudSnapshotBackupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateCloudSnapshotBackupResp parses an HTTP response from a CreateCloudSnapshotBackupWithResponse call
func ParseCreateCloudSnapshotBackupResp(rsp *http.Response) (*CreateCloudSnapshotBackupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCloudSnapshotBackupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateCloudSnapshotBackupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListGeographicRegionsResp parses an HTTP response from a ListGeographicRegionsWithResponse call
func ParseListGeographicRegionsResp(rsp *http.Response) (*ListGeographicRegionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGeographicRegionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloudSnapshotGeographicRegions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseListCloudSnapshotRestoresResp parses an HTTP response from a ListCloudSnapshotRestoresWithResponse call
func ParseListCloudSnapshotRestoresResp(rsp *http.Response) (*ListCloudSnapshotRestoresResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCloudSnapshotRestoresResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCloudSnapshotRestoresResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCloudSnapshotBackupResp parses an HTTP response from a DeleteCloudSnapshotBackupWithResponse call
func ParseDeleteCloudSnapshotBackupResp(rsp *http.Response) (*DeleteCloudSnapshotBackupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCloudSnapshotBackupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEditCloudSnapshotBackupRetentionResp parses an HTTP response from a EditCloudSnapshotBackupRetentionWithResponse call
func ParseEditCloudSnapshotBackupRetentionResp(rsp *http.Response) (*EditCloudSnapshotBackupRetentionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditCloudSnapshotBackupRetentionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRestoreResp parses an HTTP response from a RestoreWithResponse call
func ParseRestoreResp(rsp *http.Response) (*RestoreResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateCloudSnapshotRestoreResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCloudSnapshotBackupScheduleResp parses an HTTP response from a DeleteCloudSnapshotBackupScheduleWithResponse call
func ParseDeleteCloudSnapshotBackupScheduleResp(rsp *http.Response) (*DeleteCloudSnapshotBackupScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCloudSnapshotBackupScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCloudSnapshotBackupScheduleResp parses an HTTP response from a GetCloudSnapshotBackupScheduleWithResponse call
func ParseGetCloudSnapshotBackupScheduleResp(rsp *http.Response) (*GetCloudSnapshotBackupScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCloudSnapshotBackupScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCloudSnapshotBackupScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpsertCloudSnapshotBackupScheduleResp parses an HTTP response from a UpsertCloudSnapshotBackupScheduleWithResponse call
func ParseUpsertCloudSnapshotBackupScheduleResp(rsp *http.Response) (*UpsertCloudSnapshotBackupScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertCloudSnapshotBackupScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseAssociateCMEKResp parses an HTTP response from a AssociateCMEKWithResponse call
func ParseAssociateCMEKResp(rsp *http.Response) (*AssociateCMEKResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssociateCMEKResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUnassociateCMEKResp parses an HTTP response from a UnassociateCMEKWithResponse call
func ParseUnassociateCMEKResp(rsp *http.Response) (*UnassociateCMEKResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassociateCMEKResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDataAPIStatusResp parses an HTTP response from a GetDataAPIStatusWithResponse call
func ParseGetDataAPIStatusResp(rsp *http.Response) (*GetDataAPIStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataAPIStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Enabled Indicates whether Data API is enabled or disabled on the cluster.
			Enabled bool `json:"enabled"`

			// EnabledForNetworkPeering Whether network peering was enabled or disabled for the Data API.
			EnabledForNetworkPeering bool `json:"enabledForNetworkPeering"`

			// State Current status of the Data API.  Here are the possible values:
			//
			//   - `enabled`: Data API is active and fully functional
			//   - `enabling`: Data API is in the process of being enabled
			//   - `disabled`: Data API is not enabled with no infrastructure being deployed for it at the moment
			//   - `disabling`: Data API is in the process of being disabled
			//   - `configuring`: Data API is in the process of being configured, thus here should not be any downtime for existing clients,
			//                    but new functionality like network peering will not be available until status is enabled
			State GetDataAPIStatus200State `json:"state"`

			// StateForNetworkPeering Current status for vpc peering for Data API.  Here are the possible values:
			//
			//   - `enabled`: network peering it is currently enabled
			//   - `enabling`: network peering is in the process of being enabled
			//   - `disabled`: network peering it is not enabled with no infrastructure being deployed for it at the moment
			//   - `disabling`: network peering is in the process of being disabled
			StateForNetworkPeering GetDataAPIStatus200StateForNetworkPeering `json:"stateForNetworkPeering"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDataApiAndPeeringResp parses an HTTP response from a UpdateDataApiAndPeeringWithResponse call
func ParseUpdateDataApiAndPeeringResp(rsp *http.Response) (*UpdateDataApiAndPeeringResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDataApiAndPeeringResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDataAPIPrivateEndpointCommandResp parses an HTTP response from a GetDataAPIPrivateEndpointCommandWithResponse call
func ParseGetDataAPIPrivateEndpointCommandResp(rsp *http.Response) (*GetDataAPIPrivateEndpointCommandResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataAPIPrivateEndpointCommandResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePrivateEndpointCommandResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListDataAPIPrivateEndpointsResp parses an HTTP response from a ListDataAPIPrivateEndpointsWithResponse call
func ParseListDataAPIPrivateEndpointsResp(rsp *http.Response) (*ListDataAPIPrivateEndpointsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDataAPIPrivateEndpointsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPrivateEndpointsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAssociateDataAPIPrivateEndpointRequestResp parses an HTTP response from a AssociateDataAPIPrivateEndpointRequestWithResponse call
func ParseAssociateDataAPIPrivateEndpointRequestResp(rsp *http.Response) (*AssociateDataAPIPrivateEndpointRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssociateDataAPIPrivateEndpointRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDisassociateDataAPIPrivateEndpointResp parses an HTTP response from a DisassociateDataAPIPrivateEndpointWithResponse call
func ParseDisassociateDataAPIPrivateEndpointResp(rsp *http.Response) (*DisassociateDataAPIPrivateEndpointResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisassociateDataAPIPrivateEndpointResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListMtlsCertificatesResp parses an HTTP response from a ListMtlsCertificatesWithResponse call
func ParseListMtlsCertificatesResp(rsp *http.Response) (*ListMtlsCertificatesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMtlsCertificatesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MtlsCertificates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddMtlsCertificateResp parses an HTTP response from a AddMtlsCertificateWithResponse call
func ParseAddMtlsCertificateResp(rsp *http.Response) (*AddMtlsCertificateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMtlsCertificateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddMtlsCertificateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteMtlsCertificateResp parses an HTTP response from a DeleteMtlsCertificateWithResponse call
func ParseDeleteMtlsCertificateResp(rsp *http.Response) (*DeleteMtlsCertificateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMtlsCertificateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMtlsCertificateResp parses an HTTP response from a GetMtlsCertificateWithResponse call
func ParseGetMtlsCertificateResp(rsp *http.Response) (*GetMtlsCertificateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMtlsCertificateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MtlsCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutMtlsCertificateResp parses an HTTP response from a PutMtlsCertificateWithResponse call
func ParsePutMtlsCertificateResp(rsp *http.Response) (*PutMtlsCertificateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutMtlsCertificateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMtlsConfigurationResp parses an HTTP response from a GetMtlsConfigurationWithResponse call
func ParseGetMtlsConfigurationResp(rsp *http.Response) (*GetMtlsConfigurationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMtlsConfigurationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetMtlsConfigurationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateMtlsConfigurationResp parses an HTTP response from a UpdateMtlsConfigurationWithResponse call
func ParseUpdateMtlsConfigurationResp(rsp *http.Response) (*UpdateMtlsConfigurationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMtlsConfigurationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListNetworkPeeringRecordsResp parses an HTTP response from a ListNetworkPeeringRecordsWithResponse call
func ParseListNetworkPeeringRecordsResp(rsp *http.Response) (*ListNetworkPeeringRecordsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNetworkPeeringRecordsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListNetworkPeeringRecordsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostNetworkPeeringResp parses an HTTP response from a PostNetworkPeeringWithResponse call
func ParsePostNetworkPeeringResp(rsp *http.Response) (*PostNetworkPeeringResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNetworkPeeringResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateNetworkPeeringResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAzureVnetPeeringCommandResp parses an HTTP response from a GetAzureVnetPeeringCommandWithResponse call
func ParseGetAzureVnetPeeringCommandResp(rsp *http.Response) (*GetAzureVnetPeeringCommandResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAzureVnetPeeringCommandResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAzureVNetPeeringCommandResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNetworkPeeringResp parses an HTTP response from a DeleteNetworkPeeringWithResponse call
func ParseDeleteNetworkPeeringResp(rsp *http.Response) (*DeleteNetworkPeeringResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNetworkPeeringResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNetworkPeeringRecordResp parses an HTTP response from a GetNetworkPeeringRecordWithResponse call
func ParseGetNetworkPeeringRecordResp(rsp *http.Response) (*GetNetworkPeeringRecordResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkPeeringRecordResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetNetworkPeeringRecordResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOnOffScheduleResp parses an HTTP response from a DeleteOnOffScheduleWithResponse call
func ParseDeleteOnOffScheduleResp(rsp *http.Response) (*DeleteOnOffScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOnOffScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOnOffScheduleResp parses an HTTP response from a GetOnOffScheduleWithResponse call
func ParseGetOnOffScheduleResp(rsp *http.Response) (*GetOnOffScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOnOffScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterOnOffSchedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOnOffScheduleResp parses an HTTP response from a PostOnOffScheduleWithResponse call
func ParsePostOnOffScheduleResp(rsp *http.Response) (*PostOnOffScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOnOffScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutOnOffScheduleResp parses an HTTP response from a PutOnOffScheduleWithResponse call
func ParsePutOnOffScheduleResp(rsp *http.Response) (*PutOnOffScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutOnOffScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDisablePrivateEndpointServiceResp parses an HTTP response from a DisablePrivateEndpointServiceWithResponse call
func ParseDisablePrivateEndpointServiceResp(rsp *http.Response) (*DisablePrivateEndpointServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisablePrivateEndpointServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPrivateEndpointServiceStatusResp parses an HTTP response from a GetPrivateEndpointServiceStatusWithResponse call
func ParseGetPrivateEndpointServiceStatusResp(rsp *http.Response) (*GetPrivateEndpointServiceStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPrivateEndpointServiceStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPrivateEndpointServiceStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEnablePrivateEndpointServiceResp parses an HTTP response from a EnablePrivateEndpointServiceWithResponse call
func ParseEnablePrivateEndpointServiceResp(rsp *http.Response) (*EnablePrivateEndpointServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnablePrivateEndpointServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPrivateEndpointCommandResp parses an HTTP response from a GetPrivateEndpointCommandWithResponse call
func ParseGetPrivateEndpointCommandResp(rsp *http.Response) (*GetPrivateEndpointCommandResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPrivateEndpointCommandResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePrivateEndpointCommandResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPrivateEndpointsResp parses an HTTP response from a ListPrivateEndpointsWithResponse call
func ParseListPrivateEndpointsResp(rsp *http.Response) (*ListPrivateEndpointsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPrivateEndpointsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPrivateEndpointsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAcceptPrivateEndpointResp parses an HTTP response from a AcceptPrivateEndpointWithResponse call
func ParseAcceptPrivateEndpointResp(rsp *http.Response) (*AcceptPrivateEndpointResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptPrivateEndpointResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePrivateEndpointResp parses an HTTP response from a DeletePrivateEndpointWithResponse call
func ParseDeletePrivateEndpointResp(rsp *http.Response) (*DeletePrivateEndpointResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePrivateEndpointResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIndexBuildStatusResp parses an HTTP response from a IndexBuildStatusWithResponse call
func ParseIndexBuildStatusResp(rsp *http.Response) (*IndexBuildStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IndexBuildStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexBuildStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IndexNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListIndexDefinitionsResp parses an HTTP response from a ListIndexDefinitionsWithResponse call
func ParseListIndexDefinitionsResp(rsp *http.Response) (*ListIndexDefinitionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIndexDefinitionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIndexDefinitionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IndexNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseManageQueryIndexesResp parses an HTTP response from a ManageQueryIndexesWithResponse call
func ParseManageQueryIndexesResp(rsp *http.Response) (*ManageQueryIndexesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManageQueryIndexesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexDDLResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IndexNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIndexDefinitionResp parses an HTTP response from a IndexDefinitionWithResponse call
func ParseIndexDefinitionResp(rsp *http.Response) (*IndexDefinitionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IndexDefinitionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexPropertiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IndexNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClusterReplicationsResp parses an HTTP response from a ListClusterReplicationsWithResponse call
func ParseListClusterReplicationsResp(rsp *http.Response) (*ListClusterReplicationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClusterReplicationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListClusterReplicationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateReplicationResp parses an HTTP response from a CreateReplicationWithResponse call
func ParseCreateReplicationResp(rsp *http.Response) (*CreateReplicationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateReplicationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateReplicationJSONResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteReplicationResp parses an HTTP response from a DeleteReplicationWithResponse call
func ParseDeleteReplicationResp(rsp *http.Response) (*DeleteReplicationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReplicationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReplicationResp parses an HTTP response from a GetReplicationWithResponse call
func ParseGetReplicationResp(rsp *http.Response) (*GetReplicationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReplicationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetReplicationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateReplicationResp parses an HTTP response from a UpdateReplicationWithResponse call
func ParseUpdateReplicationResp(rsp *http.Response) (*UpdateReplicationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateReplicationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePauseReplicationResp parses an HTTP response from a PauseReplicationWithResponse call
func ParsePauseReplicationResp(rsp *http.Response) (*PauseReplicationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PauseReplicationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseResumeReplicationResp parses an HTTP response from a ResumeReplicationWithResponse call
func ParseResumeReplicationResp(rsp *http.Response) (*ResumeReplicationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeReplicationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSampleBucketsResp parses an HTTP response from a ListSampleBucketsWithResponse call
func ParseListSampleBucketsResp(rsp *http.Response) (*ListSampleBucketsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSampleBucketsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBucketsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSampleBucketResp parses an HTTP response from a PostSampleBucketWithResponse call
func ParsePostSampleBucketResp(rsp *http.Response) (*PostSampleBucketResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSampleBucketResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PostSampleBucketResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSampleDataByBucketIDResp parses an HTTP response from a DeleteSampleDataByBucketIDWithResponse call
func ParseDeleteSampleDataByBucketIDResp(rsp *http.Response) (*DeleteSampleDataByBucketIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSampleDataByBucketIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSampleBucketByIdResp parses an HTTP response from a GetSampleBucketByIdWithResponse call
func ParseGetSampleBucketByIdResp(rsp *http.Response) (*GetSampleBucketByIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSampleBucketByIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBucketResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListDatabaseCredentialsResp parses an HTTP response from a ListDatabaseCredentialsWithResponse call
func ParseListDatabaseCredentialsResp(rsp *http.Response) (*ListDatabaseCredentialsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDatabaseCredentialsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDatabaseCredentialsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDatabaseCredentialResp parses an HTTP response from a PostDatabaseCredentialWithResponse call
func ParsePostDatabaseCredentialResp(rsp *http.Response) (*PostDatabaseCredentialResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDatabaseCredentialResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateDatabaseCredentialResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDatabaseCredentialResp parses an HTTP response from a DeleteDatabaseCredentialWithResponse call
func ParseDeleteDatabaseCredentialResp(rsp *http.Response) (*DeleteDatabaseCredentialResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDatabaseCredentialResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDatabaseCredentialResp parses an HTTP response from a GetDatabaseCredentialWithResponse call
func ParseGetDatabaseCredentialResp(rsp *http.Response) (*GetDatabaseCredentialResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseCredentialResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDatabaseCredentialResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutDatabaseCredentialResp parses an HTTP response from a PutDatabaseCredentialWithResponse call
func ParsePutDatabaseCredentialResp(rsp *http.Response) (*PutDatabaseCredentialResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutDatabaseCredentialResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectEventsResp parses an HTTP response from a ListProjectEventsWithResponse call
func ParseListProjectEventsResp(rsp *http.Response) (*ListProjectEventsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectEventsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProjectEventByIDResp parses an HTTP response from a GetProjectEventByIDWithResponse call
func ParseGetProjectEventByIDResp(rsp *http.Response) (*GetProjectEventByIDResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectEventByIDResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEventResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectReplicationsResp parses an HTTP response from a ListProjectReplicationsWithResponse call
func ParseListProjectReplicationsResp(rsp *http.Response) (*ListProjectReplicationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectReplicationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListProjectReplicationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUsersResp parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResp(rsp *http.Response) (*ListUsersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostUserResp parses an HTTP response from a PostUserWithResponse call
func ParsePostUserResp(rsp *http.Response) (*PostUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserResp parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResp(rsp *http.Response) (*DeleteUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserResp parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResp(rsp *http.Response) (*GetUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchUserResp parses an HTTP response from a PatchUserWithResponse call
func ParsePatchUserResp(rsp *http.Response) (*PatchUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AccessForbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
